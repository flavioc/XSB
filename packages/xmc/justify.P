/* File:      justify.P
** Author(s): Abhik Roychoudhury
** Modified:  C.R.Ramakrishnan
** Contact:   lmc@cs.sunysb.edu
** 
** Copyright (C) SUNY at Stony Brook, 1998-2000
** 
** XMC is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XMC is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XMC; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id$
** 
*/

% Generic justifier for XSB programs; allows justification of T/F/U values
% NOTE : Any program predicate that depends recursively 
%        on itself through negation must be tabled.
%        This ensures that the delay list of any undefined 
%        atom can be accessed (say via get_residual/2).

:- dynamic seen/2.
?- assert((:- index seen/2-trie)).
:- dynamic node/3.
?- assert((:- index node/3-trie)).
:- dynamic edge/2.
?- assert((:- index edge/2-trie)).

	

justify(G, _, Root) :- 
	initialize_all,
	complete_call(G), just(pos(G), 0, -1, [], Root),
	true.

complete_call(G) :- call(G) ; true.


% just(L)
% ---  Given a literal L, (ancestor list Anc is implicit)
% ---  constructs the justification of L.

just(G, _, _, Ancs, Node) :-
	seen(G, Node),	% if seen before,
	\+ ancestorchk(Node, _AncDFS, Ancs), % and not an ancestor,
				% then justification of G must be complete
				% (on a sibling DAG) so just return 
				% the node number
	!.

just(leaf(G), _DFS, _LastNeg, _Ancs, Node) :-
	proved_once(leaf(G), TV),
	add_node(leaf(G), TV, Node).

just(pos(G), DFS, LastNeg, Ancs, CurrNode) :-
	proved_once(pos(G), TV), 
	add_node(pos(G), TV, Node),
	NDFS is DFS+1,
	( TV==true
	    -> ( ancestorchk(Node, _AncDFS, Ancs)
		   -> 
% A cycle can never be a valid justification for "t"
		      fail
                   ;
		      findonerule(G, Rule),
		      ( Rule == []
		          -> add_node(fact,true,FN), JC=[FN]
		          ;  add_to_ancestor(Node, DFS, Ancs, NAncs),
			     justconj(Rule, NDFS, LastNeg, NAncs, JC) 
		      ),
		      CurrNode = Node,
	              add_edges(CurrNode, JC)
	       )
	    ; TV == undef ->
               ( (tabled_goal(G), ancestorchk(Node, _AncDFS, Ancs))
	           -> (  
% Any cycle of "u"s would be a valid justification of a "u"
% so, no need to check
			 add_node(ancestor(Node),undef,CurrNode)
		      )
	           ;  (  findfailsandrules(G, FailRules),
			 add_to_ancestor(Node, DFS, Ancs, NAncs),
			 justconj(FailRules, NDFS, LastNeg, NAncs, JC),
			 CurrNode = Node,
			 add_edges(CurrNode, JC)
		      )
	       )
	    ; % TV=false
	       ( (tabled_goal(G), ancestorchk(Node, AncDFS, Ancs))
	           -> ( LastNeg < AncDFS,
% A cycle may be a valid justification of "f" as long as
% it *doesnt* contain a negation
			add_node(ancestor(Node),false,CurrNode)
		      )
	           ;  ( findfails(G, Fails),
			( Fails == []
			    -> add_node(fails,false,FN), JC=[FN]
			    ;  add_to_ancestor(Node, DFS, Ancs, NAncs),
			       justconj(Fails, NDFS, LastNeg, NAncs, JC)
			),
			CurrNode = Node,
			add_edges(CurrNode, JC)
		      )
	       )
        ).

just(neg(G), DFS, _LastNeg, Ancs, Node) :- 
	proved(G, TV1),
	toggle_tv(TV1, TV),
	add_node(neg(G), TV, Node),
	NDFS is DFS+1,
	add_to_ancestor(Node, DFS, Ancs, NAncs),
	just(G, NDFS, DFS, NAncs, JC),
	add_edges(Node, [JC]).


justconj([], _, _, _Ancs, []).
justconj([G|Gs], DFS, LastNeg, Ancs, JCs) :- 
	just(G, DFS, LastNeg, Ancs, JC),
	justconj(Gs, DFS, LastNeg, Ancs, Jrest),
	insert(JC, Jrest, JCs).

insert(X, L, L) :- member(X, L), !.
insert(X, L, [X|L]).

add_node(pos(F), TV, Node) :-
	(tabled_goal(F)
	   -> (seen(pos(F), Node)
	        -> node(Node, _, TV)
	        ;  coninc(nodenum),
		   conget(nodenum, NodeNum),
		   Node = num(NodeNum),
		   assert(seen(pos(F), Node)),
		   assert(node(Node, F, TV))
	      )
	   ;  Node = full(F, TV, _Children)
	).
add_node(neg(F), TV, full(F, TV, _Children)).
add_node(leaf(F), TV, full(F, TV, [])).
add_node(fact, _TV, fact).
add_node(fails, _TV, fails).
add_node(ancestor(A), TV, ancestor(A, TV)).
	
add_edges(num(Parent), Children) :-
	retractall(edge(num(Parent), _)),
	assert(edge(num(Parent), Children)).
add_edges(full(_, _, Children), Children).

add_to_ancestor(num(Node), DFS, Ancs, [anc(Node, DFS)|Ancs]) :- !.
add_to_ancestor(_,_,Ancs, Ancs).

ancestorchk(num(Node), DFS, Ancs) :-
	member(anc(Node,DFS), Ancs).

%----------------------------------------------------------------
initialize_all :-
	conset(nodenum, 0),
	retractall(node(_,_,_)),
	retractall(seen(_,_)),
	retractall(edge(_,_)),
	assert(node(full(X,Y,_),X,Y)),
	assert(node(ancestor(A,T),ancestor(A),T)),
	assert(node(fact,fact,true)),
	assert(node(fails,fails,false)),
	assert(edge(full(_,_,Z), Z)).

%----------------------------------------------------------------
negated_goal(\+(G), G).
negated_goal(not(G), G).
negated_goal(tnot(G), G).
%negated_goal('t not'(G), G).
negated_goal(sk_not(G), G).	% changed 't not' to sk_not by Yifei

%----------------------------------------------------------------

proved_once(G, TV) :- proved(G, TV), close_open_tables, !.

% proved(G, TruthValue)
% ---  Finding truth value of a single literal.

proved_list([G1|Gs], TV) :- 
	proved(G1, TV1),
	(TV1 = false
		-> TV = false
		; proved_list(Gs, TV)
	).
proved_list([], true).

proved(neg(G), TV) :-
	proved(G, TV1),
	toggle_tv(TV1, TV).
proved(leaf(G), TV) :- 
	proved_nt(G, TV).
proved(pos(G), TV) :- 
	(tabled_goal(G)
		-> proved_tab(G, TV)
		;  proved_nt(G, TV)
	).

proved_nt(G, true) :- call(G).
proved_nt(G, false) :- \+((call(G), close_open_tables, !)).

proved_tab(G, TV) :-
	\+ get_calls_for_table(G, _), !, 
	complete_call(G), 
	proved_tab(G, TV).
proved_tab(G,true) :- 
	setof(G, get_residual(G, []), List), !, member(G, List).
	% this is required; do not change setof to findall
        % illustration r(b) in p80.P of wfs_tests
proved_tab(G, undef) :- 
	setof(G, get_residual(G, [_|_]), List), !, member(G, List).
        % need to make sure we do not return mutiple ans.
        % for the same undef. atom with diff. delay lists.
proved_tab(G, false) :- \+ get_residual(G, _).

%-----------------------------------------------------------------------
%
% findonerule(G, B)
% ---- finds a clause of G (with body B) which can be used to prove G

findonerule(Goal,Body) :-
	get_clause(Goal,Body), alltrue(Body).

% alltrue(ClauseBody, ListofLiterals)
% --------  Checking the truth of a clause body.

alltrue([]).
alltrue([G1|Gs]) :- proved(G1,true), alltrue(Gs).

% generate all false instances of all the clauses.
% for each instance return "any" failed body literal.

findfails(Goal, Fails) :-
	findall(Body, (get_clause(Goal,Body), falseinst(Body)), BodyList),
	failedlits(BodyList, Fails).

falseinst([G1|Gs]) :- (  proved(G1, false) ;
                            (true_or_undef(G1), falseinst(Gs))
                          ).
% falseinst([]) will always fail

failedlits([], []).
failedlits([Bd|Rest], [Lit|Fails]) :-
	findfalselit(Bd, Lit), 
	failedlits(Rest, Fails).


% Nondeterministically find a false literal.
% Can be backtracked to another choice if the current choice results
% in a cyclic justification of a true literal.

findfalselit([G1|Gs], Fg) :- 
	( proved(G1, false) 
		-> (Fg = G1 ; findfalselit(Gs, Fg))
                ;  findfalselit(Gs, Fg)
	).

%---------------------------------------------------------------------------

% find all instances of all the clauses.
% for the false instances return any false lit.
% for the other instances return the entire body, since all 
% of the body lits have to be shown as true/undef.

findfailsandrules(Goal,FailRules) :-
	findall((TV, Body), (get_clause(Goal, Body), ufinst(Body, TV)), 
			BodyList),
        failsandrules(BodyList, FailRules).

ufinst(Body) :- (falseinst(Body), TV=false) ; (undefinst(Body), TV=undef).

failsandrules([], []).
failsandrules([(TV,Bd)|Rest], FR) :-
	failorrule(TV, Bd, FR1),
        failsandrules(Rest, FR2), 
        append(FR1, FR2, FR).

failorrule(false, Body, [Lit]) :- 
	findfalselit(Body,Lit).
failorrule(undef, Body, Body).	% ufinst has already certified
				% that each literal in Body is t/u.

undefinst([G1|Gs]) :- (   (proved(G1, undef), alltrue_or_undef(Gs))
                            ;  (proved(G1, true), undefinst(Gs))
                           ).

alltrue_or_undef([]).
alltrue_or_undef([G1|Gs]) :- true_or_undef(G1), alltrue_or_undef(Gs).

%-----------------------------------------------------------------

true_or_undef(G) :- proved(G, true).
true_or_undef(G) :- proved(G, undef).

toggle_tv(true, false).
toggle_tv(false, true).
toggle_tv(undef, undef). 

tabled_goal(G) :- predicate_property(G, tabled).

builtin(G) :- predicate_property(G, built_in).

get_clause(G, Conj) :- rule(G, B), member(Conj, B).

%%%%%%%%%%%%%%%%
% Code to initialize justifier with appropriate program rules
%%%%%%%%%%%%%%%%

just_init(PgmFiles, AnnotFile) :-
	load_dyn(AnnotFile),
	just_cleanup,
	seeing(OF),
	load_pgms(PgmFiles),
	load_builtin_preds,
	see(OF).

load_pgms([]) :- !.
load_pgms([P|Ps]) :- !, 
	load_pgms(P),
	load_pgms(Ps).
load_pgms(PgmFile) :- 
	see(PgmFile),
	load_pgm,
	seen.

load_pgm :-
	repeat,
	read(Rule),
	(Rule = end_of_file
		-> true
		; (Rule = ':-'(Directive)
			-> ( Directive = table(PredSpec)
				-> assert(tabled_pred(PredSpec))
				;  true	% skip other directives
			   )
			;  ( Rule = ':-'(Head, Body)
				-> (builtin_pred(Head)
				      -> true
				      ; (convert((Head;Body),[[pos(CH)]|CB]),
					assert(rule(CH, CB)))
				   )
				;  assert(rule(Rule, [[]]))
			   )
		   ), fail
	).


convert(G, [[pos(G)]]) :- var(G), !.
convert(true, [[]]) :- !.
convert((G1 '->' G2 ; G3), C) :- !,
	convert(((G1, G2); (not(G1), G3)), C).
convert((G1 '->' G2), C) :- !,
	convert((G1, G2), C).
convert((G1; G2), C) :- !,
	convert(G1, C1),
	convert(G2, C2),
	append(C1, C2, C).
convert((G1, G2), C) :- !,
	convert(G1, C1),
	convert(G2, C2),
	product(C1, C2, C).
convert(G, C) :- 
	negated_goal(G, NG),!,
	convert(NG, C1),
	(C1 = [[NC]]	-> C=[[neg(NC)]]
			; writeln('++ERROR: conjunction/disjunction in scope of not!'(NG)),
				C=[[]]
	).
convert(G, [[leaf(G)]]) :-
	(builtin(G); leaf(G)), !.
convert(G, [[pos(G)]]).

product(L1, L2, L) :-
	bagof(C, choose_from(L1, L2, C), L).
choose_from(L1, L2, C) :-
	member(C1, L1), member(C2, L2), append(C1, C2, C).

builtin_pred(forall(_,_,_)).
load_builtin_preds :-
	assert(rule(forall(_,A,C), [[neg(pos(exists_ce(A,C)))]])),
	assert(rule(exists_ce(A,C), [[pos(A), neg(pos(C))]])),
	assert((exists_ce(A,C) :- A, not(C))).

just_cleanup :-
	retractall(rule(_,_)),
	retractall(tabled_pred(_)).
