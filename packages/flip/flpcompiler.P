/* File:      flpcompiler.P
** Author(s): Bertram Ludaescher
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) Bertram Ludaescher, 1998
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id$
** 
*/


:- export comp/2.
:- import append/3, member/2 from basics.

:- dynamic ctr/2.
:- retractall(ctr(_,_)),asserta(ctr(gensym,0)).

%%% comp(+Complex_rule,-Set_of_flat_rules)

%comp(rule(Hs,Bs),Rules) :-
%	!,
%	flatten_list(Hs,H1s),
%	flatten_list(Bs,B1s),
%	append(B1s,[ensure_goals(H1s)],B2s),
%	subst_vars(H1s,H2s,_HeadVars),
%	subst_vars(B2s,B3s,Head_and_BodyVars),
%	(H2s=[Head]
%	-> Rules=[rule(Head,B3s)]
%	;  gensym(aux_,Aux),
%	   NewHead=..[Aux|Head_and_BodyVars],
%	   multiply(H2s,[NewHead],Head_C),
%	   Rules=[rule(NewHead,B3s)|Head_C]
%	).

comp(rule(Hs,Bs),Rules) :-
	!,
	flatten_list(Hs,H1s),
	flatten_list(Bs,B1s),
	subst_vars(H1s,H2s,HeadVars),
	subst_vars(B1s,B2s,BodyVars),
	findall(X,
		(member(X,HeadVars), \+ member(X,BodyVars)),
		UVars), 
	(UVars=[]
	-> true
	;  write('%%% *Warning* unbound in rule: '),
	   write(UVars),nl
	),
	(H2s=[Head]
	-> Rules=[rule(Head,B2s)]
	;  gensym(aux_,Aux),
	   NewHead=..[Aux|BodyVars],
	   multiply(H2s,[NewHead],Head_C),
	   Rules=[rule(NewHead,B2s)|Head_C]
	).

comp(query(Bs),[query(B2s,Var_Match1)]) :-
	!,
	flatten_list(Bs,B1s),
	subst_vars_match(B1s,B2s,Var_Match),
	remove_anonymous(Var_Match,Var_Match1).	% remove `_' from the match-list

comp(fact(Hs),[fact(H2s)]) :-
	!,
	flatten_list(Hs,H1s),
	subst_vars(H1s,H2s,HeadVars),
	(HeadVars=[]
	-> true
	;  write('%%% *Warning* unbound in fact: '),
	   write(HeadVars),nl
	).
%comp(fact(Hs),Rules) :-
%	!,
%	comp(rule(Hs,[]),Rules).


multiply([],_,[]).
multiply([H|Hs],B, [rule(H,B)|Rest]) :-
	multiply(Hs,B,Rest).

%%% flatten(+F_Term_list,-Flat_list)
flatten_list([],[]).
flatten_list([X|Xs], Ys) :-
	flatten(X,_,X_C),
	append(X_C,Xs_C,Ys),
	flatten_list(Xs,Xs_C).

%%% flatten(+F_Term,-F_TermV,-F_TermC)
% flatten an F_Term
% F_TermV: object value
% F_TermC: generated code

flatten(non(R),not_used,[not(R_C1)]) :-
	% flatten(non(...)...) is a hack: just assume 'not(X)' will do!
	!,
	flatten(R,_,R_C),
	list_to_conj(R_C,R_C1).

flatten(pterm(P,Args),not_used,P_C) :-
	!,
	flatten_pathlist(Args,Args_V,Args_C),
	Val=..[P|Args_V],
	append(Args_C,[Val],P_C).

flatten(fn(F,Args),Val,F_C) :-
	!,
	flatten_pathlist(Args,Args_V,F_C),
	Val=..[F|Args_V].

flatten(spterm(S,P1,P2),no_val,P_C) :-
	!,
	flatten(P1,P1_V,P1_C),
	flatten(P2,P2_V,P2_C),
	Code=..[S,P1_V,P2_V],
	append(P1_C,P2_C,P3_C),
	append(P3_C,[Code],P_C).

flatten(ref(O,'$self',Spec),O_V,Ref_C) :-
	!,
	flatten(O,O_V,O_C),
	flatten_speclist(Spec,O_V,Spec_C),
	append(O_C,Spec_C,Ref_C).

flatten(ref(O,Mref,Spec),Ref_V,Ref_C) :-
	!,
	flatten(O,O_V,O_C),
	flatten_mref(Mref,Arr,Mref_V,Mref_C),
	new_pathvar(Ref_V),
	Code=..[Arr,O_V,Mref_V,Ref_V],
	append(O_C,Mref_C,Ref1_C),
	append(Ref1_C,[Code],Ref2_C),
	flatten_speclist(Spec,Ref_V,Spec_C),
	append(Ref2_C,Spec_C,Ref_C).

flatten(identifier(X),X,[]) :- !.
flatten(var(_V,Name),'$v'(Name),[]) :- !.
flatten(string(Chars),Chars,[]) :- !.
flatten(number(N),N,[]) :- !.

flatten(X,X,[]) :- !.



%%%
flatten_mref(mref(Arr,MA),Arr,MA_V,MA_C) :-
	flatten_methappl(MA,MA_V,MA_C).

flatten_methappl('@'(M,Args),MA_V,MA_C) :-
	flatten(M,M_V,M_C),
	flatten_pathlist(Args,Args_Vs,Args_C),
	MA_V=..['@',M_V|Args_Vs],
	append(M_C,Args_C,MA_C).
	

%flatten_speclist([],O,['$ex'(O)]).
%flatten_speclist([S|Ss],O,Ss_C) :-
%	flatten_speclist1([S|Ss],O,Ss_C).


flatten_speclist([],_,[]).
flatten_speclist([S|Ss],Obj,Ss1_C) :-
	flatten_spec(S,Obj,S_C),
	flatten_speclist(Ss,Obj,Ss_C),
	append(S_C,Ss_C,Ss1_C).


flatten_spec(isa_(Class),Obj,Spec_C) :-
	flatten(Class,Class_V,Class_C),
	append(Class_C,[isa_(Obj,Class_V)],Spec_C).

flatten_spec(sub_(Class),Obj,Spec_C) :-
	flatten(Class,Class_V,Class_C),
	append(Class_C,[sub_(Obj,Class_V)],Spec_C).

flatten_spec(fun(MA,Arr,Res),Obj,Spec_C) :-
	flatten_methappl(MA,MA_V,MA_C),
	flatten(Res,Res_V,Res_C),
	append(MA_C,Res_C,Spec1_C),
	Code=..[Arr,Obj,MA_V,Res_V],
	append(Spec1_C,[Code],Spec_C).

flatten_spec(set(MA,Arr,Ps),Obj,Spec_C) :-
	flatten_methappl(MA,MA_V,MA_C),
	flatten_pathlist(Ps,Ps_V,Ps_C),
	flatten_setarrow(Ps_V,Obj,MA_V,Arr,Res_C),
	append(MA_C,Ps_C,Spec1_C),
	append(Spec1_C,Res_C,Spec_C).


flatten_setarrow([],_,_,_,[]).
flatten_setarrow([P|Ps],O,M,Arr,[Code|Codes]) :-
	Code=..[Arr,O,M,P],
	flatten_setarrow(Ps,O,M,Arr,Codes).



% flatten_pathlist(+Pathlist,-List_of_Values,-Code)
%
flatten_pathlist([],[],[]).
flatten_pathlist([P|Ps],[P_V|Ps_V],Ps1_C):-
	flatten(P,P_V,P_C),
	flatten_pathlist(Ps,Ps_V,Ps_C),
	append(P_C,Ps_C,Ps1_C).



% ---- auxiliary predicates ----
 

new_pathvar(V) :- 
	gensym_f('$pv',V).

%%% subst_vars(+Term,-NewTerm,-Vars) 
% replace all variables in Term by special terms and collect
% all variables in Vars
%
subst_vars(Term,Term1,Vars) :-
	subst_vars(Term,Term1,[],Vars).

subst_vars('$pv'(X),PV,Vars0, Vars) :-
	!,
	name(X,XN),append("_P_",XN,PVN),name(PV,PVN),
	(memberchk(PV,Vars0)
	-> Vars=Vars0
	;  Vars=[PV|Vars0]
	).
subst_vars('$v'(X),X1,Vars0, Vars) :-
	!,
	name(X,XN),
	(X='_'
	-> X1 = X
	;  name(X1,[95|XN])	% add '_' at beginning
	),
	(memberchk(X1,Vars0)
	-> Vars=Vars0
	;  Vars=[X1|Vars0]
	).
%subst_vars('$v'(X),X,Vars0, Vars) :-
%	!,
%	(memberchk(X,Vars0)
%	-> Vars=Vars0
%	;  Vars=[X|Vars0]
%	).
subst_vars(Term, Term1,Vars0, Vars) :-
		functor(Term,F,Arity),
		functor(Term1,F,Arity),
		subst_vars(Arity, Term, Term1,Vars0, Vars).

subst_vars(0, _,_, Vars0, Vars0) :- !.
subst_vars(N, Term,Term1,Vars0,Vars) :-
	arg(N, Term, Arg),
	arg(N, Term1, Arg1),
	subst_vars(Arg, Arg1,Vars0,Vars1),
	M is N-1, !,
	subst_vars(M, Term, Term1,Vars1,Vars).



%%% subst_vars_match(+Term,-NewTerm,-Match_list) 
% replace all variables in Term by Prolog variables and collect
% the mapping (user vars -> Prolog vars)  in Match_list
%
% variables are found in reverse order and return in reverse order 
% in which they were found. this yields the correct order, if
% variables do not appear more then once !
%
subst_vars_match(Term,Term1,V_Match) :-
	subst_vars_match(Term,Term1,[],V_Match,[],_P_Match).

% replace path-variable
subst_vars_match('$pv'(X),Y, V_Match0,V_Match0, P_Match0,P_Match) :-
	!,			
	name(X,XN),
	(memberchk(XN=Y,P_Match0)
	-> P_Match=P_Match0
	;  P_Match=[XN=Y|P_Match0]
	).
% replace user-variable
subst_vars_match('$v'(X),Y, V_Match0,V_Match, P_Match0,P_Match0) :-
	!,
	name(X,XN),
	(memberchk(XN=Y,V_Match0)
	-> V_Match=V_Match0
	;  V_Match=[XN=Y|V_Match0]
	).
% recurse
subst_vars_match(Term,Term1, V_Match0,V_Match, P_Match0,P_Match) :-
		functor(Term,F,Arity),
		functor(Term1,F,Arity),
		subst_vars_match(Arity, Term,Term1,
			V_Match0,V_Match, 
			P_Match0,P_Match).
% for each argument
subst_vars_match(0, _,_, V_Match0,V_Match0, P_Match0,P_Match0) :- 
	!.
subst_vars_match(N, Term,Term1,V_Match0,V_Match, P_Match0,P_Match) :-
	arg(N, Term, Arg),
	arg(N, Term1, Arg1),
	subst_vars_match(Arg,Arg1,
		V_Match0,V_Match1, 
		P_Match0,P_Match1),
	M is N-1, !,
	subst_vars_match(M, Term,Term1,
		V_Match1,V_Match, 
		P_Match1,P_Match).

%%% this could be incorporated into subst_vars_match!
remove_anonymous([],[]).
remove_anonymous([([95]=_)|Ms], M1s) :-
	!,
	remove_anonymous(Ms, M1s).
remove_anonymous([M|Ms], [M|M1s]) :-
	!,
	remove_anonymous(Ms, M1s).

memberchk(X,[X|_]) :-!.
memberchk(X,[_|Xs]) :-
	memberchk(X,Xs).


list_to_conj([X], X).
list_to_conj([X,X1|Xs], ','(X,Xs1)) :-
	list_to_conj([X1|Xs], Xs1).


%%% gensym(+Prefix,-NewAtom_with_Prefix)
gensym(Prefix,NewSym) :-
	retract(ctr(gensym,N)),
	N1 is N+1,
	asserta(ctr(gensym,N1)),
	name(N1,N1N),
	name(Prefix,PN),
	append(PN,N1N,NewSymN),
	name(NewSym,NewSymN).

%%% gensym_f(+Func,-NewAtom_with_Functor)
gensym_f(Functor,NewSym) :-
	retract(ctr(gensym,N)),
	N1 is N+1,
	asserta(ctr(gensym,N1)),
	functor(NewSym,Functor,1),
	arg(1,NewSym,N1).
