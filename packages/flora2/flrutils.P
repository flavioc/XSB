/* File:      flrutils.P
**
** Author(s): Guizhen Yang
              Michael Kifer
**
** Contact:   xsb-contact@cs.sunysb.edu
**
** Copyright (C) The Research Foundation of SUNY, 1999-2001
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id$
**
*/


:- compiler_options([xpp_on]).


#define FLORA_FILE_EXT		flr
#define FLORA_INCLUDE_EXT	fli
#define FLORA_HEADER_EXT	flh
#define FLORA_FDB_EXT		fdb
#define XSB_PFILE_EXT		'P'
#define XSB_OFILE_EXT		'O'
#define XSB_HFILE_EXT		'H'
#define FLORA_FAILURE		failure
#define FLORA_SUCCESS		success
#define FLORA_NOOP		noop
#define FLORA_ALL		all
#define FLORA_FILE		file
#define FLORA_COMMANDLINE	commandline

#include "char_defs.h"
#include "flag_defs_xsb.h"
#include "flora_terms.flh"


/*************************************************************************
  flora_compile_internal(+File)
*************************************************************************/
flora_compile_internal(File) :-
	flora_compile_internal(File,FLORA_DEFAULT_WORKSPACE).


/******************************************************************************
  flora_compile_internal(+File,+Workspace)
  The .O file is renamed using the module name
******************************************************************************/
flora_compile_internal(File,Workspace) :-
	flora_check_filename(File),
	flora_check_workspace(Workspace),
	( flora_locate_file(File,FLORA_FILE_EXT,FlrFile) ->
	    flora_flcompile(FlrFile,Workspace)
	;
	  flora_flrfilename_error(File),
	  !,
	  fail
	),
	!.


/**********************************************************************
  flora_load_module_internal(+File,+Workspace)
  File must be a FLORA file.
**********************************************************************/
flora_load_module_internal(InFile,Workspace) :-
	flora_check_filename(InFile),
	flora_check_workspace(Workspace),
	flora_get_user_program_maybe(InFile,File),
	( flora_locate_file(File,FLORA_FILE_EXT,FlrFile) ->
	    flora_flload(FlrFile,Workspace)
	;
	  flora_flrfilename_error(InFile),
	  !,
	  fail
	),
	!.


/**********************************************************************
  flora_load_module_internal(+File)
  File may be a FLORA file, .P file, or .O file.
**********************************************************************/
flora_load_module_internal(InFile) :-
	flora_check_filename(InFile),
	flora_get_user_program_maybe(InFile,File),
	( flora_locate_file(File,FLORA_FILE_EXT,FlrFile) ->
	    flora_flload(FlrFile,FLORA_DEFAULT_WORKSPACE)

	; flora_locate_file(File,XSB_PFILE_EXT,PFile) ->
	    flora_stdmsg_nl,
	    flora_message_line('consulting %s',args(PFile)),
	    consult(PFile)

	; flora_locate_file(File,XSB_OFILE_EXT,OFile) ->
	    flora_stdmsg_nl,
	    flora_message_line('consulting %s',args(OFile)),
	    consult(OFile)

	; parse_filename(File,_,_,Ext),
          Ext \== '', Ext \== XSB_OFILE_EXT, Ext \== XSB_PFILE_EXT, Ext \== FLORA_FILE_EXT,
	  path_sysop(exists,File)
	->
	    flora_stderr_nl,
	    flora_error_line('%s: Filename extension must be %s, %s or %s!',
	                     args(File,
				  FLORA_FILE_EXT,XSB_PFILE_EXT,XSB_OFILE_EXT)),
	    fail
	;
	  flora_stderr_nl,
	  flora_error_line('File %s[.{%s|%s|%s}] does not exist!',
			   args(File,
				FLORA_FILE_EXT,XSB_PFILE_EXT,XSB_OFILE_EXT)),
          fail
        ),
	!.



/**********************************************************************
  flloadtrailer(+TrailerName,+Workspace)
  TrailerName must be either NONE, or BASIC, or FLOGIC.
**********************************************************************/
flloadtrailer(TrailerName) :-
	flloadtrailer(TrailerName,FLORA_DEFAULT_WORKSPACE).

flloadtrailer(TrailerName,Workspace) :-
	( TrailerName \== NONE, TrailerName \== BASIC, TrailerName \== FLOGIC ->
	    flora_error_line('Equality directive must be %s, %s, or %s!',
                             args(NONE,BASIC,FLOGIC)),
	    fail
	;
	  %% Get the trailer file name in Flora package.
	  flora_check_workspace(Workspace),
	  package_configuration(dir(flora),FloraDir),
	  slash(S),
	  flora_trailer_filename(TrailerName,TrailerFileName),
	  fmt_write_string(TrailerFullName,'%s%strailer%s%s',
                           args(FloraDir,S,S,TrailerFileName)),
	  %% Get file names in user dir.
	  flora_user_flora_dir(UserFloraDir),
	  fmt_write_string(UserTrailerPFile,'%s%s%s',args(UserFloraDir,S,TrailerFileName)),
	  flora_mainO_filename(UserTrailerPFile,UserTrailerOFile),
	  flora_WSO_filename(UserTrailerPFile,Workspace,UserTrailerWSOFile),
	  %% Copy the main file to user directory.
	  ( flora_file_newerthan(UserTrailerPFile,TrailerFullName) ->
	      true
	  ;
	    path_sysop(copy,TrailerFullName,UserTrailerPFile)
	  ),
	  ( flora_file_newerthan(UserTrailerWSOFile,UserTrailerPFile) ->
	      true
	  ;
	    flora_set_xpp_options(Workspace),
	    %%compile(UserTrailerPFile,[optimize,spec_repr,ti_all]),
	    compile(UserTrailerPFile,[optimize,ti_all]),
	    flora_rename_file(UserTrailerOFile,UserTrailerWSOFile),
	    flora_clear_xpp_options
	  ),
	  consult(UserTrailerWSOFile),
	  !,
	  %% Check if the patch needs to be loaded.
	  flora_user_module_predicate_symbol(FLORA_THIS_MODULE,Workspace,Predicate),
	  (current_predicate(Predicate/1) -> true; flloadpatch(Workspace))
        ),
	!.


/**********************************************************************
  flsetuptrailer(+TrailerName)
  TrailerName must be either NONE, or BASIC, or FLOGIC.
  This predicate is called in the Makefile.
**********************************************************************/
flsetuptrailer(TrailerName) :-
	package_configuration(dir(flora),FloraDir),
	slash(S),
	flora_trailer_filename(TrailerName,TrailerFileName),
	fmt_write_string(TrailerFullName,'%s%strailer%s%s',
                         args(FloraDir,S,S,TrailerFileName)),
	telling(PreOutFile),
	tell(TrailerFullName),
	flora_trailer_include(TrailerName,TrailerInclude),
	flora_include_file([FLHEADER|TrailerInclude],HeaderStatus),
	told,
	tell(PreOutFile),
	!,
	( HeaderStatus == FLORA_FAILURE ->
	    fail
	;
	  flora_set_xpp_options(FLORA_DEFAULT_WORKSPACE),
	  %%compile(TrailerFullName,[optimize,spec_repr,ti_all]),
	  compile(TrailerFullName,[optimize,ti_all]),
	  flora_clear_xpp_options
	),
	!.

flora_trailer_filename(NONE,'standard.P').
flora_trailer_filename(BASIC,'eqlbasic.P').
flora_trailer_filename(FLOGIC,'eqlflogic.P').

flora_trailer_include(NONE,[FLTRAILER]).
flora_trailer_include(BASIC,[FLEQLTRAILER]).
flora_trailer_include(FLOGIC,[FLEQLTRAILER,FLSCALAREQL]).


/**********************************************************************
  flloadpatch(+Workspace)
**********************************************************************/
flloadpatch(Workspace) :-
	package_configuration(dir(flora),FloraDir),
	slash(S),
	flora_patch_filename(PatchName),
	fmt_write_string(PatchFullName,'%s%strailer%s%s',args(FloraDir,S,S,PatchName)),
	%% Get file names in user dir.
	flora_user_flora_dir(UserFloraDir),
	fmt_write_string(UserPatchPFile,'%s%s%s',args(UserFloraDir,S,PatchName)),
	flora_mainO_filename(UserPatchPFile,UserPatchOFile),
	flora_WSO_filename(UserPatchPFile,Workspace,UserPatchWSOFile),
	%% Copy the main file to user directory.
	( flora_file_newerthan(UserPatchPFile,PatchFullName) ->
	    true
	;
	  path_sysop(copy,PatchFullName,UserPatchPFile)
	),
	( flora_file_newerthan(UserPatchWSOFile,UserPatchPFile) ->
	    true
	;
	  flora_set_xpp_options(Workspace),
	  %%compile(UserPatchPFile,[optimize,spec_repr,ti_all]),
	  compile(UserPatchPFile,[optimize,ti_all]),
	  flora_rename_file(UserPatchOFile,UserPatchWSOFile),
	  flora_clear_xpp_options
        ),
	consult(UserPatchWSOFile),
	!.


/**********************************************************************
  flsetuppatch
**********************************************************************/
flsetuppatch :-
	package_configuration(dir(flora),FloraDir),
	slash(S),
	flora_patch_filename(PatchName),
	fmt_write_string(PatchFullName,'%s%strailer%s%s',args(FloraDir,S,S,PatchName)),
	telling(PreOutFile),
	tell(PatchFullName),
	flora_include_file([FLHEADER,FLDEFINITION,FLPATCH],HeaderStatus),
	told,
	tell(PreOutFile),
	!,
	( HeaderStatus == FLORA_FAILURE ->
	    fail
	;
	  flora_set_xpp_options(FLORA_DEFAULT_WORKSPACE),
	  %%compile(PatchFullName,[optimize,spec_repr,ti_all]),
	  compile(PatchFullName,[optimize,ti_all]),
	  flora_clear_xpp_options
	),
	!.


flora_patch_filename('patch.P').


/*************************************************************************
  flora_user_flora_dir(-Dir)
*************************************************************************/
flora_user_flora_dir(Dir) :-
	( package_configuration(user_dir(flora),Dir) ->
	    true
	;
	    xsb_configuration(user_home,UserHome),
	    slash(S),
	    fmt_write_string(Dir,'%s%s.xsb%sflora',args(UserHome,S,S)),
	    ( path_sysop(exists,Dir) ->
		true
	    ;
		( path_sysop(mkdir,Dir) ->
		    true
		;
		    flora_error_line('Cannot create directory %s!',args(Dir)),
		    abort
		)
	    ),
	    assert(package_configuration(user_dir(flora),Dir))
	),
	!.

flora_user_tmpfile(Filename) :-
	flora_user_flora_dir(Dir),
	slash(S),
	fmt_write_string(Filename,'%s%stmp$user',args(Dir,S)).


/*************************************************************************
   flora_rename_file(+F1,+F2)
   This is like path_sysop(rename,F1,F2), but it first tries issues
   an error when fails.
   The reason is that on Windows files sometimes fail to be renamed for 
   strange reasons, so we first delete F2, try to rename, and if failed,
   issue an error, which explains what happened.
   There is no point to continue after a failure, because Flora 
   will be in a broken state.
*************************************************************************/
flora_rename_file(F1,F2) :-
	( (path_sysop(unlink,F2), !; true),
	  path_sysop(rename,F1,F2), !
	;
	    flora_error_line("Something wrong: Can't rename %s to %s\n",
			     args(F1,F2)),
	    abort
	).


/*************************************************************************
  flora_flcompile(+FlrFile,+ModuleName)

  This procedure is called to compile either a Flora user module or a
  Flora system module. In the former case, the module name is an atom
  whereas in the latter case the module name looks like flora(name).
*************************************************************************/
flora_flcompile(FlrFile,ModuleName) :-
	flora_mainP_filename(FlrFile,MPFile),
	flora_FDB_filename(FlrFile,FDBFile),
	flora_set_xpp_options(ModuleName),
	flora_compile_file(FlrFile,MPFile,FDBFile,Status),
	( Status == FLORA_FAILURE ->
	    flora_clear_xpp_options,
	    !,
	    fail
	;
	  flora_mainO_filename(FlrFile,MOFile),
	  flora_message_line('calling XSB compiler'),
	  (
	    %%compile(MPFile,[optimize,spec_repr,ti_all])
	    compile(MPFile,[optimize,ti_all]) ->
	      true
	  ;
	    flora_clear_xpp_options,
	    fail
	  ),
	  !,
	  flora_clear_xpp_options,
	  flora_module_name(ModuleName,_Type,Workspace),
	  flora_WSO_filename(FlrFile,Workspace,WSOFile),
	  flora_rename_file(MOFile,WSOFile)
        ),
	!.


/******************************************************************************
  flora_compile_system_module(+File)

  Compile a Flora system module in the lib/ directory. These files are
  loaded into predefined modules. This procedure is used only in the Makefile.
  Error checking for file name, existence, etc., is omitted.

  Note: This predicate is used *ONLY* in the make file for simplicity.
******************************************************************************/
flora_compile_system_module(File) :-
	%% Get the system module ID from the base file name.
	path_sysop(basename,File,BaseName),
	flora_sysmod_file(SysModID,BaseName,_SubDir),
	( flora_locate_file(BaseName,FLORA_FILE_EXT,FlrFile) ->
	    flora_module_name(ModuleName,systemmodule,SysModID),
	    flora_flcompile(FlrFile,ModuleName)
	;
	  flora_stderr_nl,
	  flora_error_line('File %s[.%s] does not exist!',args(BaseName,FLORA_FILE_EXT)),
	  !,
          fail
	),
	!.


/*************************************************************************
  flora_load_system_module_internal(+SysModID)

  This predicate is called to load a Flora system module. The input is
  its ID.
*************************************************************************/
flora_load_system_module_internal(SysModID) :-
	( atom(SysModID), flora_sysmod_file(SysModID,BaseName,SubDir) ->
	    flora_module_name(ModuleName,systemmodule,SysModID),
	    %% Compute the Flora file name.
	    package_configuration(dir(flora),FloraDir),
	    slash(S),
	    fmt_write_string(FlrFile,"%s%s%s%s%s.flr",
			     args(FloraDir,S,SubDir,S,BaseName)),
	    flora_WSO_filename(FlrFile,SysModID,WSOFile),
	    !,
	    ( flora_file_newerthan(WSOFile,FlrFile) ->
		true

	    ; path_sysop(exists,FlrFile) ->
		flora_flcompile(FlrFile,ModuleName)
	    ;
	      flora_stderr_nl,
	      flora_error_line('Flora system module file %s does not exist!',
			       args(FlrFile)),
	      !,
	      fail
	    ),
	    !,
	    flora_message_line('loading FLORA system module %s',
			       args(SysModID)),
	    flora_set_xpp_options(ModuleName),
	    consult(WSOFile),
	    flora_clear_xpp_options
	;
	  flora_stderr_nl,
	  flora_error_line('Invalid FLORA system module ID %S ! Loading failed!',
			   args(SysModID)),
          !,
	  fail
	),
	!.


/******************************************************************************
  flora_compile_system_module_by_ID(+SysModID)

  Compile a Flora system module in the lib/ directory according to its ID.
******************************************************************************/
flora_compile_system_module_by_ID(SysModID) :-
	%% Retrieve the file name and its subdir.
	flora_sysmod_file(SysModID,BaseName,SubDir),
	%% Compute the Flora file name.
	package_configuration(dir(flora),FloraDir),
	slash(S),
	fmt_write_string(FlrFile,"%s%s%s%s%s.flr",args(FloraDir,S,SubDir,S,BaseName)),
	( path_sysop(exists,FlrFile) ->
	    flora_module_name(ModuleName,systemmodule,SysModID),
	    flora_flcompile(FlrFile,ModuleName)
	;
	  flora_stderr_nl,
	  flora_error_line('Flora system module file %s does not exist!',args(FlrFile)),
	  !,
          fail
	),
	!.


/*************************************************************************
  flora_flload(+FlrFile,+Workspace)

  Need to make sure the GPP options are cleared when this procedure is
  finished.
*************************************************************************/
flora_flload(FlrFile,Workspace) :-
	flora_mainP_filename(FlrFile,MPFile),
	flora_mainO_filename(FlrFile,MOFile),
	flora_FDB_filename(FlrFile,FDBFile),
	flora_WSO_filename(FlrFile,Workspace,WSOFile),
	!,
	flora_set_xpp_options(Workspace),
        ( flora_file_newerthan(MPFile,FlrFile) ->
	    flora_stdmsg_nl,
	    true
	;
	  flora_compile_file(FlrFile,MPFile,FDBFile,Status),
	  ( Status == FLORA_FAILURE ->
	      flora_clear_xpp_options,
	      !,
	      fail
	  ;
	    true
	  )
	),
	!,
	flora_message_line('loading %s into module %s',args(FlrFile,Workspace)),
	( flora_file_newerthan(WSOFile,MPFile) ->
	    true
	;
	  (
	    %%compile(MPFile,[optimize,spec_repr,ti_all])
	    compile(MPFile,[optimize,ti_all])
	  ->
	    true
	  ;
	    flora_clear_xpp_options,
	    fail
	  ),
	  flora_rename_file(MOFile,WSOFile)
        ),
        consult(WSOFile),
	flora_clear_xpp_options,
	!.

/*****************************************************************************
  flora_save_user_clauses(+FlrFile)
  Read user input and save it in the given file
*****************************************************************************/
flora_save_user_clauses(FlrFile) :-
	flora_message_line('Enter FLORA program clauses. When done, type Ctl-D.'),
	file_open(FlrFile,w,Port),
	stat_flag(CURRENT_INPUT, InPort),
	copyIOport(InPort,Port),
	file_close(Port),
	flora_message_line('User program saved in file %s', arg(FlrFile)).


/*************************************************************************
  flora_get_user_program_maybe(+InFile,-File)
  If InFile = user assume the user wants to input the program from the shell.
  Retrun the name of the tempfile that has the program.
*************************************************************************/
flora_get_user_program_maybe(InFile,File) :-
	( InFile == user ->
	    %%path_sysop(tmpfilename,File),
	    flora_user_tmpfile(File),
	    fmt_write_string(FlrFile,'%s.%s',args(File,FLORA_FILE_EXT)),
	    flora_save_user_clauses(FlrFile)
	;
	  File=InFile
	).


/*************************************************************************
  flora_locate_file(+InFile,+ExtType,-ExtFile)

  InFile must have ExtType as extension or no extension (in this case,
  ExtType is appended).
*************************************************************************/
flora_locate_file(InFile,ExtType,ExtFile) :-
	parse_filename(InFile,_,_,Ext),
	( Ext == ExtType ->
	    ExtFileName=InFile
	;
	  fmt_write_string(ExtFileName,'%s.%s',args(InFile,ExtType))
	),
	flora_locate_file(ExtFileName,ExtFile),
	!.


/*************************************************************************
  flora_locate_file(+InFile,-LocatedFile)

  When it succeeds, it returns the absolute file name.
*************************************************************************/
flora_locate_file(In,In) :-
	path_sysop(isabsolute,In),
	!,
	path_sysop(exists,In).

flora_locate_file(In,Loc) :-
	flora_library_directory(LibDir),
	slash(S),
	fmt_write_string(File,'%s%s%s',args(LibDir,S,In)),
	path_sysop(expand,File,Loc),
	path_sysop(exists,Loc),
	!.


/*************************************************************************
  flora_file_newerthan(+File1,+File2)
  returns true if File1 exists and is newer than File2. File2 already exists.
*************************************************************************/
flora_file_newerthan(File1,File2) :-
	path_sysop(exists,File1),
	path_sysop(newerthan,File1,File2).


/*************************************************************************
  flora_library_directory(-Dir)
  returns directories to search a FLORA file.
*************************************************************************/
flora_library_directory('.').
flora_library_directory(LibDir) :- library_directory(LibDir).
flora_library_directory(LibDir) :- xsb_configuration(libdir,LibDir).
flora_library_directory(LibDir) :- xsb_configuration(syslibdir,LibDir).
flora_library_directory(LibDir) :- xsb_configuration(cmplibdir,LibDir).


/*************************************************************************
  flora_mainP_filename(+File,-MPFile)
  flora_mainO_filename(+File,-MOFile)
  flora_FDB_filename(+File,-FDBFile)
  flora_FLH_filename(+File,-FLHFile)
  flora_WSP_filename(+File,+WS,-WSPFile)
  flora_WSO_filename(+File,+WS,-WSOFile)
  flora_dump_filename(+File,-DFile)
*************************************************************************/
flora_mainP_filename(File,MPFile) :-
	parse_filename(File,Dir,Base,_),
	fmt_write_string(MPFile,'%s%s.%s',args(Dir,Base,XSB_PFILE_EXT)).

flora_mainO_filename(File,MOFile) :-
	parse_filename(File,Dir,Base,_),
	fmt_write_string(MOFile,'%s%s.%s',args(Dir,Base,XSB_OFILE_EXT)).

flora_FDB_filename(File,FDBFile) :-
	parse_filename(File,Dir,Base,_),
	fmt_write_string(FDBFile,'%s%s.%s',args(Dir,Base,FLORA_FDB_EXT)).

flora_FLH_filename(File,FLHFile) :-
	parse_filename(File,Dir,Base,_),
	fmt_write_string(FLHFile,'%s%s.%s',args(Dir,Base,FLORA_HEADER_EXT)).

%flora_WSP_filename(File,WS,WSPFile) :-
%	parse_filename(File,Dir,Base,_),
%	fmt_write_string(WSPFile,'%s%s_%s.%s',args(Dir,Base,WS,XSB_PFILE_EXT)).

flora_WSO_filename(File,WS,WSOFile) :-
	parse_filename(File,Dir,Base,_),
	fmt_write_string(WSOFile,'%s%s_%s.%s',args(Dir,Base,WS,XSB_OFILE_EXT)).

flora_dump_filename(File,DFile) :-
	parse_filename(File,Dir,Base,Ext),
	fmt_write_string(DFile,'%s%s_dump.%s',args(Dir,Base,Ext)).


/*************************************************************************
  utilities
*************************************************************************/
flora_check_filename(Name) :-
	( not atom(Name) ->
	    flora_error_line('invalid file name'),
	    fail
	;
	  true
	).


flora_check_workspace(Name) :-
	( var(Name) ->
	    flora_error_line('uninstantiated module name'),
	    fail
	; not (atom(Name), is_alphanumeric(Name)) ->
	    flora_error_heading,
	    flora_stderr_string('invalid module name (not alphanumeric): '),
	    flora_stderr_write(Name),
	    flora_stderr_nl,
	    fail
	; 
	  true
	).

is_alphanumeric(Name) :-
	atom_codes(Name,NameL),
	is_alphanumericL(NameL).

is_alphanumericChar(Ch) :-
	( CH_0 =< Ch, Ch =< CH_9
	; CH_a =< Ch, Ch =< CH_z
	; CH_A =< Ch, Ch =< CH_Z
	; Ch == CH_UNDERSCORE
	).

is_alphanumericL([]).

is_alphanumericL([Ch|Rest]) :-
	is_alphanumericChar(Ch),
	is_alphanumericL(Rest).


/*************************************************************************
  gpp control utilities
*************************************************************************/
%% standard gpp options used by Flora.
flora_xpp_standard_options('-P -m -nostdinc -curdirinclast').


flora_set_xpp_options :-
	retractall(xpp_options(_)),
	flora_xpp_standard_options(Opt),
	assert(xpp_options(Opt)).


%% It is always called before invoking GPP.
%% If ModuleName looks like a system module name (flora(_)) then adds
%% extra options for compiling system modules.
%% Note: This predicate should not be called before a previous call of
%% flora_set_xpp_options finishes.
flora_set_xpp_options(ModuleName) :-
	retractall(xpp_options(_)),
	flora_module_name(ModuleName,Type,WS),
	( Type == usermodule ->
	    ExtraOpt=''

	; Type == systemmodule	->
	    ExtraOpt='-D FLORA_COMPILE_SYSTEM_MODULE'

	; Type == invalid ->
	    flora_module_name_error(WS),
	    abort
	),
	flora_xpp_standard_options(StandardOpt),
	fmt_write_string(Opt,
			 '%s -D FLORA_VAR_WORKSPACE=%s %s',
		         args(StandardOpt,WS,ExtraOpt)),
	assert(xpp_options(Opt)),
	!.


flora_set_xpp_options(ModuleName,ExtraOpt) :-
	flora_set_xpp_options(ModuleName),
	xpp_options(XOpt),
	retractall(xpp_options(_)),
	fmt_write_string(Opt,'%s %s',args(XOpt,ExtraOpt)),
	assert(xpp_options(Opt)).


flora_clear_xpp_options :-
	retractall(xpp_options(_)).


/*************************************************************************
  flora_loaddyn_FDB_filename(+DBFileName)
*************************************************************************/
flora_loaddyn_FDB_filename(DBFileName) :-
	%% Output the base file name only. The full path will be taken
	%% care of by flora_load_dyn and consult.
	parse_filename(DBFileName,_Dir,Base,Ext),
	current_output_port(OutPort),
	fmt_write(OutPort,":- import flora_load_dyn/2 from flrutils.\n",_),
	fmt_write(OutPort,"?- flora_load_dyn('%s.%s',%s).\n\n",
                  args(Base,Ext,'FLORA_THIS_MODULE_NAME')).


/*************************************************************************
  flora_include_file(+OptionList,-Status)
*************************************************************************/
flora_include_file([],FLORA_SUCCESS) :- !.

flora_include_file([Opt|OptList],Status) :-
	flora_include(Opt,File),
	!,
	package_configuration(dir(flora),FloraDir),
	slash(S),
	fmt_write_string(FullName,'%s%s%s',args(FloraDir,S,File)),
	( path_sysop(exists,FullName) ->
	    print_file_contents(FullName),
	    flora_include_file(OptList,Status)
	;
	  flora_error_line('The FLORA system file %s cannot be found!',
			   arg(FullName)),
          Status=FLORA_FAILURE
	).

flora_include_file(_OptList,FLORA_FAILURE) :-
	  flora_error_line('system file corrupted!').


/*************************************************************************
  flora_end_of_input(+Status)
  flora_not_end_of_input(+Status)
*************************************************************************/
flora_end_of_input(Status) :- member(FLORA_EOF,Status).
flora_not_end_of_input(Status) :- member(FLORA_NOT_EOF,Status).


/*************************************************************************
  flora_reset_modules_for_file/0
*************************************************************************/
flora_reset_modules_for_file :-
	flora_reset_lexer,
	flora_reset_operator,
	flora_reset_arguments,
	flora_reset_prolog,
	flora_reset_firstorder,
	flora_reset_compiler,
	conset(flora_shell_mode,0).


/*************************************************************************
  flora_reset_modules_for_shell/0
*************************************************************************/
flora_reset_modules_for_shell :-
	flora_reset_lexer,
	flora_reset_compiler,
	conset(flora_shell_mode,1).


/*************************************************************************
  flora_compile_file(+InputFile,+OutputPFile,+OutputDBFile,-FileStatus)

  Note: FileStatus returns either FLORA_FAILURE or FLORA_SUCCESS.

        The appropriate GPP options must be set before this procedure is called.
*************************************************************************/
flora_compile_file(InputFile,PFile,DBFile,FileStatus) :-
	flora_maxerr(MaxErrNum),
	flora_stdmsg_nl,
	flora_message_line('compiling %s',args(InputFile)),
	cputime(T0),
	seeing(PreInFile),
	%% Disable the compilation for FLORA template include file.
	conset(flora_compile_include_file,0),
	flora_reset_modules_for_file,
	xpp_process_file(InputFile,XPP_process,IOportFromProc),
	stat_set_flag(CURRENT_INPUT,IOportFromProc),
	flora_rpc_file(MaxErrNum,0,0,CompiledRuleList,FileOptionList,CompileStatus),
	%% Wait, not to leave zombies.
	process_control(XPP_process,wait),
	%% Release the file descriptor used to read from cpp.
	file_close(IOportFromProc),
	see(PreInFile),
	( CompileStatus == FLORA_FAILURE ->
	    FileStatus=FLORA_FAILURE
	;
	  flora_generate_file(CompiledRuleList,FileOptionList,PFile,DBFile,FileStatus)
        ),
	cputime(T1),
	( FileStatus == FLORA_FAILURE ->
	    true
	;
	  T is T1-T0,
	  flora_message_line('Done! CPU time used: %S seconds',args(T))
	),
	!.

%% Catch a failure situation.
flora_compile_file(_InputFile,_PFile,_DBFile,FLORA_FAILURE).


/*************************************************************************
  flora_generate_file(+CompiledRuleList,+FileOptionList,+PFile,+DBFile,-FileStatus)

  Note: FileStatus returns either FLORA_FAILURE or FLORA_SUCCESS.
*************************************************************************/
flora_generate_file(CompiledRuleList,FileOptionList,PFile,DBFile,FileStatus) :-
	flora_divide_program(CompiledRuleList,RuleList,FactList),
	sort(FileOptionList,FileOptions),
	flora_generate_Pfile(PFile,FileOptions,RuleList,FactList,DBFile,PFileStatus),
	( PFileStatus == FLORA_FAILURE ->
	    FileStatus=FLORA_FAILURE
	;
	  ( FactList == [] ->
	      FileStatus=FLORA_SUCCESS
	  ;
	    flora_generate_DBfile(DBFile,FactList,FileStatus)
	  )
        ),
	!.


/*************************************************************************
  flora_generate_Pfile(+PFileName,+FileOptionList,+RuleList,+FactList,
                       +DBFile,-FileStatus)

  Things to do:
  (1) include .flh file directive.
  (2) output header file.
  (3) syslib and sysmod loading instrucitons.
  (4) DB file loading instruction.
  (5) program.
  (6) trailer.
*************************************************************************/
flora_generate_Pfile(PFileName,FileOptionList,RuleList,FactList,DBFile,FileStatus) :-
	telling(PreOutFile),
	tell(PFileName),
	findall(LibOption,member(FLSYSLIB(LibOption),FileOptionList),SysLibOptionList),
	findall(ModOption,member(FLSYSMOD(ModOption),FileOptionList),SysModOptionList),
	append(SysLibOptionList,SysModOptionList,OptList),
	%% FLLIBCONTROL and FLLIBMETAOPS in (sylibinc) should be
	%% included by the compiler.
	flora_include_file([FLHEADER,FLDEFINITION,FLPATCH,FLLIBCONTROL,FLLIBMETAOPS|OptList],
                           HeaderStatus),
	( HeaderStatus == FLORA_FAILURE ->
	    FileStatus=FLORA_FAILURE
	;
	  (FactList == [] -> true; flora_loaddyn_FDB_filename(DBFile)),
	  flora_extern_code(RuleList,CoderStatus),
	  ( CoderStatus == [] ->
	      ( member(FLEQLFLOGIC,FileOptionList) ->
		  flora_message_line('including full F-logic equality maintenance'),
		  flora_include_file([FLEQLTRAILER,FLSCALAREQL],FileStatus)

	      ; member(FLEQLBASIC,FileOptionList) ->
	          flora_message_line('including basic equality maintenance'),
		  flora_include_file([FLEQLTRAILER],FileStatus)
	      ;
	        flora_include_file([FLTRAILER],FileStatus)
	      )
	  ;
	    flora_coder_error(CoderStatus),
	    FileStatus=FLORA_FAILURE
	  )
        ),
	told,
	tell(PreOutFile),
	!.


/*************************************************************************
  flora_generate_DBfile(+DBFileName,+FactList,-FileStatus)

  Things to do:
  (1) include .flh file directive.
  (2) output header file.
  (3) facts.
*************************************************************************/
flora_generate_DBfile(DBFileName,FactList,FileStatus) :-
	telling(PreOutFile),
	tell(DBFileName),
	%% Include the Macro definitions.
	writeln('#include "flrheader.flh"'),
	nl,
	flora_extern_code(FactList,CoderStatus),
	( CoderStatus == [] ->
	    FileStatus=FLORA_SUCCESS
	;
	  flora_coder_error(CoderStatus),
	  FileStatus=FLORA_FAILURE
	),
	told,
	tell(PreOutFile),
	!.


/*************************************************************************
  flora_load_dyn(+InDBFile,+ModuleName)

  This procedure reads a Flora DB file that contains facts in canonical
  form and inserts them into the storage trie for the module. The module
  could be either a Flora user module, or a Flora system module. In the
  latter case, it is structured term.
*************************************************************************/
flora_load_dyn(InDBFile,ModuleName) :-
	flora_check_filename(InDBFile),
	( path_sysop(isabsolute,InDBFile) ->
	    InDBFileAbs=InDBFile

	; current_loaded_file(LoadedFile) ->
	    path_sysop(dirname,LoadedFile,FileDir),
	    fmt_write_string(InDBFileAbs,'%s%s',args(FileDir,InDBFile))
	;
	  InDBFileAbs=InDBFile
	),
	!,
	( flora_locate_file(InDBFileAbs,DBFile) ->
	    flora_message_line('dynamically loading %s into module %S',
			       args(DBFile,ModuleName)),
	    cputime(T0),
	    seeing(PreInFile),
	    flora_set_xpp_options(ModuleName),
	    xpp_process_file(DBFile,XPP_process,IOportFromProc),
	    stat_set_flag(CURRENT_INPUT,IOportFromProc),
	    flora_storage_name(ModuleName,StorageName),
	    flora_read_canonical_and_insert(StorageName),
	    %% Wait, not to leave zombies.
	    process_control(XPP_process,wait),
	    %% Release the file descriptor used to read from cpp.
	    file_close(IOportFromProc),
	    flora_clear_xpp_options,
	    see(PreInFile),
	    cputime(T1),
	    T is T1-T0,
	    flora_message_line('Done! CPU time used: %S seconds',args(T))
	;
	  flora_error_line('File %s does not exist!', args(InDBFileAbs)),
	  fail
	),
	!.


/*************************************************************************
  flora_read_canonical_and_insert(+StorageName)

  It reads the current input in canonical form and inserts all facts
  into the storage trie.
*************************************************************************/
flora_read_canonical_and_insert(StorageName) :-
	repeat,
	read_canonical(Term),
	( Term == end_of_file ->
	    !
	;
	  storage_insert_fact(StorageName,Term,_Inserted),
	  fail
	).


/*************************************************************************
 Commit all backtrackable updates to Flora storage
 Reclaims storage of deleted nodes.
**************************************************************************/

flora_commit_storage :-
	(flora_storage_registry(StorageName),
	    storage_commit(StorageName),
	    storage_reclaim_space(StorageName),
	    fail
	; true).

/*************************************************************************
 Collect garbage in Flora storage tries
**************************************************************************/

flora_reclaim_storage_space :-
	(flora_storage_registry(StorageName),
	    storage_reclaim_space(StorageName),
	    fail
	; true).

/*************************************************************************
  flora_rpc_file(+MaxErr,+ErrNum,+WarnNum,-CompiledRuleList,-FileOptionList,-FileStatus)
*************************************************************************/
%% The first argument keeps track of the tail of a list.
flora_tailappend(V,[],V) :- !.
flora_tailappend([H|V],[H|L],T) :- flora_tailappend(V,L,T).


%% Calls the compiler. This is used to wrap templates, like trailers, 
%% with the WORKSPACE macros.
flora_rpc_file(MaxErr,ErrNum,WarnNum,CompiledRuleList,FileOptionList,FileStatus) :-
	flora_read_parse_compile(FLORA_FILE,Tokens,FlattenedRules,RuleOptions,RuleStatus),
	member(error(EN),RuleStatus),
	member(warning(WN),RuleStatus),
	NewErrNum is ErrNum+EN,
	NewWarnNum is WarnNum+WN,
	( EN > 0 -> %% errors just found
	    ( MaxErr \== FLORA_ALL, NewErrNum >= MaxErr ->
		FileStatus=FLORA_FAILURE,
		flora_stderr_string("\n"),
		flora_errorwarn_count(NewErrNum,NewWarnNum),
		flora_stderr_string("\n++compilation aborted\n")

	    ; flora_rule_delimeter_struct(_,_,_,_,_,RuleDelimeterToken),
	      flora_not_end_of_input(RuleStatus), member(RuleDelimeterToken,Tokens) ->
	        flora_rpc_file(MaxErr,NewErrNum,NewWarnNum,
                               _CompiledRuleList,_FileOptionList,FileStatus)

	    ; flora_not_end_of_input(RuleStatus), flora_discard_tokens ->
	        flora_rpc_file(MaxErr,NewErrNum,NewWarnNum,
                               _CompiledRuleList,_FileOptionList,FileStatus)
	    ;
	      FileStatus=FLORA_FAILURE,
	      flora_stderr_string("\n"),
	      flora_errorwarn_count(NewErrNum,NewWarnNum),
	      flora_stderr_string("\n++compilation aborted\n")
	    )
	;
	  ( NewErrNum == 0 -> %% no error so far
	      flora_tailappend(CompiledRuleList,FlattenedRules,NewCompiledRuleList),
	      flora_tailappend(FileOptionList,RuleOptions,NewFileOptionList)
	  ;
	    true
	  ),
	  ( flora_not_end_of_input(RuleStatus) ->
	      flora_rpc_file(MaxErr,NewErrNum,NewWarnNum,
                             NewCompiledRuleList,NewFileOptionList,FileStatus)
	  ; %% end of file already
	    ( NewErrNum == 0 ->
		NewCompiledRuleList=[],
		NewFileOptionList=[],
		FileStatus=FLORA_SUCCESS,
		( NewWarnNum == 0 ->
		    true
		;
		  flora_stdwarn_string("\n"),
		  flora_errorwarn_count(NewErrNum,NewWarnNum)
		)
	    ;
	      FileStatus=FLORA_FAILURE,
	      flora_stderr_string("\n"),
	      flora_errorwarn_count(NewErrNum,NewWarnNum),
	      flora_stderr_string("\n++compilation aborted\n")
	    )
	  )
	),
	!.


/*************************************************************************
  flora_discard_tokens/0
  scans the input until a rule delimeter is found. It fails if eof.
*************************************************************************/
flora_discard_tokens :-
	flora_warning_line('discarding tokens (rule delimeter `.'' or EOF expected)'),
	repeat,
	flora_tokens(Tokens,Status),
	flora_rule_delimeter_struct(_Txt,_LN1,_CN1,_LN2,_CN2,RuleDelimeterToken),
	( flora_end_of_input(Status) ->
	    !,
	    fail
	
	; member(RuleDelimeterToken,Tokens) ->
	    !
	;
	  fail
        ).


/*************************************************************************
  flora_read_parse_compile(+Option,-Tokens,-FlattenedRuleList,-OptionList,-Status)

  Note: This procedure can be used to read both file and command line.
        For reading file, Option is FLORA_FILE. For reading command line,
        Option is FLORA_COMMANDLINE.
*************************************************************************/
flora_read_parse_compile(Option,Tokens,FlattenedRules,OptionList,Status) :-
	flora_tokens(InputTokens,LexerStatus),
	flora_lexer_error(InputTokens,LexerStatus,LexErrNum),
	( LexErrNum > 0 ->
	    Tokens=InputTokens,
	    FlattenedRules=[],
	    OptionList=[],
	    ErrNum=LexErrNum,
	    WarnNum=0

	; flora_blank_line(InputTokens) ->
	    Tokens=InputTokens,
	    FlattenedRules=[],
	    OptionList=[],
	    ErrNum=0,
	    WarnNum=0
	;
	  ( Option == FLORA_COMMANDLINE ->
	      flora_construct_query_term(InputTokens,Tokens)
	  ;
	    Tokens=InputTokens
	  ),
	  flora_compose(Tokens,ComposerTerm,ComposerStatus),
	  flora_composer_errorwarn(Tokens,ComposerStatus,CompoErrNum,CompoWarnNum),
	  ( CompoErrNum > 0 ->
	      FlattenedRules=[],
	      OptionList=[],
	      ErrNum=CompoErrNum,
	      WarnNum=CompoWarnNum
	  ;
	    flora_parse(ComposerTerm,ParserTerm,ParserStatus),
	    flora_parser_error(Tokens,ParserStatus,ParErrNum),
	    ( ParErrNum > 0 ->
		FlattenedRules=[],
		OptionList=[],
		ErrNum=ParErrNum,
		WarnNum=CompoWarnNum
	    ;
	      flora_compile(ParserTerm,FlattenedRules,OptionList,CompilerStatus),
	      flora_compiler_errorwarn(Tokens,CompilerStatus,CompiErrNum,CompiWarnNum),
	      ErrNum=CompiErrNum,
	      WarnNum is CompoWarnNum+CompiWarnNum
	    )
	  )
        ),
	EWS=[error(ErrNum),warning(WarnNum)],
	( flora_end_of_input(LexerStatus) ->
	    Status=[FLORA_EOF|EWS]
	;
	  Status=[FLORA_NOT_EOF|EWS]
	).


/*************************************************************************
  flora_construct_query_term(+InputTokens,-Tokens)

  It constructs a query term from the shell command line input. Two extra
  pair of parentheses are added to enclose the input. This is to prevent
  the query term from being intepreted as having arity other than one.
*************************************************************************/
flora_construct_query_term(InputTokens,Tokens) :-
	flora_symbol_token_struct("?-",1,0,1,0,QueryOpToken),
	flora_symbol_token_struct("(",1,0,1,0,LPToken),
	Tokens=[QueryOpToken,LPToken,LPToken|L],
	flora_construct_rest_query_term(InputTokens,L).


flora_construct_rest_query_term([T],[RPToken,RPToken,T]) :-
	!,
	%% This last one from the input tokens is the rule delimeter.
	flora_symbol_token_struct(")",1,0,1,0,RPToken).

flora_construct_rest_query_term([T|Ts],[T|L]) :-
	flora_construct_rest_query_term(Ts,L).


/*************************************************************************
  flora_good_command(+Status)
  flora_bad_command(+Status)
  flora_noop_command(+Status)
*************************************************************************/
flora_good_command(Status) :- member(FLORA_SUCCESS,Status).
flora_bad_command(Status) :- member(FLORA_FAILURE,Status).
flora_noop_command(Status) :- member(FLORA_NOOP,Status).


/*************************************************************************
  flora_shell_command_line(-Code,-Options,-Status)
*************************************************************************/
flora_shell_command_line(Code,Options,Status) :-
	flora_reset_modules_for_shell,
	flora_read_parse_compile(FLORA_COMMANDLINE,Tokens,Rules,RuleOptions,RuleStatus),
	member(error(ErrNum),RuleStatus),
	( ErrNum > 0 ->
	    ( flora_end_of_input(RuleStatus) ->
		InputStatus=FLORA_EOF

	    ; flora_rule_delimeter_struct(_,_,_,_,_,RuleDelimeterToken),
	      member(RuleDelimeterToken,Tokens) ->
		InputStatus=FLORA_NOT_EOF

	    ; flora_discard_tokens ->
	        InputStatus=FLORA_NOT_EOF
	    ;
	      InputStatus=FLORA_EOF
	    ),
	    Status=[InputStatus,FLORA_FAILURE]
	;
	  ( Rules == [] ->
	      CommandStatus=FLORA_NOOP
	  ;
	    flora_intern_code(Rules,FLORA_DEFAULT_WORKSPACE,Code,CoderStatus),
	    ( CoderStatus == [] ->
		CommandStatus=FLORA_SUCCESS
	    ;
	      flora_coder_error(CoderStatus),
	      CommandStatus=FLORA_FAILURE
	    )
	  ),
	  sort(RuleOptions,Options),
	  ( flora_end_of_input(RuleStatus) ->
	      Status=[FLORA_EOF,CommandStatus]
	  ;
	    Status=[FLORA_NOT_EOF,CommandStatus]
	  )
	),
	!.


/*************************************************************************
  flora_flrfilename_error(+FileName)

  This procedure is called when search for a Flora file is failed. The
  failure may be due to incorrect file name extension or non-existence.
*************************************************************************/
flora_flrfilename_error(File) :-
	( parse_filename(File,_,_,Ext), Ext \== '', Ext \== FLORA_FILE_EXT,
	  path_sysop(exists,File) ->
	    flora_stderr_nl,
	    flora_error_line('%s: Filename extension must be %s!',
			     args(File,FLORA_FILE_EXT))
	;
	  flora_stderr_nl,
	  flora_error_line('File %s[.%s] does not exist!',args(File,FLORA_FILE_EXT))
        ),
	!.


/*************************************************************************
  utilities
*************************************************************************/
flora_errorwarn_count(ErrNum,WarnNum) :-
	( ErrNum == 1 ->
	    flora_stderr_string("++1 error\n")

	; ErrNum > 1 ->
	    flora_stderr_string("++%d errors\n",args(ErrNum))
	;
	  true
        ),
	( WarnNum == 1 ->
	    flora_stdwarn_string("++1 warning\n")

	; WarnNum > 1 ->
	    flora_stdwarn_string("++%d warnings\n",args(WarnNum))
	;
	  true
        ),
	!.


flora_last_element([T],T).
flora_last_element([_|L],T) :- flora_last_element(L,T).


flora_nth_element([T|_],1,T) :- !.
flora_nth_element([_|L],N,T) :- M is N-1, flora_nth_element(L,M,T).


/*************************************************************************
  flora_lexer_error(+Tokens,+LexerStatus,-ErrNum)
*************************************************************************/
flora_lexer_error(Tokens,LexerStatus,ErrNum) :-
	( member(error(Msg),LexerStatus) ->
	    flora_last_element(Tokens,Tk),
	    flora_token_text(Tk,TextStr,_BLN,_BCN,ELN,ECN),
	    flora_error_line('[Lexer] near line(%d)/char(%d) `%s''',
	                     args(ELN,ECN,TextStr)),
	    flora_error_indentline,
	    flora_stderr_string("%s\n",args(Msg)),
	    ErrNum=1
	;
	  ErrNum=0
        ).


/*************************************************************************
  flora_composer_errorwarn(+Tokens,+ComposerStatus,-ErrNum,-WarnNum)
*************************************************************************/
flora_composer_errorwarn(_Tokens,[],0,0) :- !.

flora_composer_errorwarn(Tokens,[error(Indx,Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_nth_element(Tokens,Indx,Tk),
	flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN),
	flora_error_line('[Composer] near line(%d)/char(%d) `%s''',
                         args(BLN,BCN,TextStr)),
	flora_error_indentline,
	flora_stderr_string("%s\n",args(Msg)),
	flora_composer_errorwarn(Tokens,L,EN,WarnNum),
	ErrNum is EN+1.

flora_composer_errorwarn(Tokens,[error(I1,I2,Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_nth_element(Tokens,I1,Tk1),
	flora_nth_element(Tokens,I2,Tk2),
	flora_token_text(Tk1,TextStr1,BLN1,BCN1,_ELN1,_ECN1),
	flora_token_text(Tk2,TextStr2,BLN2,BCN2,_ELN2,_ECN2),
	flora_error_line('[Composer] near line(%d)/char(%d) `%s'' and near line(%d)/char(%d) `%s''',
	                 args(BLN1,BCN1,TextStr1,BLN2,BCN2,TextStr2)),
	flora_error_indentline,
	flora_stderr_string("%s\n",args(Msg)),
	flora_composer_errorwarn(Tokens,L,EN,WarnNum),
	ErrNum is EN+1.

flora_composer_errorwarn(Tokens,[warning(I1,I2,Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_nth_element(Tokens,I1,Tk1),
	flora_nth_element(Tokens,I2,Tk2),
	flora_token_text(Tk1,TextStr1,BLN1,BCN1,_ELN1,_ECN1),
	flora_token_text(Tk2,TextStr2,BLN2,BCN2,_ELN2,_ECN2),
	flora_warning_line('[Composer] near line(%d)/char(%d) `%s'' and near line(%d)/char(%d) `%s''',
	                   args(BLN1,BCN1,TextStr1,BLN2,BCN2,TextStr2)),
	flora_warning_indentline,
	flora_stdwarn_string("%s\n",args(Msg)),
	flora_composer_errorwarn(Tokens,L,ErrNum,WN),
	WarnNum is WN+1.

flora_composer_errorwarn(Tokens,[error(Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_error_line('[Composer] %s',args(Msg)),
	flora_composer_errorwarn(Tokens,L,EN,WarnNum),
	ErrNum is EN+1.


/*************************************************************************
  flora_parser_error(+Tokens,+ParserStatus,-ErrNum)
*************************************************************************/
flora_parser_error(_Tokens,[],0) :- !.

flora_parser_error(Tokens,[error(Indx,Msg)|L],ErrNum) :-
	!,
	flora_nth_element(Tokens,Indx,Tk),
	flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN),
	flora_error_line('[Parser] near line(%d)/char(%d) `%s''',
                         args(BLN,BCN,TextStr)),
	flora_error_indentline,
	flora_stderr_string("%s\n",args(Msg)),
	flora_parser_error(Tokens,L,EN),
	ErrNum is EN+1.

flora_parser_error(Tokens,[error(Msg)|L],ErrNum) :-
	!,
	flora_error_line('[Parser] %s',args(Msg)),
	flora_parser_error(Tokens,L,EN),
	ErrNum is EN+1.


/*************************************************************************
  flora_compiler_errorwarn(+Tokens,+CompilerStatus,-ErrNum,-WarnNum)
*************************************************************************/
flora_compiler_errorwarn(_Tokens,[],0,0) :- !.

flora_compiler_errorwarn(Tokens,[error(Indx,Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_nth_element(Tokens,Indx,Tk),
	flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN),
	flora_error_line('[Compiler] near line(%d)/char(%d) `%s''',
                         args(BLN,BCN,TextStr)),
	flora_error_indentline,
	flora_stderr_string("%s\n",args(Msg)),
	flora_compiler_errorwarn(Tokens,L,EN,WarnNum),
	ErrNum is EN+1.

flora_compiler_errorwarn(Tokens,[warning(Indx,Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_nth_element(Tokens,Indx,Tk),
	flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN),
	flora_warning_line('[Compiler] near line(%d)/char(%d) `%s''',
                           args(BLN,BCN,TextStr)),
	flora_warning_indentline,
	flora_stdwarn_string("%s\n",args(Msg)),
	flora_compiler_errorwarn(Tokens,L,ErrNum,WN),
	WarnNum is WN+1.

flora_compiler_errorwarn(Tokens,[error(Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_error_line('[Compiler] %s',args(Msg)),
	flora_compiler_errorwarn(Tokens,L,EN,WarnNum),
	ErrNum is EN+1.


/*************************************************************************
  flora_coder_error(+CoderStatus)
*************************************************************************/
flora_coder_error([]) :- !.

flora_coder_error([error(Msg)|L]) :-
	!,
	flora_error_line('[Coder] %s',args(Msg)),
	flora_coder_error(L).


/*****************************************************************************
  flora_list2conjunct(+List,-Goal)
*****************************************************************************/
flora_list2conjunct([G],G) :- !.

flora_list2conjunct([G|L],Goal) :-
	!,
	flora_list2conjunct(L,LG),
	Goal =.. [',',G,LG].


/*************************************************************************
  flMaxerr(+Num)
*************************************************************************/
:- flMaxerr(8).

flMaxerr(X) :-
	( var(X) ->
	    flora_maxerr(X)

	; X \== FLORA_ALL, (not integer(X); X < 1) ->
	    flora_error_line('invalid argument to maxerr'),
	    fail
	;
	  retractall(flora_maxerr(_)),
	  assert(flora_maxerr(X))
	).


/*************************************************************************
  flP2H/2
*************************************************************************/
flP2H(PrologTerm,HiLogTerm) :- plg2hlg(PrologTerm,HiLogTerm,WRAP_HILOG).


/*************************************************************************
  flHalt/0
*************************************************************************/
flHalt :- halt.


/*************************************************************************
  flDump/1
*************************************************************************/
flDump(InFile>>Workspace) :-
	flora_dump_file(InFile,Workspace,dontsquash).

flDump(InFile) :-
	flora_dump_file(InFile,FLORA_DEFAULT_WORKSPACE,squash).


/*************************************************************************
  flora_dump_file(+File,+Workspace,+SquashingOption)

  It expects a Flora file as input and dump its content in a more readable
  format. If SquashingOption == squash, ignore Workspace in the final round 
  of gpp pre-processing.
*************************************************************************/
flora_dump_file(InFile,Workspace,SquashingOption) :-
	flora_check_filename(InFile),
	flora_check_workspace(Workspace),
	( flora_locate_file(InFile,FLORA_FILE_EXT,FlrFile) ->
	    flora_flcompile(FlrFile,Workspace)
	;
	  flora_flrfilename_error(InFile),
	  !,
	  fail
	),
	!,
	%% Compilation succeeds. Need to dump file contents.
	( SquashingOption == squash ->
	    NewWorkspace=''
	;
	  %% Add '_' to the workspace to simplify reading.
	  str_cat(Workspace,'_',NewWorkspace)
	),
	%% Find the files that need to be dumped.
	flora_mainP_filename(FlrFile,PFile),
	flora_FDB_filename(FlrFile,FDBFile),
	flora_dump_filename(PFile,DumpPFile),
	flora_dump_filename(FDBFile,DumpFDBFile),
	!,
	( path_sysop(exists,PFile) ->
	    %% Dump the main .P file.
	    flora_gpp_dumpfile(PFile,DumpPFile,NewWorkspace)
	;
	  flora_error_line('Failed to create the main dumpfile %s',
		           arg(PFile))
	),
	( path_sysop(exists,FDBFile) ->
	    %% Dump the .fdb file if it exists.
	    flora_gpp_dumpfile(FDBFile,DumpFDBFile,NewWorkspace)
	;
	  true
	),
	!.


/*************************************************************************
  flora_gpp_dumpfile(+FileName,+DumpFileName,+Workspace)

  When this procedure is called, the input file is already checked
  for existence.
*************************************************************************/
flora_gpp_dumpfile(FileName,DumpFileName,Workspace) :-
	flora_message_line('Making dump file %s from %s',args(FileName,DumpFileName)),
	flora_set_xpp_options(Workspace,'-D FLORA_DUMP'),
	file_open(DumpFileName,w,DumpPort),
	xpp_process_file(FileName,XPP_process,IOportFromGPP),
	copyIOport(IOportFromGPP,DumpPort),
	process_control(XPP_process,wait),
	flora_clear_xpp_options,
	file_close(IOportFromGPP),
	file_close(DumpPort),
	!.

flora_gpp_dumpfile(FileName,_DumpFileName,_Workspace) :-
	flora_error_line('Failed to make a dump file for %s!',args(FileName)),
	!,
	fail.


/*************************************************************************
  flCompileInclude(+File)

  This is used only in the closure/Makefile
  It takes a trailer template and wraps it with the workspace and 
  flora prefixes. This way the trailer is easier to maintain and understand.

  The included file is treated as a Flora program, so the compiler wraps it 
  with the appropriate macros (e.g., WORKSPACE), as it would any other
  Flora program.
*************************************************************************/
flCompileInclude(File) :-
	flora_check_filename(File),
	( flora_locate_file(File,FLORA_INCLUDE_EXT,FLIFile) ->
	    flora_FLH_filename(FLIFile,FLHFile),
	    flora_compile_incfile(FLIFile,FLHFile,Status),
	    (Status == FLORA_FAILURE -> fail; true)

	; parse_filename(File,_,_,Ext), Ext \== '', Ext \== FLORA_INCLUDE_EXT,
	  path_sysop(exists,File)
	->
	    flora_stderr_nl,
	    flora_error_line('%s: Include filename extension must be %s!',
			     args(File,FLORA_INCLUDE_EXT)),
	    fail
	;
	  flora_stderr_nl,
	  flora_error_line('File %s[.%s] does not exist!',
			   args(File,FLORA_INCLUDE_EXT)),
          fail
        ),
	!.


/*************************************************************************
  flora_compile_incfile(+InputFile,+OutputFile,-FileStatus) :-

  This compiles the include file (it is called from flCompileInclude/1)
  and adds the WORKSPACE and other macros to it.

  Note: FileStatus returns either FLORA_FAILURE or FLORA_SUCCESS.
*************************************************************************/
flora_compile_incfile(InputFile,OutputFile,FileStatus) :-
	flora_stdmsg_nl,
	flora_message_line('compiling FLORA template include file %s',args(InputFile)),
	cputime(T0),
	seeing(PreInFile),
	%% Enable the compilation for FLORA template include files.
	conset(flora_compile_include_file,1),
	flora_reset_modules_for_file,
	flora_set_xpp_options,
	xpp_process_file(InputFile,XPP_process,IOportFromProc),
	stat_set_flag(CURRENT_INPUT,IOportFromProc),
	flora_rpc_file(FLORA_ALL,0,0,CompiledRuleList,_FileOptionList,CompileStatus),
	%% Wait, not to leave zombies.
	process_control(XPP_process,wait),
	%% Release the file descriptor used to read from cpp.
	file_close(IOportFromProc),
	flora_clear_xpp_options,
	%% Disable the compilation for FLORA template include files.
	conset(flora_compile_include_file,0),
	see(PreInFile),
	!,
	( CompileStatus == FLORA_FAILURE ->
	    FileStatus=FLORA_FAILURE
	;
	  telling(PreOutFile),
	  tell(OutputFile),
	  flora_extern_code(CompiledRuleList,CoderStatus),
	  ( CoderStatus == [] ->
	      FileStatus=FLORA_SUCCESS
	  ;
	    flora_coder_error(CoderStatus),
	    FileStatus=FLORA_FAILURE
	  ),
	  told,
	  tell(PreOutFile),
	  cputime(T1),
	  T is T1-T0,
	  flora_message_line('Done! CPU time used: %S seconds',args(T))
	),
	!.
