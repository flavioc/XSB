/* File:      flrprettyprint.flr
**
** Author(s): Michael Kifer
** Contact:   xsb-contact@cs.sunysb.edu
**
** Copyright (C) The Research Foundation of SUNY, 2001
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id$
**
*/

/*   To pretty print an object:
**	?- prettyprint_obj(obj,module).
**   To save it in a file:
**	?- prettyprint_obj(obj,module,outfile).
**   To pretty print a class:
**      ?- prettyprint_class(class,module).
**   To save result of a pretty-printed class in a file:
**      ?- prettyprint_class(class,module,outfile).
**   To print class membership:
**      ?- prettyprint_isa(class,module).
**   To save it in a file:
**      ?- prettyprint_isa(class,module,outfile).
*/



:- table flora_in_between_isa/3, flora_in_between_sub/3.
:- firstorder flora_in_between_isa/3, flora_in_between_sub/3.

%% Methods to ignore during pretty printing
flora_print_ignore(print(pretty)).
flora_print_ignore(ignore(pretty)).

%% prettyprint_class(+Class,+Module,+File)
prettyprint_class(Class, Module, Outfile) :-
	tell(Outfile)@prolog(),
    	prettyprint_class(Class, Module),
	told@prolog().
%% Print class in Module
prettyprint_class(Class,Module) :-
	flora_pp_immediate_superclasses(Class,Module),
    	prettyprint_obj(Class,Module),
	(X : Class)@Module,
	ground(X)@prolog(basics),  %% to ground X, if non-ground
	prettyprint_obj(X,Module),
	fail.

%% Print obj from Module
prettyprint_obj(X,Module) :-
	flora_pp_immediate_classes(X,Module),
	flora_pp_write_header(X),
	flora_pp_write_body_scalar(X,Module),
	flora_pp_write_body_set(X,Module),
	writeln('].')@prolog(), nl@prolog().
%% Print obj in Module to a Outfile
prettyprint_obj(X,Module,Outfile) :-
	tell(Outfile)@prolog(),
	prettyprint_obj(X,Module),
	told@prolog().

%% Print all the isa info in one shot.
prettyprint_isa(Class,Module) :-
	flora_pp_immediate_isa(Class,Module),
	flora_pp_subclasses_isa(Class,Module).
%% Same, but save in a file
prettyprint_isa(Class, Module, File) :-
	tell(File)@prolog(),
	prettyprint_isa(Class, Module),
	told@prolog().


flora_pp_write_header(X) :-
    	atom(X)@prolog(),
	!,
	flP2H(PX,X),
    	fmt_write('''%s''[', PX)@prolog(),
    	nl@prolog().
flora_pp_write_header(X) :-
    	is_charlist(X)@prolog(),
	!,
	flP2H(PX,X),
    	fmt_write('"%s"[',PX)@prolog(),
    	nl@prolog().
flora_pp_write_header(X) :- write(X)@prolog(), writeln('[')@prolog().

%% Print out scalar methods
flora_pp_write_body_scalar(Obj,Module) :-
    	MethLst1 = collectset{SM | Obj[SM -> _]@Module},
	sort(MethLst1, MethLst2)@prolog(),
	flora_pp_write_body_scalar1(Obj, MethLst2,Module).

%% Test if method is to be ignored and either skip it or print it.
flora_pp_write_body_scalar1(_, [], _Module).
flora_pp_write_body_scalar1(Obj, [MethInv|MethInvs],Module) :-
        MethInv = [M|_Args],
	%%printable_object[ignore(pretty) ->> {M}],
	flora_print_ignore(M),
	!,
	%% skip this method
	flora_pp_write_body_scalar1(Obj, MethInvs,Module).
flora_pp_write_body_scalar1(Obj, [MethInv|MethInvs],Module) :-
	Obj[MethInv -> Val]@Module,
	write('    ')@prolog(), flora_pp_write_method_invocation(MethInv),
	write(' -> ')@prolog(), flora_pp_write_value(Val),
	flora_pp_write_comma_maybe(MethInvs),
	flora_pp_write_body_scalar1(Obj, MethInvs,Module).

flora_pp_write_body_set(Obj,Module) :-
    	MethLst1 = collectset{MM | Obj[MM ->> _]@Module},
	sort(MethLst1, MethLst2)@prolog(),
	flora_pp_write_body_set1(Obj, MethLst2,Module).

flora_pp_write_body_set1(_Obj, [],_Module).
flora_pp_write_body_set1(Obj, [MethInv|MethInvs],Module) :-
        MethInv = [M|_Args],
	%%printable_object[ignore(pretty) ->> {M}],
	flora_print_ignore(M),
	!,
	%% skip this method
	flora_pp_write_body_set1(Obj, MethInvs,Module).
flora_pp_write_body_set1(Obj, [MethInv|MethInvs],Module) :-
	Vals = collectset{V| Obj[MethInv ->> V]@Module},
	write('    ')@prolog(), flora_pp_write_method_invocation(MethInv),
	write(' ->> ')@prolog(), flora_pp_write_set(Vals),
	flora_pp_write_comma_maybe(MethInvs),
	flora_pp_write_body_set1(Obj, MethInvs,Module).

%% Write comma, if List is not empty 
flora_pp_write_comma_maybe([]) :- nl@prolog().
flora_pp_write_comma_maybe([_First| _Rest]) :- writeln(',')@prolog().


flora_pp_write_method_invocation(M) :- flP2H(PM,M),write(PM)@prolog().

flora_pp_write_set(L) :-
    	write('{')@prolog(),
	flora_pp_write_set1(L),
	write('}')@prolog().

flora_pp_write_set1([]).
flora_pp_write_set1([Elt]) :- flora_pp_write_value(Elt).
flora_pp_write_set1([Elt, Elt2 | Rest]) :-
    	flora_pp_write_value(Elt), write(',')@prolog(),
	flora_pp_write_set1([Elt2|Rest]).
        
flora_pp_write_value(Val) :-
	atom(Val)@prolog(),
	!,
	flP2H(PVal,Val),
	fmt_write('''%s''', PVal)@prolog().
flora_pp_write_value(Val) :-
	is_charlist(Val)@prolog(),
	!,
	flP2H(PVal,Val),
	fmt_write('"%s"', PVal)@prolog().
flora_pp_write_value(Val) :-
	flP2H(PVal,Val),
	write(PVal)@prolog().

flora_pp_immediate_isa(Class,Module) :-
	(X : Class)@Module, 
	ground([X,Class])@prolog(basics),
	%% no intermediate class
	tnot(flora_in_between_isa(X,Class,Module)),
	flora_pp_write_value(X), write('		:  ')@prolog(),
	flora_pp_write_value(Class), nl@prolog(),
	fail.
flora_pp_immediate_isa(_,_).

%% There is an intermediate class between X and Class
flora_in_between_isa(X,Class,Module) :-
	(X:C1)@Module, C1 \= Class, (C1::Class)@Module.


flora_pp_subclasses_isa(Class,Module) :-
	(Sub :: Class)@Module,
	Sub \= Class,
	tnot(flora_in_between_sub(Sub,Class,Module)),
	flora_pp_immediate_isa(Sub,Module),
        flora_pp_subclasses_isa(Sub,Module),
	fail.
flora_pp_subclasses_isa(_,_).

flora_in_between_sub(Sub,Class,Module) :-
	(Sub :: Sub1)@Module,
	Sub \= Sub1, Sub1 \= Class,
	(Sub1 :: Class)@Module.
	
%% immediate classes of Obj
flora_pp_immediate_classes(Obj,Module) :-
	(Obj : Class)@Module,
	ground([Obj,Class])@prolog(basics),
	tnot(flora_in_between_isa(Obj,Class,Module)),
	flora_pp_write_value(Obj), write('	:  ')@prolog(),
	flora_pp_write_value(Class),
	write('.')@prolog(), nl@prolog(),
	fail.
flora_pp_immediate_classes(_Obj,_Module).

flora_pp_immediate_superclasses(Class,Module) :-
	(Class :: Super)@Module, ground(Super)@prolog(basics),
	Class \= Super,
	tnot(flora_in_between_sub(Class,Super,Module)),
	flora_pp_write_value(Class),
	write('	:: ')@prolog(),
	flora_pp_write_value(Super),
	write('.')@prolog(), nl@prolog(),
	fail.
flora_pp_immediate_superclasses(_,_).
