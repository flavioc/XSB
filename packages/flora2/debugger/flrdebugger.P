/* File:        flrdebugger.P  -- Flora debugger
**
** Author(s): Michael Kifer
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) The Research Foundation of SUNY, 2001
**
** FLORA-2 is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** FLORA-2 is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with FLORA-2; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
** 
** $Id$
** 
*/

:- compiler_options([xpp_on]).
#include "standard.h"

#include "flrheader.flh"
#include "flora_terms.flh"



:- import file_close/1, ioport2iostream/2 from file_io.
:- import format/3 from format.
:- import debug_display_call_hook/1, flora_switch/1 from usermod.
:- import package_configuration/2 from packaging.
:- import process_control/2 from shell.
:- import xpp_process_file/3 from parse.
:- import member/2, append/3, length/2 from basics.

:- import flora_decode_predicate/6,
	flora_module_name/3,
	flora_firstorder_module_predicate_symbol/3
    from flrwrapper.
:- import flora_prlgdef/2 from flrprolog.
:- import flora_opdef/3 from flroperator.
:- import flora_set_xpp_options_for_read/1,
	flora_set_xpp_options_for_read/0,
	flora_clear_xpp_options/0 from flrutils.
:- import flora_message_line/1, flora_message_line/2 from flrprint.
:- import flLoadedModule/1 from flora2.

:- import flora_concat_atoms/2,
	flora_slash/1,
	flora_set_counter/2
   from flrporting.


:- import flora_handle_trace/0,
	flora_handle_notrace/0
   from usermod.
%% This is a trick: the debugger wants the hook to be in usermod, 
%% but we want to work in a module
:- import flora_write_debugger_hook/1 from usermod.

:- dynamic debug_display_call_hook/1.
:- dynamic flora_switch/1.
:- dynamic flora_debug_context/1.
:- dynamic flora_write_debugger_hook/1.

:- dynamic
	hide_this_hide/2,
	show_this_hide/2,
	hide_this_show/2,
	trace_this_noprint/2,
	trace_this_print/2,
	flora_hide_this_hide/1,
	flora_hide_this_show/1,
	flora_show_this_hide/1,
	flora_trace_this_noprint/1,
	flora_trace_this_print/1.
:- import 
	hide_this_hide/2,
	show_this_hide/2,
	hide_this_show/2,
	trace_this_noprint/2,
	trace_this_print/2,
	flora_hide_this_hide/1,
	flora_hide_this_show/1,
	flora_show_this_hide/1,
	flora_trace_this_noprint/1,
	flora_trace_this_print/1
    from usermod.

:- export flora_read_debugger_data/1,
	flora_load_dyndata_for_user_modules/1,
	FLORA_SYMBOL('debugger_loaded'),
	flora_trace/0,
	flora_notrace/0.


?- assert(debug_display_call_hook(flora_write_debugger_hook)).
?- assert((
           flora_write_debugger_hook(X) :-
	     (\+flora_switch(low_level_trace) -> flora_write_goal(X)
	     ; print_item(X)
	     )
	  )).


:- dynamic flora_dbg_stream/1.
?- (flora_dbg_stream(Stream) -> close(Stream), retractall(flora_dbg_stream(_))
   ; ioport2iostream(STDDBG,Stream), assert(flora_dbg_stream(Stream))
   ).
flora_write_dbg_item(Format,ArgList) :-
	flora_dbg_stream(Stream), format(Stream,Format,ArgList).
flora_write_dbg_item(Item) :- flora_dbg_stream(Stream), write(Stream,Item).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% flora_write_goal %%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_write_goal(Call) :- var(Call), print_item(Call).

flora_write_goal(Call) :-
	classify_call(Call, Type,Basename,ArgList,Workspace),
	( Type == (firstorder)
	-> flora_write_firstorder(Basename,ArgList,Workspace)
	; Type == (hilog)
	-> flora_write_hilog(Basename,ArgList,Workspace)
	; Type == (flogic)
	-> flora_write_flogic(Basename,ArgList,Workspace)
	; Type == (inheritance)
	-> print_item('(Trying to derive by inheritance) '),
	    flora_write_flogic(Basename,ArgList,Workspace)
	; Type == (definedvalue)
	-> print_item('derivable by deduction '),
	    append(ArgList, ['...'], NewArgList),
	    flora_write_flogic(Basename,NewArgList,Workspace)
	; Type == (conflictvalue)
	-> print_item('inheritance conflict for '),
	    append(ArgList, ['...'], NewArgList),
	    flora_write_flogic(Basename,NewArgList,Workspace)
	),
	!.


%% An update
flora_write_goal(Call) :-
	Call =.. [UpdPred,UpdLiterals|Query],
	is_update_call(UpdPred,UpdName),
	!,
	(Query==[]
	-> flora_write_update(UpdName,UpdLiterals)
	; Query = [RealQuery],
	    flora_write_update(UpdName,UpdLiterals,RealQuery)
	).

/*
%% aggregate
flora_write_goal(Call) :-
	Call = ','(AggrCall,ComparisonCall),
	AggrCall =.. [AggrPred,AggrVar,GroupVarList,Query,AggrResultVar],
	is_aggregate_call(AggrPred,AggrName),
	flora_write_aggregate(AggrName,AggrVar,GroupVarList,
			      Query,AggrResultVar,ComparisonCall).
*/
%% aggregate
flora_write_goal(Call) :-
	Call =.. [AggrPred,AggrVar,GroupVarList,Query,AggrResultVar],
	is_aggregate_call(AggrPred,AggrName),
	flora_write_aggregate(AggrName,AggrVar,GroupVarList,
			      Query,AggrResultVar).

%% flLoad in the form of [...]
flora_write_goal(Call) :-
	Call = FLLIBLOAD(Arg),
	print_item('['),
	(Arg = '>>'(File,Module)
	-> print_items((File,'>>',Module))
	;  print_item(File)
	),
	print_item(']').

%% List of goals -- the last one
flora_write_goal(Call) :-
	is_commalist(Call),
	!,
	write_goal_commalist(Call).
flora_write_goal(Call) :-
	is_list_term(Call),
	!,
	write_goal_list(Call).
flora_write_goal(Call) :-
	is_disjunction(Call),
	!,
	write_disjunction(Call).
flora_write_goal('->'(Call1,Call2)) :-
	flora_write_goal(Call1),
	print_item(' -> '),
	flora_write_goal(Call2).

flora_write_goal(Call) :-
	Call =.. [F, Subcall],
	member(F, [(tnot),('\+'),(not),(call)]),
	!,
	print_items((F,'(')),
	flora_write_goal(Subcall),
	print_item(')').

flora_write_goal(Call) :-
	Call = FL_UNIVEQFORM(Left,Right),
	!,
	flora_write_goal(Left),
	print_items((' ', FL_UNIVEQFORM, ' ')),
	flora_write_goal(Right).

flora_write_goal(call(Call)) :-
	print_item('call('),
	flora_write_goal(Call),
	print_item(')').

flora_write_goal(catch(Call,Catcher,Handler)) :-
	print_item('catch('),
	flora_write_goal(Call),
	print_item(','),
	write_hilog(Catcher),
	print_item(','),
	flora_write_goal(Handler),
	print_item(')').

flora_write_goal(FL_IF(IfCall)) :-
	!,
	flora_print_if_statement(IfCall).

flora_write_goal(FL_UNLESS(FL_DO(Cond,Action))) :-
	!,
	flora_print_unless(Cond,Action).

flora_write_goal(FL_WHILE(FL_DO(Cond,Action))) :-
	!,
	flora_print_while('DO',Cond,Action).

flora_write_goal(FL_WHILE(FL_LOOP(Cond,Action))) :-
	!,
	flora_print_while('LOOP',Cond,Action).

flora_write_goal(FL_DO(FL_UNTIL(Action,Cond))) :-
	!,
	flora_print_until('DO',Action,Cond).

flora_write_goal(FL_LOOP(FL_UNTIL(Action,Cond))) :-
	!,
	flora_print_until('LOOP',Action,Cond).


%% This occurs when you have hilog-lit@Module, where Module is a var
flora_write_goal(FLLIBMODLIT(WRAP_HILOG,Args,Module)) :-
	!,
	Args = [Basename|ArgList],
	flora_write_hilog(Basename,ArgList,Module).
%% This occurs when you have flogic-lit@Module, where Module is a var
flora_write_goal(FLLIBMODLIT(Basename,Args,Module)) :-
	!,
	flora_write_flogic(Basename,Args,Module).
%% This occurs when you have firstorder-lit@Module, where Module is a var
flora_write_goal(FLLIBMODLIT(FL_FIRSTORDER,Basename,Args,Module)) :-
	!,
	flora_write_firstorder(Basename,Args,Module).

flora_write_goal(Call) :-
	is_prolog(Call),
	!,
	flora_write_prolog(Call).

%% catch all
flora_write_goal(Call) :- print_item(Call).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

write_goal_commalist(','(G,Gs)) :-
	!,
	flora_write_goal(G),
	print_item(','),
	write_goal_commalist(Gs).
write_goal_commalist(G) :-
	!,
	flora_write_goal(G).

write_goal_list([]) :- !, print_item([]).
write_goal_list(List) :-
	print_item('['),
	write_goal_list_internal(List),
	print_item(']').
write_goal_list_internal([H]) :-
	!,
	flora_write_goal(H).
write_goal_list_internal([H|R]) :-
	!,
	flora_write_goal(H),
	print_item(','),
	write_goal_list_internal(R).
write_disjunction(';'(G1,G2)) :-
	!,
	flora_write_goal(G1),
	print_item(' ; '),
	flora_write_goal(G2).


/*********************************************************************/
%%%%%%%%%%%%%%%%%%%%% Molecules %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_write_flogic(Basename,Args,Workspace) :-
	decode_molecule(Basename,Code,Args),
	write_code(Code),
	write_workspace(Workspace).

write_code(Code) :-
	Code =.. [code|Elements],
	write_code_elements(Elements).
write_code_elements([]).
write_code_elements([H|Tail]) :-
	write_value(H),
	write_code_elements(Tail).


is_flogic(Call) :-
	callable(Call),
	classify_call(Call, flogic,_Basename,_ArgList,_Workspace).
is_prolog(Call) :- 
	callable(Call),
	classify_call(Call, prolog,_Basename,_ArgList,_Workspace).
is_hilog(Call) :- 
	callable(Call),
	classify_call(Call, hilog,_Basename,_ArgList,_Workspace).
is_hilog(Call) :-
	callable(Call),
	Call =.. [WRAP_HILOG|_].
is_commalist(Call) :-
	callable(Call),
	functor(Call,',',2).
%% only tests if the functor is '.' -- not that it is a proper list
is_list_term(Call) :-
	callable(Call),
	functor(Call,'.',2).
is_disjunction(Call) :-
	callable(Call),
	functor(Call,';',2).

%% The predicates declared as flora_prlg in flrprolog.P
is_flora_builtin(Call) :-
	callable(Call),
	functor(Call,F,N),
	flora_prlgdef(F,N).


decode_molecule(Wrapper,Code,ComponentList) :-
	(str_match(FLDEBUGPREFIX,Wrapper,forward,0,End),! ; End=0),
	substring(Wrapper,End,_,BaseWrapper),
	decode_molecule_base(BaseWrapper,Code,ComponentList).

decode_molecule_base(WRAP_FD,code(O,'[',M,'->',V,']'), [O,M,V]).
decode_molecule_base(WRAP_MVD,code(O,'[',M,'->>',V,']'), [O,M,V]).
decode_molecule_base(WRAP_IFD,code(O,'[',M,'*->',V,']'), [O,M,V]).
decode_molecule_base(WRAP_IMVD,code(O,'[',M,'*->>',V,']'), [O,M,V]).
decode_molecule_base(WRAP_FDSIG,code(O,'[',M,'=>',V,']'), [O,M,V]).
decode_molecule_base(WRAP_IFDSIG,code(O,'[',M,'*=>',V,']'), [O,M,V]).
decode_molecule_base(WRAP_MVDSIG,code(O,'[',M,'=>>',V,']'), [O,M,V]).
decode_molecule_base(WRAP_IMVDSIG,code(O,'[',M,'*=>>',V,']'), [O,M,V]).
decode_molecule_base(WRAP_MVDINC,code(O,'[',M,'+>>',V,']'), [O,M,V]).
decode_molecule_base(WRAP_IMVDINC,code(O,'[',M,'*+>>',V,']'), [O,M,V]).
decode_molecule_base(WRAP_MVDTOLIST,code(O,'[',M, '->->',V,']'), [O,M,V]).
decode_molecule_base(WRAP_IMVDTOLIST,code(O,'[',M, '*->->',V,']'), [O,M,V]).
decode_molecule_base(WRAP_ISA,code(O,':',C), [O,C]).
decode_molecule_base(WRAP_SUB,code(Sub,'::',Sup), [Sub,Sup]).
%% boolean method
decode_molecule_base(WRAP_METH,code(O,'[',P,']'), [O,P]).
%% inheritable boolean method
decode_molecule_base(WRAP_IMETH,code(O,'[*',P,']'), [O,P]).
%% procedural boolean method
decode_molecule_base(WRAP_TRAN,code(O,'[#',P,']'), [O,P]).

decode_molecule_base(WRAP_OBJEQL,code(O1,':=:',O2), [O1,O2]).

%%%%%%%%%%%%%%%%%%%%% HiLog %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_write_hilog(Basename,Args,Workspace) :-
	%% Construct hilog term
	HTerm =.. [WRAP_HILOG,Basename|Args],
	write_hilog(HTerm),
	write_workspace(Workspace).

%%%%%%%%%%%%%%%%%%%%%% Prolog %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% classify_call would classify WRAP_HILOG(....) as prolog, because
%% it is a term and not a predicate
flora_write_prolog(Call) :-
	is_hilog(Call),
	!,
	write_hilog(Call).
flora_write_prolog(Call) :-
	is_flora_builtin(Call),
	Call =.. [F|Args],
	length(Args,Arity),
	flora_write_builtin(F,Arity,Args).
flora_write_prolog(Call) :-
	Call =.. [F|Args],
	print_items((F,'(')),
	write_hilog_args(Args),
	print_item(')@prolog()').

flora_write_builtin(F,0,_) :- !, print_item(F).
%% This would have to be expanded to deal with unary ops
flora_write_builtin(F,1,[Arg]) :- !,
	print_items((F,'(')),
	write_hilog(Arg),
	print_item(')').
%% This deals with binary ops
flora_write_builtin(F,2,[Arg1,Arg2]) :- !,
	((flora_opdef(_,xfx,F); flora_opdef(_,yfx,F); flora_opdef(_,xfy,F))
	-> write_hilog(Arg1), print_items((' ',F,' ')), write_hilog(Arg2)
	;  print_items((F,'(')),
	    write_hilog(Arg1), print_item(','), write_hilog(Arg2),
	    print_item(')')
	).
flora_write_builtin(F,_,Args) :-
	print_items((F,'(')),
	write_hilog_args(Args),
	print_item(')').

%%%%%%%%%%%%%%%%%%%%%% Firstorder %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_write_firstorder(Basename,ArgList,Workspace) :-
	print_items((Basename,'(')),
	write_hilog_args(ArgList),
	print_item(')'),
	write_workspace(Workspace).


%%%%%%%%%%%%%%%%%%%%%% IF %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_print_if_statement(FL_THEN(Cond,Action)) :-
	!,
	print_item('IF ('),
	flora_write_goal(Cond),
	write_if_body(Action).
flora_print_if_statement(_) :-
	abort('Ill-formed IF statement').

write_if_body(FL_ELSE(Then,Else)) :-
	!,
	print_item(') THEN ('),
	flora_write_goal(Then),
	print_item(') ELSE ('),
	flora_write_goal(Else),
	print_item(')').
write_if_body(Then) :-
	print_item(') THEN ('),
	flora_write_goal(Then),
	print_item(')').

%%%%%%%%%%%%%%%%%%%%%% UNLESS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_print_unless(Cond,Action) :-
	print_item('UNLESS ('),
	flora_write_goal(Cond),
	print_items((') ', 'DO', ' (')),
	flora_write_goal(Action),
	print_item(')').


%%%%%%%%%%%%%%%%%%%%%% WHILE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_print_while(LoopType,Cond,Action) :-
	print_item('WHILE ('),
	flora_write_goal(Cond),
	print_items((') ', LoopType, ' (')),
	flora_write_goal(Action),
	print_item(')').

%%%%%%%%%%%%%%%%%%%%%% UNTIL %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_print_until(LoopType,Action,Cond) :-
	print_items((LoopType, ' (')),
	flora_write_goal(Action),
	print_item(') UNTIL ( '),
	flora_write_goal(Cond),
	print_item(')').


%%%%%%%%%%%%%%%%%%%%% Updates %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

is_update_call(FLLIBINSERT, FL_INSERT).
is_update_call(FLLIBINSERTALL, FL_INSERTALL).
is_update_call(FLLIBBTINSERT, FL_BTINSERT).
is_update_call(FLLIBBTINSERTALL, FL_BTINSERTALL).
is_update_call(FLLIBDELETE, FL_DELETE).
is_update_call(FLLIBDELETEALL, FL_DELETEALL).
is_update_call(FLLIBBTDELETE, FL_BTDELETE).
is_update_call(FLLIBBTDELETEALL, FL_BTDELETEALL).
is_update_call(FLLIBERASE, FL_ERASE).
is_update_call(FLLIBERASEALL, FL_ERASEALL).
is_update_call(FLLIBBTERASE, FL_BTERASE).
is_update_call(FLLIBBTERASEALL, FL_BTERASEALL).

flora_write_update(UpdName,UpdLiterals) :-
	print_items((UpdName,'{')),
	write_update_literals(UpdLiterals),
	print_item('}').
flora_write_update(UpdName,UpdLiterals,Query) :-
	print_items((UpdName,'{')),
	write_update_literals(UpdLiterals),
	print_item(' | '),
	flora_write_goal(Query),
	print_item('}').
write_update_literals([]).
write_update_literals([L|Rest]) :-
	L = FLSYSDBUPDATE(Literal,_Storage),
	flora_write_goal(Literal),
	(Rest \== [] -> print_item(','); true),
	write_update_literals(Rest).


%%%%%%%%%%%%%%%%%%%%% Aggregate Ops %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/*
flora_write_aggregate(AggrName,AggrVar,GroupVarList,
			      Query,AggrResultVar,ComparisonCall) :- 
	ComparisonCall =.. [Comparison,ComparisonVar,AggrResultVar],
	print_items((ComparisonVar,Comparison,AggrName,'{',
		     AggrVar,GroupVarList,' | ')),
	flora_write_goal(Query),
	print_item('}').
*/
flora_write_aggregate(AggrName,AggrVar,GroupVarList,Query,AggrResult) :- 
	write_hilog(AggrResult),
	print_items((' = ',AggrName,'{',AggrVar,GroupVarList,' | ')),
	flora_write_goal(Query),
	print_item('}').

is_aggregate_call(FLLIBMIN,FL_MIN).
is_aggregate_call(FLLIBMAX,FL_MAX).
is_aggregate_call(FLLIBSUM,FL_SUM).
is_aggregate_call(FLLIBAVG,FL_AVG).
is_aggregate_call(FLLIBCOUNT,FL_COUNT).
is_aggregate_call(FLLIBCOLLECTSET,FL_COLLECTSET).
is_aggregate_call(FLLIBCOLLECTBAG,FL_COLLECTBAG).


%%%%%%%%%%%%%%%%%%%%%% Classifier %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
classify_call(Call, Type,Basename,ArgList,Workspace) :-
	flora_decode_predicate(Call,Type1,Workspace,Prefix,Basename1,ArgList1),
	%% The following is a debugging statement, 
	%% to help weed out calls that should be suppressed
	%%format('~n~w~n~w~n~w~n~w~n~w~n~w~n',
	%%	  [Call,Type1,Workspace,Prefix,Basename1,ArgList]),
	(Type1 == (flora)
	-> ((Prefix=immediate_ ; Prefix=inheritance_)
	   -> Basename = Basename1, Type = (inheritance), ArgList = ArgList1
	   
	   ; Prefix=super_
	   -> Basename = Basename1, Type = (flogic), ArgList = ArgList1

	   ; Prefix=defined_inferred_
	   -> Basename = Basename1, Type = (definedvalue), ArgList = ArgList1

	   ; Prefix=conflict_obj_
	   -> Type = (conflictvalue),
	       ( Basename1 == ifd -> Basename = WRAP_FD
	       ; Basename1 == imvd -> Basename = WRAP_MVD
	       ; Basename = Basename1
	       ),
	       ArgList = ArgList1
	   ;   %% must be a hilog predicate derivative formed by specialization
	       %% such as FLORA_PREFIX'usermod''main''flapply_#303'
	       str_cat(WRAP_HILOG,'_',Prefix)
	   ->  Type = (hilog), ArgList1 = [Basename | ArgList]
	   ; Type = Type1, Basename = Basename1, ArgList = ArgList1
	   )
	; Type = Type1, Basename = Basename1, ArgList = ArgList1
	).

%%%%%%%%%%%%%%%%%%%%% Write Utils %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

write_value(Val) :-
	atomic(Val),
	!,
	print_item(Val).
write_value(Val) :-
	is_charlist(Val),
	!,
	flora_write_dbg_item('"~w"', [Val]).
write_value(Val) :- var(Val), !, print_item( Val).
write_value(=(_N,Var)) :- !, print_item( Var).
write_value(WRAP_FDSKOLEM(X,Y)) :- !,
	write_value(X), print_item('.'), write_value(Y).
write_value(WRAP_IFDSKOLEM(X,Y)) :- !,
	write_value(X), print_item('!'), write_value(Y).
write_value(Val) :-
	is_flogic(Val),
	!,
	flora_write_goal(Val).
write_value(Val) :-
	is_commalist(Val),
	!,
	write_goal_commalist(Val).
write_value(Val) :-
	is_list_term(Val),
	!,
	write_goal_list(Val).
write_value(Val) :-
	is_disjunction(Val),
	!,
	write_disjunction(Val).
write_value(Val) :-
	is_hilog(Val),
	!,
	write_hilog(Val).
write_value(Val) :-
	is_prolog(Val),
	!,
	print_item(Val).

write_hilog(Val) :-
	(atomic(Val);var(Val)),
	!,
	(atom(Val), flora_decode_predicate(Val,_,WS,_,Basename,_),
	    nonvar(WS), nonvar(Basename)
	->  print_item(Basename) ,write_workspace(WS)
	;   print_item(Val)
	).

write_hilog(FLLIBMODLIT(Wrap,Args,Module)) :- !,
	flora_write_goal(FLLIBMODLIT(Wrap,Args,Module)).

write_hilog(Val) :-
	is_commalist(Val),
	!,
	write_goal_commalist(Val).
write_hilog(Val) :-
	is_list_term(Val),
	!,
	print_item('['),
	write_hilog_args(Val),
	print_item(']').
write_hilog(Val) :-
	is_disjunction(Val),
	!,
	write_disjunction(Val).
write_hilog(Val) :-
	is_flogic(Val),
	!,
	flora_write_goal(Val).
write_hilog(Val) :-
	(\+callable(Val) -> abort(('Ill-formed HiLog term,', Val))
	;
	    %% check if there is a workspace
	    (flora_decode_predicate(Val,_,WS,_,_,_), ! ; true),
	    Val =.. [Funct,Head|Args],
	    (str_sub(WRAP_HILOG,Funct)
	    -> write_hilog(Head),
		(Args == [], !
		;
		    print_item( '('),
		    write_hilog_args(Args),
		    print_item( ')')
		),
		(nonvar(WS) -> write_workspace(WS); true)
	    ; % Not a hilog term
		write_value(Val)
	    )
	).

write_hilog_args([]) :- true.
write_hilog_args([Arg]) :- !, write_hilog(Arg).
write_hilog_args([Arg|Rest]) :-
	!,
	write_hilog(Arg),
	print_item(','),
	write_hilog_args(Rest).


write_workspace(WS) :-
	(WS==main -> true
	;
	    flora_write_dbg_item('@~w',[WS])
	).


/*
%% Extracts and writes variables from the list [=(name,internalVar), ...]
%% or from the list [internalVar, internalVar, ...]
flora_write_vars(V) :- V== [], !.
flora_write_vars([V|Rest]) :- 
	var(V), !, flora_write_vars(V,Rest).
flora_write_vars([=(_N,V)|Rest]) :- 
    	!, flora_write_vars(V,Rest).

flora_write_vars(V,Rest) :-
	print_item(V),
	(Rest == [] -> true
	 ; print_item(','), flora_write_vars(Rest)
	).
*/

print_item(Item) :- flora_write_dbg_item(Item).
print_items(','(Item,Rest)) :-
	!,
	print_item(Item),
	print_items(Rest).
print_items(Item) :- print_item(Item).

/*********************************************************************/

flora_trace :-
	assert(flora_switch(trace)),
	flora_handle_trace.
flora_notrace :-
	retractall(flora_switch(trace)),
	flora_handle_notrace.
/*********************************************************************/

flora_debug_dyndata_file(Filename) :-
	package_configuration(dir(flora), FlrSysLib),
	flora_slash(S),
	flora_concat_atoms([FlrSysLib,S,debugger,S,'dynamic_data.dat'],
			   Filename).
flora_debug_statdata_file(Filename) :-
	package_configuration(dir(flora), FlrSysLib),
	flora_slash(S),
	flora_concat_atoms([FlrSysLib,S,debugger,S,'static_data.dat'],
			   Filename).

%% If WS is a var -- loading static data
%% Otherwise, loading dynamic data for the specified module
flora_read_debugger_data(WS,_Datafile) :-
	%% Check if already loaded
	(var(WS) 
	-> current_predicate(FLORA_SYMBOL('debugger_static_data_loaded')/0)
	; flora_firstorder_module_predicate_symbol(debugger_data_loaded,
						   WS,
						   WSSym),
	    current_predicate(WSSym/0)
	),
	!.
flora_read_debugger_data(WS,Datafile) :- 
	(var(WS)
	-> flora_set_xpp_options_for_read
	; flora_set_xpp_options_for_read(WS)
	),
	xpp_process_file(Datafile, CPP_process, IOportFromCPP),
	repeat,
	    file_read(IOportFromCPP,T),
	    (T = end_of_file -> true
	    	    	     ;  assert(T), fail
	    ),
	process_control(CPP_process, wait(ExitStatus)),
	(ExitStatus==0, !
	; abort(('[Debugger] Error while preprocessing ', Datafile))
	),
	flora_clear_xpp_options,
	file_close(IOportFromCPP),
	flora_set_counter(xpp_on,0),
	(var(WS)
	->  flora_message_line('Static debugger data loaded')
	;   flora_message_line('Dynamic debugger data loaded for module ~w',
			       WS)
	),
	!.


%% Read dynamic data for preloaded user modules
flora_load_dyndata_for_user_modules([]).
flora_load_dyndata_for_user_modules([M|List]) :-
	flora_debug_dyndata_file(DataFile),
	flora_read_debugger_data(M,DataFile),
	flora_load_dyndata_for_user_modules(List).

flora_load_statdata :-
	flora_debug_statdata_file(DataFile),
	flora_read_debugger_data(_M,DataFile).

%% The bridge is disabled during low level tracing
flora_build_bridge_to_xsb_debugger :-
	assert((hide_this_hide(X,Y) :-
	       \+flora_switch(low_level_trace),flora_hide_this_hide(X/Y))),
	assert((hide_this_show(X,Y) :-
	       \+flora_switch(low_level_trace),flora_hide_this_show(X/Y))),
	assert((show_this_hide(X,Y) :-
	       \+flora_switch(low_level_trace),flora_show_this_hide(X/Y))),
	assert((trace_this_noprint(X,Y) :-
	       \+flora_switch(low_level_trace),flora_trace_this_noprint(X/Y))),
	assert((trace_this_print(X,Y) :-
	       \+flora_switch(low_level_trace),flora_trace_this_print(X/Y))),
	%% Rule to handle system modules.
	%% This prevents tracing inside flora system modules.
	%% We might add a switch that would enable this optionally.
	%% Not clear if this useful.
	assert((show_this_hide(X,Y) :-
	       \+flora_switch(low_level_trace),
		flora_decode_predicate(X,_,WS,_,_,_),
		flora_module_name(WS,systemmodule,_)
	       )),
	%% Rules for prefixes of predicates that need 
	%% to be handled by the debugger
	assert((hide_this_hide(X,Y) :-
	       \+flora_switch(low_level_trace),
		flora_hide_this_hide(pref(X1/Y)),
		str_sub(X1,X,0)
	       )),
	assert((hide_this_show(X,Y) :-
	       \+flora_switch(low_level_trace),
		flora_hide_this_show(pref(X1/Y)),
		str_sub(X1,X,0)
	       )),
	assert((show_this_hide(X,Y) :-
	       \+flora_switch(low_level_trace),
		flora_show_this_hide(pref(X1/Y)),
		str_sub(X1,X,0)
	       )),
	assert((trace_this_noprint(X,Y) :-
	       \+flora_switch(low_level_trace),
		flora_trace_this_noprint(pref(X1/Y)),
		str_sub(X1,X,0)
	       )),
	assert((trace_this_print(X,Y) :-
	       \+flora_switch(low_level_trace),
		flora_trace_this_print(pref(X1/Y)),
		str_sub(X1,X,0)
	       )).

?- findall(X,flLoadedModule(X),L),
   flora_load_statdata,
   flora_load_dyndata_for_user_modules(L).

?- flora_build_bridge_to_xsb_debugger.

FLORA_SYMBOL('debugger_loaded').

