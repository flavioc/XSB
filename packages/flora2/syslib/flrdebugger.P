/* File:        flrdebugger.P  -- Flora debugger
**
** Author(s): Michael Kifer
** Contact:   xsb-contact@cs.sunysb.edu
**
** Copyright (C) The Research Foundation of SUNY, 2001
**
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
** 
** $Id$
** 
*/

:- compiler_options([xpp_on]).
#include "standard.h"

#include "flrheader.flh"



:- import trie_assert/1, trie_retract_all/1 from tables.
:- import fmt_write/3, file_open/3, file_close/1 from file_io.
:- import file_write/2 from xsb_writ.
:- import debug_display_call_hook/1, flora_switch/1 from usermod.
:- import flora_classify_call/5 from flrwrapper.

:- dynamic debug_display_call_hook/1.
:- dynamic flora_switch/1.
:- dynamic flora_debug_context/1.


:- assert(debug_display_call_hook(flora_write_debug_goal_top)).

flora_write_debug_goal_top(Call) :-
	flora_classify_call(Call, Type,Basename,ArgList,Workspace),
	(Type == prolog -> file_write(Call)
	; Type == florapred
	-> flora_print_florapred(Basename,ArgList,Workspace)
	; Type == hilog
	-> flora_print_hilog(Basename,ArgList,Workspace)
	; Type == flogic
	-> flora_print_flogic(Basename,ArgList,Workspace)
	; abort(['[FLORA debugger]: Something wrong. Unrecognized call type',
		 Type])
	).

	

flora_print_flogic(WRAP_ISA,[X,Y],Workspace) :-
	!, flora_print_isa(X,Y,Workspace).
flora_print_flogic(WRAP_SUB,[X,Y],Workspace) :-
	!, flora_print_sub(X,Y,Workspace).
flora_print_flogic(WRAP_FD,[O, M, V],Workspace) :-
	!, flora_print_fd(O,M,V,Workspace).
flora_print_flogic(WRAP_IFD,[O, M, V],Workspace) :-
	!, flora_print_ifd(O,M,V,Workspace).
flora_print_flogic(WRAP_FDSIG,[O, M, V],Workspace) :-
	!, flora_print_fdsig(O,M,V,Workspace).
flora_print_flogic(WRAP_IFDSIG,[O, M, V],Workspace) :-
	!, flora_print_ifdsig(O,M,V,Workspace).
flora_print_flogic(WRAP_MVD,[O, M, V],Workspace) :-
	!, flora_print_mvd(O,M,V,Workspace).
flora_print_flogic(WRAP_IMVD,[O, M, V],Workspace) :-
	!, flora_print_imvd(O,M,V,Workspace).
flora_print_flogic(WRAP_MVDSIG,[O, M, V],Workspace) :-
	!, flora_print_mvdsig(O,M,V,Workspace).
flora_print_flogic(WRAP_IMVDSIG,[O, M, V],Workspace) :-
	!, flora_print_imvdsig(O,M,V,Workspace).

flora_print_flogic(FL_INSERT,L) :-
	!, flora_print_insert(L).
flora_print_flogic(FL_INSERTALL,L) :-
	!, flora_print_insertall(L).
flora_print_flogic(FL_DELETE,L) :-
	!, flora_print_delete(L).
flora_print_flogic(FL_DELETEALL,L) :-
	!, flora_print_deleteall(L).
flora_print_flogic(FL_ERASE,L) :-
	!, flora_print_erase(L).
flora_print_flogic(FL_ERASEALL,L) :-
	!, flora_print_eraseall(L).

flora_print_flogic(FL_BTINSERT,L) :-
	!, flora_print_btinsert(L).
flora_print_flogic(FL_BTINSERTALL,L) :-
	!, flora_print_btinsertall(L).
flora_print_flogic(FL_BTDELETE,L) :-
	!, flora_print_btdelete(L).
flora_print_flogic(FL_BTDELETEALL,L) :-
	!, flora_print_btdeleteall(L).
flora_print_flogic(FL_BTERASE,L) :-
	!, flora_print_bterase(L).
flora_print_flogic(FL_BTERASEALL,L) :-
	!, flora_print_bteraseall(L).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Findall-related calls
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Problem:
%% Currently, the debugger displays some goals, such as =(_,_), which 
%% flora compiler places as part of the translation, as in the following 
%% example:
%%
%%  ?- L = collectset{X; X[Y->Z]}.
%%  ?- '_$_$_flora_print_all'(','(findall(_h4610,'_$_$_flora_fd_rhs'(_h4610,'_$_$_flora_@'(_h4649),_h4761),_h4957),
%%     	       	       ','('_$_$_flora_collectset'(nogrp,_h4957,_h4970),
%%     	       	       =(_h4589,_h4970))),
%%     	       	       '.'(var('L',_h4589),
%%     	       	       '.'(var('X',_h4610),
%%     	       	       '.'(var('Y',_h4649),
%%     	       	       '.'(var('Z',_h4761),[]))))).
%% The problem here is =(_h4589,_h4970) which is going to be executed after
%% '_$_$_flora_collectset'. '_$_$_flora_collectset' itself is hidden, 
%% but "=" is not (and should not). We can''t just avoid printing it, 
%% because it is activated with call_c, which always enables printing.

%% flora_print_all
flora_write_debug_goal(findall(X,Gs,_Res)) :-
	is_list(X),
	X = [var(_,_)|_],
	!,
	file_write(STDDBG, 'Query: { '),
	flora_write_vars(X),
	file_write(STDDBG, ' | '),
	flora_write_debug_goal(Gs),
	file_write(STDDBG, ' }').

%% Aggregates in the rule body, but not query.
%% Can''t determine the context. We need to change translation 
%% from Flora into prolog to be able to determine the context.
%% For instance, here is a translation that is handled by this case:
%%
%% flora_pp_write_body_set(Obj) :- 
%%     	   MethLst1 = collectset{ML ; Obj[@M ->> _], @M =.. ML},
%%    	   sort(MethLst1, MethLst2),
%%    	   flora_pp_write_body_set1(Obj, MethLst2).
%%
%% flora_pp_write_body_set(_h15703) :- 
%%        findall(_h15750,','('_$_$_flora_mvd_rhs'(_h15703,_h15789,_h15869),
%%    	      	      	    =..(_h15789,'.'('_$_$_flora_@',_h15750))),_h16267),
%%    	  '_$_$_flora_collectset'(nogrp,_h16267,_h16280),
%%        =(_h15729,_h16280),
%%        sort(_h15729,_h15951),
%%        flora_pp_write_body_set1(_h15703,_h15951).
%%
flora_write_debug_goal(findall(X,Gs,_Res)) :-
	nonvar(Gs),
	Gs =.. [',' , FirstGoal | _GoalList],
	FirstGoal =.. [F|_],
	str_sub(STD_FPREFIX, F),
	!,
	%% We don''t know which aggregate and whether there is grouping
	fmt_write(STDDBG, 'Var = aggregate{%S; ', arg(X)),
	flora_write_debug_goal(Gs),
	file_write(STDDBG, ' }').

%% ','(Goal1,Goal2, ...). This comes from flora_print_all
flora_write_debug_goal(Call) :- 
	nonvar(Call),
	Call =.. [',' | GoalList],
	GoalList = [Call1 | Rest],
	flora_debug_get_context(Rest,Context),
	!,
	%% Context=none means list of independent goals
	(Context == none -> flora_write_debug_goal(GoalList, none)
	    	    	 ; flora_write_debug_goal(Call1, Context)
	).


%% aggregates -- they come with "context" obtained from ','(Goal1,Goal2, ...)
flora_write_debug_goal(Call) :- 
	functor(Call, findall, 3),
	flora_debug_context(Context),
	!,
	flora_write_debug_goal(Call, Context).


/*********************************************************************/
%% Catch-all cases

flora_write_debug_goal(Call) :- file_write(STDDBG, Call).

/*********************************************************************/
%% Context-sensitive flora_write_debug_goal''s

%% This handles aggregates
flora_write_debug_goal(findall(AggrResult,Goal,_Result),
		       Context) :-
	(var(AggrResult) -> AggrResult = CollectVar % no grouping vars
	%% Grouping vars present
	 ;  AggrResult = flora_rslt(CollectVar,Grp),
	    Grp =.. [flora_grp | GrpVars]
	),
	!, 
	(Context == collectset
    	-> file_write(STDDBG, 'Set = collectset{ ')
    	;  true),
	(Context == collectbag
    	-> file_write(STDDBG, 'Set = collectbag{ ')
    	;  true),
	(Context == min -> file_write(STDDBG, 'Res = min{ ') ;  true),
	(Context == max -> file_write(STDDBG, 'Res = max{ ') ;  true),
	(Context == avg -> file_write(STDDBG, 'Res = avg{ ') ;  true),
	(Context == sum -> file_write(STDDBG, 'Res = sum{ ') ;  true),
	file_write(STDDBG, CollectVar),
	(is_list(GrpVars) ->  % there are grouping vars
	    file_write(STDDBG, '['),
	    flora_write_vars(GrpVars),
	    file_write(STDDBG, ']; ')
	 ; file_write(STDDBG, '; ')  % no grouping
	),
	flora_write_debug_goal(Goal),
	file_write(STDDBG, ' }').

%% None of the above contexts: assume a list of independent goals
flora_write_debug_goal(Goals, none) :-
	!,
	flora_write_debug_goallist(Goals).
flora_write_debug_goallist(G) :- G == [], !.
flora_write_debug_goallist([G|Gs]) :-
	flora_write_debug_goal(G),
	!,
	(Gs == [] ; file_write(STDDBG, ', ')),
	flora_write_debug_goallist(Gs).

%% Extract context out of the list of secondary goals
flora_debug_get_context([SecondaryGoals | _], Context) :-
    	(SecondaryGoals =.. [',' | Goals],
	    flora_debug_get_context1(Goals, Context) -> true
	    ; Context = none
	),
	!,
	retractall(flora_debug_context(_)),
	assert(flora_debug_context(Context)).

%% Fails if not context found
flora_debug_get_context1(GoalList, Context) :-
    	nonvar(GoalList),
    	GoalList = [Goal | Rest],
	(flora_check_goal_for_context(Goal, Context)
	->  true
	;   flora_debug_get_context1(Rest, Context)
	).
	 
%% Fails, if no context found
flora_check_goal_for_context(Goal, Context) :-
    	(nonvar(Goal),
	 Goal =.. [ContextPred | _Rest1] % determines the type of aggregate
	 ; fail
	),
	(ContextPred == STD_FPREFIX(collectset) 
	->  Context = collectset
	;   true),
	(ContextPred == STD_FPREFIX(collectbag) 
	->  Context = collectbag
	;   true),
	(ContextPred == STD_FPREFIX(min) 
	->  Context = min
	;   true),
	(ContextPred == STD_FPREFIX(max) 
	->  Context = max
	;   true),
	(ContextPred == STD_FPREFIX(avg) 
	->  Context = avg
	;   true),
	(ContextPred == STD_FPREFIX(sum) 
	->  Context = sum
	;   true).

/*********************************************************************/

flora_print_isa(X,Y) :- 
	flora_debug_write_value(X),
	file_write(STDDBG, ' : '),
	flora_debug_write_value(Y).
flora_print_sub(X,Y) :-
	flora_debug_write_value(X),
	file_write(STDDBG, ' :: '),
	flora_debug_write_value(Y).

flora_print_fd(O,M,V) :-
	flora_debug_write_value(O),
	file_write(STDDBG, '['),
	flora_debug_write_method_invocation(M),
	file_write(STDDBG, ' -> '),
	flora_debug_write_value(V),
	file_write(STDDBG, ']').
flora_print_mvd(O,M,V) :-
	flora_debug_write_value(O),
	file_write(STDDBG, '['),
	flora_debug_write_method_invocation(M),
	file_write(STDDBG, ' ->> '),
	flora_debug_write_value(V),
	file_write(STDDBG, ']').

flora_print_assert(L) :- file_write(STDDBG, 'assert('), flora_print_assert1(L).
flora_print_assert1([]) :- !, file_write(STDDBG, ')').
flora_print_assert1([A | R]) :-
	( A = VAR_FPREFIX(isa)(X,Y) ->
	    flora_print_isa(X,Y)
	; A = VAR_FPREFIX(sub)(X,Y) ->
	    flora_print_sub(X,Y)
	; A = VAR_FPREFIX(fd)(O,M,V) ->
	    flora_print_fd(O,M,V)
	; A = VAR_FPREFIX(mvd)(O,M,V) ->
	    flora_print_mvd(O,M,V)
	),
	(R == [] ; file_write(STDDBG, ', ')),
	flora_print_assert1(R).

flora_print_retract(L,Cond) :-
	file_write(STDDBG, 'retract('), flora_print_retract1(L,Cond).
flora_print_retractall(L,C) :-
	file_write(STDDBG, 'retractall('), flora_print_retract1(L,C).
flora_print_erase(L,Cond) :-
	file_write(STDDBG, 'erase('), flora_print_retract1(L,Cond).

flora_print_retract1([],[]) :- !, file_write(STDDBG, ')').
%% Need to do a better job printing L
flora_print_retract1([],Cond) :- !, fmt_write(STDDBG, '| %S )', arg(Cond)).
flora_print_retract1([A | R],Cond) :-
	flora_print_retract_molecule(A),
	(R == [], !
	 ;   file_write(STDDBG, ', ')
	),
	flora_print_retract1(R,Cond).

flora_print_retract_molecule(flora_rtrct(A)) :-
	( A = VAR_FPREFIX(isa)(X,Y) ->
	    flora_print_isa(X,Y)
	; A = VAR_FPREFIX(sub)(X,Y) ->
	    flora_print_sub(X,Y)
	; A = VAR_FPREFIX(fd)(O,M,V) ->
	    flora_print_fd(O,M,V)
	; A = VAR_FPREFIX(mvd)(O,M,V) ->
	    flora_print_mvd(O,M,V)
	).

%% Case of meta variable @M =.. L or meth@(....) =.. L
flora_print_univ(V,L) :-
	nonvar(L),
	L = [H|L1],
	H == 'flora_@',
	!,
	(var(V) -> file_write(STDDBG, '@'), file_write(STDDBG, V)
	 ; V =.. [_Junk|MethodInvoc], 
	    flora_debug_write_method_invocation(MethodInvoc)
	),
	file_write(STDDBG, ' =.. '),
	flora_debug_write_value(L1),
	!.
flora_print_univ(V,L) :-
	flora_debug_write_value(V),
	file_write(STDDBG, ' =.. '),
	flora_debug_write_value(L),
	!.
	

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

flora_debug_write_value(Val) :-
	atom(Val),
	!,
	fmt_write(STDDBG, '''%s''', arg(Val)).
flora_debug_write_value(Val) :-
	is_charlist(Val),
	!,
	fmt_write(STDDBG, '"%s"', arg(Val)).
flora_debug_write_value(Val) :- var(Val), !, file_write(STDDBG, Val).
flora_debug_write_value(var(_N,Var)) :- !, file_write(STDDBG, Var).
flora_debug_write_value(Val) :- file_write(STDDBG, Val).

flora_debug_write_method_invocation(X) :-
	var(X), !, file_write(STDDBG, X).
flora_debug_write_method_invocation(X) :- X==[], !.
flora_debug_write_method_invocation(X) :-
    	nonvar(X), X = [Attr], !,
    	flora_debug_write_value(Attr).
flora_debug_write_method_invocation(X) :-
    	nonvar(X), X = [M, Arg |Args], !,
    	flora_debug_write_value(M),
	file_write(STDDBG, '@('),
	flora_debug_write_value(Arg),
	flora_write_vars(Args),
	file_write(STDDBG, ')').
flora_debug_write_method_invocation(M) :-
    	nonvar(M), M =.. [_Junk | MethArgs], !,
	flora_debug_write_method_invocation(MethArgs).


%% Extracts and writes variables from the list [var(name,internalVar), ...]
%% or from the list [internalVar, internalVar, ...]
flora_write_vars(V) :- V== [], !.
flora_write_vars([V|Rest]) :- 
	var(V), !, flora_write_vars(V,Rest).
flora_write_vars([var(_N,V)|Rest]) :- 
    	!, flora_write_vars(V,Rest).

flora_write_vars(V,Rest) :-
	file_write(STDDBG, V),
	(Rest == [] -> true
	 ; file_write(STDDBG, ','), flora_write_vars(Rest)
	).


/*********************************************************************/

flora_trace :-
	assert(flora_switch(trace)),
	retract(flora_switch(low_level_trace)),
	flora_handle_trace.
flora_notrace :-
	retract_all(flora_switch(trace)),
	retract_all(flora_switch(low_level_trace)),
	flora_handle_notrace.

