/* File:      flrdependency.P  -- the dependency checker
**
** Author(s): Chang Zhao
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) The Research Foundation of SUNY, 2002
** 
** FLORA-2 is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** FLORA-2 is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with FLORA-2; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id$
**
*/


%%%% Check dependency of tabled predicates on updates or procedural methods.
%%%% Such dependency is considered a likely error and warning is issued.
%%%%
%%%% Usage: check_for_dependencies(+CodeList,-ErrWarnList)
%%%%        generate_rules(+CodeList)
%%%%        depend(+Sk1,+Sk2,+Option).

:- compiler_options([xpp_on]).
#include "flora_terms.flh"
#include "flora_errors.flh"
#include "flora_characters.flh"

:- table rec_depend/6.
:- use_subsumptive_tabling rec_depend(_,_,_,_,_,_).

#define MAXDEPTH	3
#define STARTPOINT	1
#define DEFAULT_WORKSPACE   '_@'

#mode save
#mode nostring "\!#'"
#define PREFIXING(X)            PREFIXINGWS(#1,DEFAULT_WORKSPACE)
#define PREFIXINGWS(X,Y)        FLORA_USER_MODULE_PREFIX#2'#1'
#mode restore

#define PREFIXED_WRAP_ISA       PREFIXING(WRAP_ISA)
#define PREFIXED_WRAP_SUB       PREFIXING(WRAP_SUB)
#define PREFIXED_WRAP_FD        PREFIXING(WRAP_FD)
#define PREFIXED_WRAP_IFD       PREFIXING(WRAP_IFD)
#define PREFIXED_WRAP_METH      PREFIXING(WRAP_METH)
#define PREFIXED_WRAP_IMETH     PREFIXING(WRAP_IMETH)
#define PREFIXED_WRAP_FDSIG     PREFIXING(WRAP_FDSIG)
#define PREFIXED_WRAP_MVDSIG    PREFIXING(WRAP_MVDSIG)
#define PREFIXED_WRAP_IFDSIG    PREFIXING(WRAP_IFDSIG)
#define PREFIXED_WRAP_IMVDSIG   PREFIXING(WRAP_IMVDSIG)
#define PREFIXED_WRAP_MVD       PREFIXING(WRAP_MVD)
#define PREFIXED_WRAP_IMVD      PREFIXING(WRAP_IMVD)
#define PREFIXED_WRAP_EXISTS    PREFIXING(WRAP_EXISTS)
#define PREFIXED_WRAP_FDDEF     PREFIXING(WRAP_FDDEF)
#define PREFIXED_WRAP_IFDDEF    PREFIXING(WRAP_IFDDEF)
#define PREFIXED_WRAP_MVDDEF    PREFIXING(WRAP_MVDDEF)
#define PREFIXED_WRAP_IMVDDEF   PREFIXING(WRAP_IMVDDEF)
#define PREFIXED_WRAP_OBJEQL    PREFIXING(WRAP_OBJEQL)
#define PREFIXED_WRAP_TRAN      PREFIXING(WRAP_TRAN)

#define PREFIXED_WRAP_HILOG           PREFIXING(WRAP_HILOG)
#define PREFIXED_WRAP_TABLED_HILOG     PREFIXING(WRAP_TABLED_HILOG)

/****************************************************************************
  utilities
 ****************************************************************************/
default_tabled(PREFIXED_WRAP_ISA,3).
default_tabled(PREFIXED_WRAP_SUB,3).
default_tabled(PREFIXED_WRAP_FD,4).
default_tabled(PREFIXED_WRAP_IFD,4).
default_tabled(PREFIXED_WRAP_METH,3).
default_tabled(PREFIXED_WRAP_IMETH,3).
default_tabled(PREFIXED_WRAP_FDSIG,4).
default_tabled(PREFIXED_WRAP_MVDSIG,4).
default_tabled(PREFIXED_WRAP_IFDSIG,4).
default_tabled(PREFIXED_WRAP_IMVDSIG,4).
default_tabled(PREFIXED_WRAP_MVD,4).
default_tabled(PREFIXED_WRAP_IMVD,4).
default_tabled(PREFIXED_WRAP_EXISTS,2).
default_tabled(PREFIXED_WRAP_FDDEF,3).
default_tabled(PREFIXED_WRAP_IFDDEF,3).
default_tabled(PREFIXED_WRAP_MVDDEF,3).
default_tabled(PREFIXED_WRAP_IMVDDEF,3).
default_tabled(PREFIXED_WRAP_OBJEQL,3).

default_tabled(PREFIXED_WRAP_TABLED_HILOG,2).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,3).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,4).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,5).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,6).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,7).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,8).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,9).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,10).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,11).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,12).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,13).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,14).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,15).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,16).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,17).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,18).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,19).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,20).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,21).
default_tabled(PREFIXED_WRAP_TABLED_HILOG,22).

procedural(WRAP_TRAN,3).
procedural(WRAP_HILOG,1).
procedural(WRAP_HILOG,2).
procedural(WRAP_HILOG,3).
procedural(WRAP_HILOG,4).
procedural(WRAP_HILOG,5).
procedural(WRAP_HILOG,6).
procedural(WRAP_HILOG,7).
procedural(WRAP_HILOG,8).
procedural(WRAP_HILOG,9).
procedural(WRAP_HILOG,10).
procedural(WRAP_HILOG,11).
procedural(WRAP_HILOG,12).
procedural(WRAP_HILOG,13).
procedural(WRAP_HILOG,14).
procedural(WRAP_HILOG,15).
procedural(WRAP_HILOG,16).
procedural(WRAP_HILOG,17).
procedural(WRAP_HILOG,18).
procedural(WRAP_HILOG,19).
procedural(WRAP_HILOG,20).
procedural(WRAP_HILOG,21).

dboperation(FLLIBINSERT,1).
dboperation(FLLIBINSERTALL,1).
dboperation(FLLIBBTINSERT,1).
dboperation(FLLIBBTINSERTALL,1).
dboperation(FLLIBDELETE,1).
dboperation(FLLIBDELETEALL,1).
dboperation(FLLIBBTDELETE,1).
dboperation(FLLIBBTDELETEALL,1).
dboperation(FLLIBERASE,1).
dboperation(FLLIBERASEALL,1).
dboperation(FLLIBBTERASE,1).
dboperation(FLLIBBTERASEALL,1).

dboperation(FLLIBINSERT,2).
dboperation(FLLIBINSERTALL,2).
dboperation(FLLIBBTINSERT,2).
dboperation(FLLIBBTINSERTALL,2).
dboperation(FLLIBDELETE,2).
dboperation(FLLIBDELETEALL,2).
dboperation(FLLIBBTDELETE,2).
dboperation(FLLIBBTDELETEALL,2).
dboperation(FLLIBERASE,2).
dboperation(FLLIBERASEALL,2).
dboperation(FLLIBBTERASE,2).
dboperation(FLLIBBTERASEALL,2).

dboperation(FLLIBINSERT,3).
dboperation(FLLIBINSERTALL,3).
dboperation(FLLIBBTINSERT,3).
dboperation(FLLIBBTINSERTALL,3).
dboperation(FLLIBDELETE,3).
dboperation(FLLIBDELETEALL,3).
dboperation(FLLIBBTDELETE,3).
dboperation(FLLIBBTDELETEALL,3).
dboperation(FLLIBERASE,3).
dboperation(FLLIBERASEALL,3).
dboperation(FLLIBBTERASE,3).
dboperation(FLLIBBTERASEALL,3).

is_upd(FLLIBINSERT(_ThisMod,List,Condition),insert,List,Condition) :- !.
is_upd(FLLIBBTINSERT(_ThisMod,List,Condition),btinsert,List,Condition) :- !.
is_upd(FLLIBDELETE(_ThisMod,List,Condition),delete,List,Condition) :- !.
is_upd(FLLIBBTDELETE(_ThisMod,List,Condition),btdelete,List,Condition) :- !.
is_upd(FLLIBERASE(_ThisMod,List,Condition),erase,List,Condition) :- !.
is_upd(FLLIBBTERASE(_ThisMod,List,Condition),bterase,List,Condition) :- !.
%%------------ Recognizes index structures associated with update ops
is_updIdxStruct(FLLIBINSERT(List,Condition),List,Condition) :- !.
is_updIdxStruct(FLLIBBTINSERT(List,Condition),List,Condition) :- !.
is_updIdxStruct(FLLIBDELETE(List,Condition),List,Condition) :- !.
is_updIdxStruct(FLLIBBTDELETE(List,Condition),List,Condition) :- !.
is_updIdxStruct(FLLIBERASE(List,Condition),List,Condition) :- !.
is_updIdxStruct(FLLIBBTERASE(List,Condition),List,Condition) :- !.

is_updall(FLLIBINSERTALL(_ThisMod,List,Condition),insertall,List,Condition) :- !.
is_updall(FLLIBBTINSERTALL(_ThisMod,List,Condition),btinsertall,List,Condition) :- !.
is_updall(FLLIBDELETEALL(_ThisMod,List,Condition),deleteall,List,Condition) :- !.
is_updall(FLLIBBTDELETEALL(_ThisMod,List,Condition),btdeleteall,List,Condition) :- !.
is_updall(FLLIBERASEALL(_ThisMod,List,Condition),eraseall,List,Condition) :- !.
is_updall(FLLIBBTERASEALL(_ThisMod,List,Condition),bteraseall,List,Condition) :- !.
%%---- Recognizes index structures associated with update ops
is_updallIdxStruct(FLLIBINSERTALL(List,Condition),List,Condition) :- !.
is_updallIdxStruct(FLLIBBTINSERTALL(List,Condition),List,Condition) :- !.
is_updallIdxStruct(FLLIBDELETEALL(List,Condition),List,Condition) :- !.
is_updallIdxStruct(FLLIBBTDELETEALL(List,Condition),List,Condition) :- !.
is_updallIdxStruct(FLLIBERASEALL(List,Condition),List,Condition) :- !.
is_updallIdxStruct(FLLIBBTERASEALL(List,Condition),List,Condition) :- !.

is_upd(FLLIBINSERT(_ThisMod,List),insert,List,_) :- !.
is_upd(FLLIBBTINSERT(_ThisMod,List),btinsert,List,_) :- !.
is_upd(FLLIBDELETE(_ThisMod,List),delete,List,_) :- !.
is_upd(FLLIBBTDELETE(_ThisMod,List),btdelete,List,_) :- !.
is_upd(FLLIBERASE(_ThisMod,List),erase,List,_) :- !.
is_upd(FLLIBBTERASE(_ThisMod,List),bterase,List,_) :- !.
%%---
is_updIdxStruct(FLLIBINSERT(List),List,_) :- !.
is_updIdxStruct(FLLIBBTINSERT(List),List,_) :- !.
is_updIdxStruct(FLLIBDELETE(List),List,_) :- !.
is_updIdxStruct(FLLIBBTDELETE(List),List,_) :- !.
is_updIdxStruct(FLLIBERASE(List),List,_) :- !.
is_updIdxStruct(FLLIBBTERASE(List),List,_) :- !.

is_updall(FLLIBINSERTALL(_ThisMod,List),insertall,List,_) :- !.
is_updall(FLLIBBTINSERTALL(_ThisMod,List),btinsertall,List,_) :- !.
is_updall(FLLIBDELETEALL(_ThisMod,List),deleteall,List,_) :- !.
is_updall(FLLIBBTDELETEALL(_ThisMod,List),btdeleteall,List,_) :- !.
is_updall(FLLIBERASEALL(_ThisMod,List),eraseall,List,_) :- !.
is_updall(FLLIBBTERASEALL(_ThisMod,List),bteraseall,List,_) :- !.
%%----
is_updallIdxStruct(FLLIBINSERTALL(List),List,_) :- !.
is_updallIdxStruct(FLLIBBTINSERTALL(List),List,_) :- !.
is_updallIdxStruct(FLLIBDELETEALL(List),List,_) :- !.
is_updallIdxStruct(FLLIBBTDELETEALL(List),List,_) :- !.
is_updallIdxStruct(FLLIBERASEALL(List),List,_) :- !.
is_updallIdxStruct(FLLIBBTERASEALL(List),List,_) :- !.

is_agg(FLLIBMIN(Var,Group,Cond,Result),min,Var,Group,Cond,Result) :- !.
is_agg(FLLIBMAX(Var,Group,Cond,Result),max,Var,Group,Cond,Result) :- !.
is_agg(FLLIBSUM(Var,Group,Cond,Result),sum,Var,Group,Cond,Result) :- !.
is_agg(FLLIBAVG(Var,Group,Cond,Result),avg,Var,Group,Cond,Result) :- !.
is_agg(FLLIBCOUNT(Var,Group,Cond,Result),count,Var,Group,Cond,Result) :- !.
is_agg(FLLIBCOLLECTSET(Var,Group,Cond,Result),collectset,Var,Group,Cond,Result)
	:- !.
is_agg(FLLIBCOLLECTBAG(Var,Group,Cond,Result),collectbag,Var,Group,Cond,Result)
	:- !.

is_control(FLLIBIFTHEN(If,Then),FLLIBIFTHEN,[If,Then]) :- !.
is_control(FLLIBIFTHENELSE(If,Then,Else),FLLIBIFTHENELSE,[If,Then,Else]) :- !.

is_constraint(PRCONSTRAINT(Constr),Constr).

/****************************************************************************
  cut_off(+Term_before_cutoff,-Term_after_cutoff)
  cut off a term whose depth is greater than MAXDEPTH
 ****************************************************************************/
cut_off(T1,T2) :- cut_off(T1,T2,1).

cut_off(T1,T2,N) :-
	( N>MAXDEPTH ->
	    writeln('Too deep'),
	    fail
	;
	    ( (atomic(T1); var(T1)) ->
	        T2=T1,
		!
            ;
	        ( N=MAXDEPTH ->
		    functor(T1,Func,Nargs),
		    functor(T2,Func,Nargs)
	        ;
		    NewN is N+1,
		    T1 =.. [Func|Args],
		    cut_off_list(Args,NewArgs,NewN),
		    T2 =.. [Func|NewArgs]
	        )
	    )
	).
		
cut_off_list([],[],_) :- !.
cut_off_list([H|T],[NewH|NewT],N) :-
	cut_off(H,NewH,N),
	cut_off_list(T,NewT,N).

/****************************************************************************
  depth(+Term,-Depth_of_the_term)
  compute the depth of a term
 ****************************************************************************/
depth(X,0) :- atomic(X), !.
depth(X,0) :- var(X), !.
depth(X,N1) :-
        !,
	X =.. [_F|Y],
	param_depth(Y,N),
	N1 is N+1.

/****************************************************************************
  param_depth(+ParamList,-MaxDepth)
  given a list of parameters, returns the max depth of all params
 ****************************************************************************/
param_depth([X],N) :- depth(X,N),!.
param_depth([H|T],N) :-
	depth(H,N1),
	param_depth(T,N2),
	( (N1>N2) ->
            N = N1
        ;
            N = N2
        ).

/****************************************************************************
  depend(+Sk1,+Sk2,-T1,-T2,+Option)
  possible options: u -- depends on update
                    a -- depends on aggregation
                    n -- depends negatively
                    p -- depends positively
    		    arb -- arbitrary
  check whether Sk1 depends on Sk2 with given option, T1 and T2 are
  instantiations of Sk1 and Sk2, respectively
 ****************************************************************************/
depend(Sk1,Sk2,T1,T2,Opt) :-
	retractall(dependency(_,_,_,_)),
	depend(Sk1,Sk2),
	dependency((T1,_IT1),(T2,_IT2),anu(A,N,U),_),
	( (Opt=u, atom(U))
	; (Opt=a, atom(A))
	; (Opt=n, atom(N))
	; (Opt=p, var(N))
	; (Opt=arb)
	).

/****************************************************************************
  depend(+Sk1,+Sk2,+Option)
  decides whether Sk1 dependes on Sk2 without caring about the 
  instantiations
 ****************************************************************************/
depend(Sk1,Sk2,Opt) :- 
	depend(Sk1,Sk2,_IT1,_IT2,Opt).

/****************************************************************************
  depend(+Sk1,+Sk2)
  decide whether term skeleton Sk1 depends on Sk2
  and whether the dependency is through aggregation, negation, update
  dependency/4 will be asserted for each path pattern from Sk1 to Sk2
 ****************************************************************************/
depend(Sk1,Sk2) :-
	retractall(target(_,_,_)),
	( is_list(Sk2) ->
	    list_to_targets(Sk2)
	;
            get_canonical_form(Sk2,FLCANON(Wrap,Args,Mod,_Callable)),
	    assert(target(Wrap,Args,Mod))
	),
	findall((RuleHead),match_rule(Sk1,RuleHead,_,_),HeadList),
	remove_dup(HeadList,NewHeadList),
	depend_list(NewHeadList).

list_to_targets([]) :- !.
list_to_targets([H|T]) :-
        get_canonical_form(H,FLCANON(Wrap,Args,Mod,_Callable)),
	assert(target(Wrap,Args,Mod)),
	list_to_targets(T).
	
	
remove_dup([],[]) :- !.
remove_dup([H|T],NewList) :-
	( member(H,T) ->
	    remove_dup(T,NewList)
	;
	    remove_dup(T,InterList),
	    NewList = [H|InterList]
	).

depend_list([]) :- !.
depend_list([(H)|T]) :-
    H = (HC,_HI),
    get_canonical_form(HC,FLCANON(Wrap,Args,Mod,_Callable)),
    ( ignored(W1,A1,M1), subsumes(ignored(W1,A1,M1),ignored(Wrap,Args,Mod)) ->
        true
    ;
        findall((Body,anu(A,N,U),Templete),
	    depend_detail(H,dep(Body,anu(A,N,U),Templete)),
	    DependencyList),
        (DependencyList == [] ->
            true
        ;
            retractall(dependency(_,_,_,_)),
            assert_dependency_list(H,DependencyList),
            aggregate_warnings
        )
    ),
    depend_list(T).

assert_dependency_list(_,[]) :- !.
assert_dependency_list(Term,[(Body,anu(A,N,U),Templete)|T]) :-
    assert(dependency(Term,Body,anu(A,N,U),Templete)),
    assert_dependency_list(Term,T).

depend_detail((_Sk1,IndSk1),dep(S,anu(A,N,U),Templ)) :-
    same_rule(IndSk1,_RuleHead,(B,BI),anu(A,N,U)),
    get_canonical_form(B,FLCANON(Wrap,Args,Mod,_Callable)),
    ( ignored(W1,A1,M1), subsumes(ignored(W1,A1,M1),ignored(Wrap,Args,Mod)) ->
        fail
    ;
        ( var(Wrap),S = (B,BI); nonvar(Wrap),target(Wrap,Args,Mod),S = (B,BI); copy_term(B,CP),rec_depend(CP,S,A,N,U,Templ))
    ).


/****************************************************************************
  rec_depend(+Head,-(Body,IndexedBody),-A,-N,-U,-T)
  Search for all possible dependencies rooted from Head. 
  For each rule whose head can unify with Head, we consider the body. If
  1) the rule body unifies with some target, then we have found a dependency
  2) otherwise, the body and its cut-off form will be recursively checked
 ****************************************************************************/
rec_depend(H,S,A,N,U,T) :-
    match_rule(H,_RuleHead,(RB,RBI),anu(A,N,U)),
    get_canonical_form(RB,FLCANON(Wrap,Args,Mod,_Callable)),
    ( ignored(W1,A1,M1), subsumes(ignored(W1,A1,M1),ignored(Wrap,Args,Mod)) ->
        fail
    ;
        ( var(Wrap),S = (RB,RBI); nonvar(Wrap),target(Wrap,Args,Mod),S = (RB,RBI); 
        ( (depth(RB,Depth),Depth>MAXDEPTH) ->
            cut_off(RB,NRB),
            T=t,
            copy_term(NRB,CP), rec_depend(CP,S,A,N,U,T)
        ;
            copy_term(RB,CP), rec_depend(CP,S,A,N,U,T)
        ))
    ).


/****************************************************************************
  match_rule(+Term,-Head,-Body,?anu(A,N,U))
  find rules whose heads unify with Term
 ****************************************************************************/
match_rule(T,(H,IH),B,anu(A,N,U)) :-
	rule((H,IH),B,anu(A,N,U)),
	T=H.

/****************************************************************************
  same_rule(+IndTerm,-Head,-Body,?anu(A,N,U))
  find rules whose heads unify with Term
 ****************************************************************************/
same_rule(IT,(H,IH),B,anu(A,N,U)) :-
	rule((H,IH),B,anu(A,N,U)),
	IT=IH.


/****************************************************************************
  generate_rules(+CodeList)
  generate rules from intermediate code
  assert tabled head -- tabled_head(_)
  assert hilog predicates excluded from dependency checking -- ignored(_)
 ****************************************************************************/
generate_rules([]) :- !.
generate_rules(CodeList) :-
	retractall(rule(_,_,_)),
	parse_codelist(CodeList).

/****************************************************************************
  parse_codelist(+CodeList)
  generate rules from a list of intermediate code
 ****************************************************************************/
parse_codelist([T]) :-
	!,
	parse_code(T).

parse_codelist([T|L]) :-
	parse_code(T),
	parse_codelist(L).


parse_code(Term) :-
	( is_prrule(Term,Head,Body) ->
            parse_rule(Head,Body)
	;
          is_prdirective(Term,Direct), is_prignoredep(Direct,PList) ->
            assert_ignoredlist(PList)
        ;
            true
	).

assert_ignoredlist([]) :- !.
assert_ignoredlist([H|L]) :-
	flora_build_struct(H,DEFAULT_WORKSPACE,FLBODYPREFIX,_VarList,HC,_HCI),
        ( functor(HC,DB,3), dboperation(DB,3) ->
            HC =.. [DB,WS,DBList,Cond],
            canonical_list(DBList,CDBList),
            get_canonical_form(Cond,FLCANON(_W,_A,_M,CallCond)),
            NHC =.. [DB,WS,CDBList,CallCond]
        ;
          functor(HC,DB,2), dboperation(DB,2) ->
            HC =.. [DB,WS,DBList],
            canonical_list(DBList,CDBList),
            NHC =.. [DB,WS,CDBList]
        ;
            NHC = HC
        ),
        get_canonical_form(NHC,FLCANON(Wrap,Args,Mod,_Callable)),
	assert(ignored(Wrap,Args,Mod)),
        assert_ignoredlist(L).

parse_rule(Head,Body) :-
	flora_build_struct(Head,DEFAULT_WORKSPACE,FLBODYPREFIX,VarList,HeadCode,HCI),
        functor(HeadCode,F,N),
        ( default_tabled(F,N) -> assert(tabled_head((HeadCode,HCI))); true),
	flora_build_struct(Body,DEFAULT_WORKSPACE,FLBODYPREFIX,VarList,BodyCode,BCI),
	assert_rule((HeadCode,HCI),BodyCode,BCI,anu(_,_,_)).

assert_rule(_H,BodyCode,_BI,_) :-
	var(BodyCode),
	!.

assert_rule(_H,FLLIBMODLIT(FL_LIBMOD,_,_,_),_BI,_) :-
        !.

assert_rule(HeadCode,BodyCode,(BCI,_I),anu(A,N,U)) :-
	(BodyCode=','(Body1,Body2); BodyCode=';'(Body1,Body2)),
	(BCI=','(BCI1,BCI2); BCI=';'(BCI1,BCI2)),
	!,
	assert_rule(HeadCode,Body1,BCI1,anu(A,N,U)),
	assert_rule(HeadCode,Body2,BCI2,anu(A,N,U)).

assert_rule(HeadCode,BodyCode,(BCI,_I),anu(A,_,U)) :-
	(BodyCode=not(NewBody); BodyCode=tnot(NewBody)),
	(BCI=not(NewBCI); BCI=tnot(NewBCI)),
	!,
	assert_rule(HeadCode,NewBody,NewBCI,anu(A,n,U)).

assert_rule(_HeadCode,BodyCode,(_BCI,_I),anu(_A,_N,_U)) :-
	is_constraint(BodyCode,_),
	!.
	
assert_rule(HeadCode,BodyCode,(BCI,Index),anu(A,N,U)) :-
	is_upd(BodyCode,_,List,Cond),
	!,
	is_updIdxStruct(BCI,(ListI,_I),CondI),
	assert(rule(HeadCode,(BodyCode,(BCI,Index)),anu(A,N,u))),
	assert_rule(HeadCode,Cond,CondI,anu(A,N,U)),
	assert_rules(HeadCode,List,ListI,anu(A,N,u)).

assert_rule(HeadCode,BodyCode,(BCI,Index),anu(A,N,U)) :-
	is_updall(BodyCode,_,List,Cond),
	!,
	is_updallIdxStruct(BCI,(ListI,_I),CondI),
	assert(rule(HeadCode,(BodyCode,(BCI,Index)),anu(a,N,u))),
	assert_rule(HeadCode,Cond,CondI,anu(A,N,U)),
	assert_rules(HeadCode,List,ListI,anu(A,N,u)).

assert_rule(HeadCode,BodyCode,(BCI,Index),anu(_,N,U)) :-
	is_agg(BodyCode,_,_,_,Condition,_),
	!,
	is_agg(BCI,_,_,_,ConditionI,_),
	assert(rule(HeadCode,(BodyCode,(BCI,Index)),anu(a,N,U))),
	assert_rule(HeadCode,Condition,ConditionI,anu(a,N,U)).

assert_rule(HeadCode,BodyCode,(BCI,_I),anu(A,N,U)) :-
	is_control(BodyCode,_,Args),
	!,
	is_control(BCI,_,ArgsI),
	assert_rules(HeadCode,Args,ArgsI,anu(A,N,U)).

assert_rule(HeadCode,BodyCode,(BCI,_I),anu(A,N,U)) :-
	BodyCode = flsysdbupdate(NewBody,_,_),
	!,
	BCI = flsysdbupdate(NewBCI,_,_),
	assert_rule(HeadCode,NewBody,NewBCI,anu(A,N,U)).

assert_rule(HeadCode,BodyCode,BCwithIndex,anu(A,N,U)) :-
	assert(rule(HeadCode,(BodyCode,BCwithIndex),anu(A,N,U))).

assert_rules(_,[],_,_) :- !.
assert_rules(HeadCode,[H|T],[HI|TI],anu(A,N,U)) :-
    assert_rule(HeadCode,H,HI,anu(A,N,U)),
    assert_rules(HeadCode,T,TI,anu(A,N,U)).

/****************************************************************************
 check_for_dependencies(+CodeList,-WarnList)
 check whether tabled predicates depend on procedural/database operations.
 ****************************************************************************/
check_for_dependencies(CodeList,WarnList) :-
        retractall(tabled_head(_)),
	retractall(warning_seen(_,_,_,_,_)),
        retractall(target(_,_,_)),
        retractall(ignored(_,_,_)),
        flora_abolish_table_predicate(rec_depend(_,_,_,_,_,_)),
        assert_targets,

	generate_rules(CodeList),
        findall(Head,tabled_head(Head),TabledList),
        depend_list(TabledList),
	generate_warnings(WarnList),
	!.

check_for_dependencies(_CodeList,[error(UNKNOWN_ERROR)]).

assert_targets :- 
        procedural(F,A),
        length(Args,A),
        assert(target(F,Args,_Mod)),
        fail.

assert_targets :- 
        dboperation(F,A),
        length(Args,A),
        assert(target(F,Args,_Mod)),
        fail.

assert_targets :- !.

/****************************************************************************
 aggregate_warnings
 find all asserted dependency/4, generate warnings and aggregate them
 ****************************************************************************/
aggregate_warnings :-
	findall(((T1,IT1),(T2,IT2),anu(A,N,U),Temp),
		dependency((T1,IT1),(T2,IT2),anu(A,N,U),Temp),
		DependencyList
	       ),
	aggregate_warnings(DependencyList).

aggregate_warnings([]) :- !.
aggregate_warnings([((T1,IT1),(T2,IT2),_,_)|T]) :-
	flora_set_counter(min_ind,0),
	flora_set_counter(next_min_ind,0),
	to_string(T1,IT1,Str1,RuleID),
	flora_get_counter(min_ind,HMinInd),
	flora_get_counter(next_min_ind,HNMinInd),

	flora_set_counter(min_ind,0),
	flora_set_counter(next_min_ind,0),
	to_string(T2,IT2,Str2,_RID),
	flora_get_counter(min_ind,BMinInd),

        functor(T2,Wrap,NArgs),
        ( dboperation(Wrap,NArgs) ->
	    Type = 'db operation'
	;
            (get_canonical_form(T2,FLCANON(WRAP_HILOG,_As,_Mod,_Callable)) ->
                Type = 'procedural predicate'
            ;
	        Type = 'procedural method'
            )
	),

        fmt_write_string(WarnHead,"Tabled literal in the head of rule that starts with %s", args(Str1)),
        fmt_write_string(WarnBody," depends on %s %s", args(Type,Str2)),
        %%fmt_write_string(WarnMsg,"Tabled literal in the head of rule that starts with %s depends on %s %s",
	%%		 args(Str1,Type,Str2)),

	( warning_seen(RuleID,HInd1,HInd2,BMinInd,_) ->
	    ( (HInd1<HMinInd;HInd1=HMinInd),(HInd2<HNMinInd;HInd2=HNMinInd) ->
	        true
	    ;
	        retract(warning_seen(RuleID,HInd1,HInd2,BMinInd,_)),
		assert(warning_seen(RuleID,HMinInd,HNMinInd,BMinInd,(WarnHead,WarnBody)))
	    )
	;
	    assert(warning_seen(RuleID,HMinInd,HNMinInd,BMinInd,(WarnHead,WarnBody)))
	),
	aggregate_warnings(T).

/****************************************************************************
 to_string(+Term,+IndexedTerm,-Str,-RuleID)
 ****************************************************************************/
 to_string(Term,(IT,Ind),Str,RuleID) :-
	rebuild_text(Term,(IT,Ind),Text),
	flora_get_counter(min_ind,Index),
	( (Index==NO_INDEX) ->
	    fmt_write_string(Str,"`%s'",args(Text)),
	    RuleID==NO_INDEX
	;
 	    flora_token_rulenum(Index,RuleID),
 	    flora_nth_token(Index,Token),
	    flora_token_text(Token,_T,BL,BC,_EL,_EC),
	    fmt_write_string(Str,"`%s' near line(%d)/char(%d)",
			     args(Text,BL,BC))
	).
 	
/****************************************************************************
 rebuild_text(+Term,+IndexdTerm,-Text)
 return a string for the given term to construct warning message
 ****************************************************************************/
rebuild_text(DEFAULT_WORKSPACE,(DEFAULT_WORKSPACE,0), DEFAULT_WORKSPACE) :- !.

rebuild_text(_Term,(T,Index),Text) :-
	(atomic(T);var(T)),
	!,
	flora_get_counter(min_ind,MinInd),
	flora_get_counter(next_min_ind,NextMinInd),
	( (Index<MinInd; MinInd=0) ->
	    flora_set_counter(next_min_ind,MinInd),
	    flora_set_counter(min_ind,Index)
	;
	    ( (Index<NextMinInd; NextMinInd=0) ->
	        flora_set_counter(next_min_ind,Index)
	    ;
	        true
	    )
	),
	flora_nth_token(Index,Token),
	flora_token_text(Token,Text1,_BL,_BC,_EL,_EC),
        escape(Text1,Text).

rebuild_text(_Term,(string(_IndTerm),Index),Text) :-
	!,
	flora_get_counter(min_ind,MinInd),
	flora_get_counter(next_min_ind,NextMinInd),
	( (Index<MinInd; MinInd=0) ->
	    flora_set_counter(next_min_ind,MinInd),
	    flora_set_counter(min_ind,Index)
	;
	    ( (Index<NextMinInd; NextMinInd=0) ->
	        flora_set_counter(next_min_ind,Index)
	    ;
	        true
	    )
	),
	flora_nth_token(Index,Token),
	flora_token_text(Token,Text1,_BL,_BC,_EL,_EC),
        escape(Text1,Text).

rebuild_text(Term,(IndTerm,_Ind),Text) :-
	Term=..['.'|_ListItems],
	!,
	rebuild_text_list(Term,IndTerm,ListText),
	fmt_write_string(Text,"[%s]",args(ListText)).

rebuild_text((T1,T2),(IndTerm,_Ind),Text) :-
	!,
        IndTerm = (IT1,IT2),
        rebuild_text(T1,IT1,Text1),
        rebuild_text(T2,IT2,Text2),
	fmt_write_string(Text,"(%s,%s)",args(Text1,Text2)).

rebuild_text(FLLIBMODLIT(FL_LIBMOD,Term,_Mod,_),
            (FLLIBMODLIT(_IW,IndTerm,_,_),_Ind),Text) :-
        rebuild_text(Term,IndTerm,Text).

rebuild_text(FLLIBMODLIT(WRAP_HILOG,[FL_TRAN,Term,_],_Mod,_),
            (FLLIBMODLIT(_IW,([_,IndTerm,_],_),_IndMod,_),_),Text) :-
        rebuild_text(Term,IndTerm,TermText),
        fmt_write_string(Text,"#%s",args(TermText)).

rebuild_text(Term,(_IndT,Index),Text) :-
	( is_upd(Term,_Op,_List,_Cond)
	; is_updall(Term,_Op,_List,_Cond)
	; is_agg(Term,_Op,_Var,_Group,_Condition,_Result)
	),
    	!,
	flora_get_counter(min_ind,MinInd),
	flora_get_counter(next_min_ind,NextMinInd),
	( (Index<MinInd; MinInd=0) ->
	    flora_set_counter(next_min_ind,MinInd),
	    flora_set_counter(min_ind,Index)
	;
	    ( (Index<NextMinInd; NextMinInd=0) ->
	        flora_set_counter(next_min_ind,Index)
	    ;
	        true
	    )
	),
	flora_nth_token(Index,Token),
	flora_token_text(Token,Text,_BL,_BC,_EL,_EC).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=PREFIXED_WRAP_TRAN(Var,Tran,_),
	!,
	IndT=PREFIXED_WRAP_TRAN(IndVar,IndTran,_),
	rebuild_text(Var,IndVar,VarText),
	rebuild_text(Tran,IndTran,TranText),
	fmt_write_string(Text,"%s[#%s]",args(VarText,TranText)).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=PREFIXED_WRAP_ISA(Var,Class,_),
	!,
	IndT=PREFIXED_WRAP_ISA(IndVar,IndClass,_),
	rebuild_text(Var,IndVar,VarText),
	rebuild_text(Class,IndClass,ClassText),
	fmt_write_string(Text,"%s:%s",args(VarText,ClassText)).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=PREFIXED_WRAP_SUB(Var,Class,_),
	!,
	IndT=PREFIXED_WRAP_SUB(IndVar,IndClass,_),
	rebuild_text(Var,IndVar,VarText),
	rebuild_text(Class,IndClass,ClassText),
	fmt_write_string(Text,"%s::%s",args(VarText,ClassText)).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=PREFIXED_WRAP_METH(Var,Meth,_),
	!,
	IndT=PREFIXED_WRAP_METH(IndVar,IndMeth,_),
	rebuild_text(Var,IndVar,VarText),
	rebuild_text(Meth,IndMeth,MethText),
	fmt_write_string(Text,"%s[%s]",args(VarText,MethText)).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=PREFIXED_WRAP_IMETH(Var,IMeth,_),
	!,
	IndT=PREFIXED_WRAP_IMETH(IndVar,IndIMeth,_),
	rebuild_text(Var,IndVar,VarText),
	rebuild_text(IMeth,IndIMeth,IMethText),
	fmt_write_string(Text,"%s[*%s]",args(VarText,IMethText)).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=fdskolem(Var,Meth),
	!,
	IndT=fdskolem(IndVar,IndMeth),
	rebuild_text(Var,IndVar,VarText),
	rebuild_text(Meth,IndMeth,MethText),
	fmt_write_string(Text,"%s.%s",args(VarText,MethText)).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=ifdskolem(Var,IMeth),
	!,
	IndT=ifdskolem(IndVar,IndIMeth),
	rebuild_text(Var,IndVar,VarText),
	rebuild_text(IMeth,IndIMeth,IMethText),
	fmt_write_string(Text,"%s!%s",args(VarText,IMethText)).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=PREFIXED_WRAP_FD(Var,Attr,Val,_),
	!,
	IndT=PREFIXED_WRAP_FD(IndVar,IndAttr,IndVal,_),
	rebuild_text(Var,IndVar,VarText),
	rebuild_text(Attr,IndAttr,AttrText),
	( (not(var(Val)),(Val=fdskolem(Var,Attr))) ->
	    fmt_write_string(Text,"%s.%s[]",args(VarText,AttrText))
	;
	    rebuild_text(Val,IndVal,ValText),
	    fmt_write_string(Text,"%s[%s->%s]",args(VarText,AttrText,ValText))
	).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=PREFIXED_WRAP_IFD(Var,Attr,Val,_),
	!,
	IndT=PREFIXED_WRAP_IFD(IndVar,IndAttr,IndVal,_),
	rebuild_text(Var,IndVar,VarText),
	rebuild_text(Attr,IndAttr,AttrText),
	( (not(var(Val)),(Val=ifdskolem(Var,Attr))) ->
	    fmt_write_string(Text,"%s!%s[]",args(VarText,AttrText))
	;
	    rebuild_text(Val,IndVal,ValText),
	    fmt_write_string(Text,"%s[%s*->%s]",args(VarText,AttrText,ValText))
	).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=PREFIXED_WRAP_FDSIG(Var,Attr,Type,_),
	!,
	IndT=PREFIXED_WRAP_FDSIG(IndVar,IndAttr,IndType,_),
	rebuild_text(Var,IndVar,VarText),
	rebuild_text(Attr,IndAttr,AttrText),
	rebuild_text(Type,IndType,TypeText),
	fmt_write_string(Text,"%s[%s=>%s]",args(VarText,AttrText,TypeText)).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=PREFIXED_WRAP_IFDSIG(Var,Attr,Type,_),
	!,
	IndT=PREFIXED_WRAP_IFDSIG(IndVar,IndAttr,IndType,_),
	rebuild_text(Var,IndVar,VarText),
	rebuild_text(Attr,IndAttr,AttrText),
	rebuild_text(Type,IndType,TypeText),
	fmt_write_string(Text,"%s[%s*=>%s]",args(VarText,AttrText,TypeText)).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=PREFIXED_WRAP_MVD(Var,Attr,Val,_),
	!,
	IndT=PREFIXED_WRAP_MVD(IndVar,IndAttr,IndVal,_),
	rebuild_text(Var,IndVar,VarText),
	rebuild_text(Attr,IndAttr,AttrText),
	rebuild_text(Val,IndVal,ValText),
	fmt_write_string(Text,"%s[%s->>{%s}]",args(VarText,AttrText,ValText)).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=PREFIXED_WRAP_IMVD(Var,Attr,Val,_),
	!,
	IndT=PREFIXED_WRAP_IMVD(IndVar,IndAttr,IndVal,_),
	rebuild_text(Var,IndVar,VarText),
	rebuild_text(Attr,IndAttr,AttrText),
	rebuild_text(Val,IndVal,ValText),
	fmt_write_string(Text,"%s[%s*->>{%s}]",args(VarText,AttrText,ValText)).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=PREFIXED_WRAP_MVDSIG(Var,Attr,Type,_),
	!,
	IndT=PREFIXED_WRAP_MVDSIG(IndVar,IndAttr,IndType,_),
	rebuild_text(Var,IndVar,VarText),
	rebuild_text(Attr,IndAttr,AttrText),
	rebuild_text(Type,IndType,TypeText),
	fmt_write_string(Text,"%s[%s=>>%s]",args(VarText,AttrText,TypeText)).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=PREFIXED_WRAP_IMVDSIG(Var,Attr,Type,_),
	!,
	IndT=PREFIXED_WRAP_IMVDSIG(IndVar,IndAttr,IndType,_),
	rebuild_text(Var,IndVar,VarText),
	rebuild_text(Attr,IndAttr,AttrText),
	rebuild_text(Type,IndType,TypeText),
	fmt_write_string(Text,"%s[%s*=>>%s]",args(VarText,AttrText,TypeText)).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=PREFIXED_WRAP_EXISTS(Var,_),
	!,
	IndT=PREFIXED_WRAP_EXISTS(IndVar,_),
	rebuild_text(Var,IndVar,VarText),
	fmt_write_string(Text,"%s[]",args(VarText)).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=PREFIXED_WRAP_MVDDEF(Var,Attr,_),
	!,
	IndT=PREFIXED_WRAP_MVDDEF(IndVar,IndAttr,_),
	rebuild_text(Var,IndVar,VarText),
	rebuild_text(Attr,IndAttr,AttrText),
	fmt_write_string(Text,"%s[%s->>{}]",args(VarText,AttrText)).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=PREFIXED_WRAP_IMVDDEF(Var,Attr,_),
	!,
	IndT=PREFIXED_WRAP_IMVDDEF(IndVar,IndAttr,_),
	rebuild_text(Var,IndVar,VarText),
	rebuild_text(Attr,IndAttr,AttrText),
	fmt_write_string(Text,"%s[%s*->>{}]",args(VarText,AttrText)).

rebuild_text(Term,(IndT,_Index),Text) :-
	Term=PREFIXED_WRAP_OBJEQL(O1,O2,_),
	!,
	IndT=PREFIXED_WRAP_OBJEQL(IndO1,IndO2,_),
	rebuild_text(O1,IndO1,O1Text),
	rebuild_text(O2,IndO2,O2Text),
	fmt_write_string(Text,"%s:=:%s",args(O1Text,O2Text)).

rebuild_text(Term,(IndT1,Index),Text) :-
        flora_decode_predicate(Term,_Type,Mod,F,_Prefix,Pred,A),
        (IndT1 = (IndT,_),!; IndT1=IndT),
        ( F==WRAP_TRAN,nonvar(Mod) ->
            IndT=..[_IndF,IndVar,IndTran,_],
            A=[Var,Tran,_],
	    rebuild_text(Var,IndVar,VarText),
	    rebuild_text(Tran,IndTran,TranText),
	    fmt_write_string(Text,"%s[#%s]",args(VarText,TranText))
        ;
	    IndT=..[_IndF|IndA],
            ( F==WRAP_TABLED_HILOG,nonvar(Mod) -> %tabled hilog pred
                Pred=Func,
                IndA=[IndFunc|IndArgsCaller],
                remove_caller(A,Args),
                remove_caller(IndArgsCaller,IndArgs),
                rebuild_text(Func,IndFunc,FuncText)
            ; F==WRAP_HILOG,nonvar(Mod) -> %non-tabled hilog pred
                Pred=Func,
	        IndA=[IndFunc|IndArgsCaller],
                remove_caller(A,Args),
                remove_caller(IndArgsCaller,IndArgs),
	        rebuild_text(Func,IndFunc,FT),
                fmt_write_string(FuncText,"#%s",args(FT))
            ; F==WRAP_HILOG -> %hilog term
                A=[Func|Args],
                IndA=[IndFunc|IndArgs],
                rebuild_text(Func,IndFunc,FuncText)
	    ;
	        flora_get_counter(min_ind,MinInd),
	        flora_get_counter(next_min_ind,NextMinInd),
	        ( (Index<MinInd; MinInd=0) ->
	            flora_set_counter(next_min_ind,MinInd),
	            flora_set_counter(min_ind,Index)
	        ;
	            ( (Index<NextMinInd; NextMinInd=0) ->
	                flora_set_counter(next_min_ind,Index)
	            ;
	                true
	            )
	        ),
	        flora_nth_token(Index,Token),
	        flora_token_text(Token,FuncText,_BL,_BC,_EL,_EC),
	        Args=A,
	        IndArgs=IndA
	    ),
	    ( (Args==[]) ->
	        fmt_write_string(Text,"%s",args(FuncText))
	    ;
	        rebuild_text_list(Args,IndArgs,ArgsText),
	        fmt_write_string(Text,"%s(%s)",args(FuncText,ArgsText))
	    )
        ).

/****************************************************************************
 rebuild_text_list(+List,+IndexdList,-Text)
 ****************************************************************************/
rebuild_text_list(L,(_Var,Index),Text) :-
	var(L),
	!,
	flora_get_counter(min_ind,MinInd),
	flora_get_counter(next_min_ind,NextMinInd),
	( (Index<MinInd; MinInd=0) ->
	    flora_set_counter(next_min_ind,MinInd),
	    flora_set_counter(min_ind,Index)
	;
	    ( (Index<NextMinInd; NextMinInd=0) ->
	        flora_set_counter(next_min_ind,Index)
	    ;
	        true
	    )
	),
	flora_nth_token(Index,Token),
	flora_token_text(Token,Text,_BL,_BC,_EL,_EC).

rebuild_text_list([],_,'') :- !.

rebuild_text_list([H|L],[IndH|IndL],Text) :-
	( var(L) ->
	    rebuild_text(H,IndH,HText),
	    ( (IndL=..['.'|_ListItems]) ->
	        rebuild_text_list(L,IndL,LText),
	        fmt_write_string(Text,"%s,%s",args(HText,LText))
	    ;
	        rebuild_text(L,IndL,LText),
	        fmt_write_string(Text,"%s|%s",args(HText,LText))
	    )
	;
	    ( L==[] ->
	        rebuild_text(H,IndH,Text)
	    ;
	        rebuild_text(H,IndH,HText),
	        ( (IndL=..['.'|_ListItems]) ->
	            rebuild_text_list(L,IndL,LText),
	            fmt_write_string(Text,"%s,%s",args(HText,LText))
	        ;
	            rebuild_text(L,IndL,LText),
	            fmt_write_string(Text,"%s|%s",args(HText,LText))
	        )
	    )
	).

/****************************************************************************
 generate_warnings(-WarnList)
 ****************************************************************************/
generate_warnings(WarnList) :-
	findall((HInd1,BInd,WarnMsg),warning_seen(_,HInd1,_,BInd,WarnMsg),WL),
	sort(WL, SortedWL),
	append_warnings(SortedWL,WarnList).

append_warnings([],[]) :- !.
append_warnings([(HInd,BInd,WarnMsg)|T],[warning(HInd,BInd,WarnMsg)|InterWarnList]) :-
	append_warnings(T,InterWarnList).

/****************************************************************************
 remove_caller(+Args1, -Args2)
 remove the last element of the argument list which is the caller
 ****************************************************************************/
remove_caller([_H], []) :- !.
remove_caller([H|L],[H|NL]) :-
        remove_caller(L,NL).

/****************************************************************************
 canonical_list(+L1,-L2)
 ****************************************************************************/
canonical_list([], []) :- !.
canonical_list([H|L],[Callable|NL]) :-
        get_canonical_form(H,FLCANON(_,_,_,Callable)),
        canonical_list(L,NL).

/****************************************************************************
 escape(+Text1, -Text2)
 for strings, replace every occurency of \ with \\ so that \n is printed
 as it is instead of being interpreted
 ****************************************************************************/
escape([],[]) :- !.
escape([CH_BACKSLASH|L],[CH_BACKSLASH,CH_BACKSLASH|EL]) :-
        !,
        escape(L,EL).
escape([H|L],[H|EL]) :-
        !,
        escape(L,EL).
escape(NL,NL) :- !.

