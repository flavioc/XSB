/* File:      flrshell.P  -- The Flora interactive shell
**
** Author(s): Guizhen Yang       (Flora)
**    	      Bertram Ludaescher (Flip, the Flora spiritual father)
** Contact:   xsb-contact@cs.sunysb.edu
**
** Copyright (C) Bertram Ludaescher, 1998
** Copyright (C) The Research Foundation of SUNY, 1999
**
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id$
**
*/


:- compiler_options([cpp_on]).
#include "standard.h"


/*********************************************************************/
'_$_$_flora_shell' :-
	bootstrap_flora,
	'_$_$_flora_welcome_msg',
	all,
	push_abort_cutpoint,
	conset(flora_shell_loaded, 1),
	'_$_$_flora_shell_loop'.


/*********************************************************************/
'_$_$_flora_welcome_msg' :-
	package_configuration(version(flora),V),
	flora_display_msg("\nFLORA Version %S\n", arg(V)),
	flora_display_msg('Type `help.'' to show the help message'),
	flora_display_msg('Type `rundemo(demoName).'' to run demos in XSB/packages/flora/demos/'),
	!.


/*********************************************************************/
'_$_$_flora_shell_loop' :-
	repeat,
	'_$_$_flora_write_shell_prompt',
	flora_read_parse_compile(static_mode,
					[atom('$?'),atom('$-')],
					Tokens,
					Rules,
					Status,
					Opts),
	( member(noop,Status) ->
	    file_nl(STDMSG), S=Status

	  ; member(error(_),Status) ->
	    ( (member(eof,Status); member(atom(rule_delimeter),Tokens)) ->
		S=Status
	      ;
	        flora_discard_tokens(S)
	    )

	  ;
	    S=Status,
	    (Opts=[] -> true; '_$_$_flora_check_library'(Opts)),
	    Rules=[query(Gs,NVs)],
	    '_$_$_flora_print_answers'(Gs,NVs)
	),
	'_$_$_flora_loop_guard'(S).

'_$_$_flora_write_shell_prompt' :-
	pop_abort_cutpoint,
	push_abort_cutpoint,
	seen,
	see(userin),
	told,
	tell(userout),
	file_nl(STDFDBK), file_write(STDFDBK, 'flora ?- ').

'_$_$_flora_loop_guard'(S) :- (member(eof,S) -> end ; fail).


/*********************************************************************/
'_$_$_flora_check_library'(Opts) :-
	package_configuration(dir(flora),FloraDir),
	slash(S),
	( member(flrassert,Opts) ->
	    ( current_predicate('_$_$_flora_assert'/1) ->
	       true
	      ;
	       fmt_write_string(Assert,'%s%ssyslib%sflrassert.P',f(FloraDir,S,S)),
	       consult(Assert)
	    )
	  ;
	    true
	),
	( member(flraggregate,Opts) ->
	    ( current_predicate('_$_$_flora_min'/3) ->
	      true
	     ;
	      fmt_write_string(Aggr,'%s%ssyslib%sflraggregate.P',f(FloraDir,S,S)),
	      consult(Aggr)
	    )
	  ;
	    true
	),
	( member(skolem,Opts) ->
	    flora_warning_nl('skolemization may require equality checking')
	  ;
	   true
	).


/*********************************************************************/
'_$_$_flora_print_answers'(Gs,NVs) :-
	( '_$_$_flora_switch'(all) ->
	    '_$_$_flora_print_all'(Gs,NVs)
	  ;
	    '_$_$_flora_print_one'(Gs,NVs)
	).


/*********************************************************************/
help :-
	flora_display_msg("\nFLORA commands:\n"),
	flora_display_msg('  help                         : show this info'),
	flora_display_msg('  compile(FILE[.P])            : compile FILE.P; create FILE.O'),
	flora_display_msg('  flcompile(FILE.[flr])        : compile FILE.flr; create FILE.P and FILE.O'),
	flora_display_msg('  flcompile(FILE.[flr],[...])  : flcompile(FILE) with options [...]'),
	flora_display_msg('  flconsult(FILE.[flr])        : compile FILE.flr; consult FILE.P'),
	flora_display_msg('  flconsult(FILE.[flr],[...])  : flconsult(FILE) with options [...]'),
	flora_display_msg('  flload(FILE[.{P|O|flr}])     : consult FILE.flr, FILE.P or FILE.O'),
	flora_display_msg('  [FILE[.{P|O|flr}],...]       : consult a list of .flr, .P, or .O files'),
	flora_display_msg('  dyncompile(FILE[.flr])       : compile FILE.flr to dynamic code'),
	flora_display_msg('  dyncompile(FILE[.flr],[...]) : dyncompile(FILE) with options [...]'),
	flora_display_msg('  dynconsult(FILE[.flr])       : dyncompile FILE.flr; dynamically load FILE.P'),
	flora_display_msg('  dynconsult(FILE[.flr],[...]) : dynconsult(FILE) with options [...]'),
	flora_display_msg('  dynload(FILE[.flr])          : dynamically load FILE.flr or FILE.P'),
	flora_display_msg('  <FILE[.EXT],...>             : dynload a list of .flr or .P files'),
	flora_display_msg('  rundemo(FILE[.flr])          : flconsult a demo from FLORA demos directory'),
	flora_display_msg('  rundemo(FILE[.flr],[...])    : rundemo(FILE) with options [...]'),
	flora_display_msg('  abolish_all_tables           : flush all tabled data'),
	flora_display_msg('  all                          : show all solutions (default)'),
	flora_display_msg('  one                          : show solutions one by one'),
	flora_display_msg('  maxerr(all/N)                : set/show the error reporting threshold'),
	flora_display_msg('  end                          : Ciao to FLORA'),
	flora_display_msg('  halt                         : Ciao both to FLORA and XSB').



/*********************************************************************/
rundemo(X,Dtvs) :-
	flora_check_filename(X),
	package_configuration(dir(flora),FloraDir),
	slash(Slash),
	%% Add the demo directory to library_directory
	fmt_write_string(DemoDir, '%s%sdemos', f(FloraDir, Slash)),
	(library_directory(DemoDir)
	       -> true
		; assert(library_directory(DemoDir))
	),
	flconsult(X,Dtvs),
	retract(library_directory(DemoDir)).

rundemo(X) :-
	flora_check_filename(X),
	package_configuration(dir(flora),FloraDir),
	slash(Slash),
	%% Add the demo directory to library_directory
	fmt_write_string(DemoDir, '%s%sdemos', f(FloraDir, Slash)),
	(library_directory(DemoDir)
	       -> true
		; assert(library_directory(DemoDir))
	),
	flconsult(X),
	retract(library_directory(DemoDir)).


/*********************************************************************/
all :-
	( '_$_$_flora_switch'(all) ->
	    true
	  ;
	    trie_assert('_$_$_flora_switch'(all))
	).

one :-
	trie_retract_all('_$_$_flora_switch'(all)).


%% Turn off printing CPU time and host information
%% These are used in the test suite in order to eliminate 
%% time/host dependent output. 
chatterbox(off) :- trie_assert('_$_$_flora_switch'(no_chatter)).
chatterbox(on) :- trie_retract_all('_$_$_flora_switch'(no_chatter)).


/*********************************************************************/

flora_trace :-   ('_$_$_flora_debugger_data_loaded'
		  -> true
		  ;  [flrdebugger]
		 ),
    	    	 '_$_$_flora_trace'.
flora_notrace :- ('_$_$_flora_debugger_data_loaded'
		  -> true
		  ;  [flrdebugger]
		 ),
    	    	 '_$_$_flora_notrace'.

/*********************************************************************/
end :-
	unload_package(flora),
	conset(flora_shell_loaded,0),
	file_nl(STDMSG), flora_display_msg('Ciao!'),
	pop_abort_cutpoint,
	abort.


/*********************************************************************/
%% Take all *,flr files in ./flora/demos/ and flora-compile them.
%% This relies on the availability of Posix wildcard matcher.
%% It is used only for configuring the demos.
flcompile_all_demos  :-
	package_configuration(dir(flora),FloraDir),
	slash(S),
	fmt_write_string(DemoDir,'%s%sdemos',f(FloraDir,S)),
        glob_directory('*.flr', DemoDir, _, DemoList),
	(library_directory(DemoDir) -> true
	    ;
	    assert(library_directory(DemoDir))
	),
	flcompile_demo(DemoList),
	retract(library_directory(DemoDir)).

flcompile_demo([D|Rest]) :- 
	flora_flcompile(static_mode,[],D,noforce,_),
	flcompile_demo(Rest).
flcompile_demo([]).



/********************************************************************/
:- table '_$_$_flora_fd_dyn'/3.
:- table '_$_$_flora_mvd_dyn'/3.
:- table '_$_$_flora_ifd_dyn'/3.
:- table '_$_$_flora_imvd_dyn'/3.
:- table '_$_$_flora_isa_dyn'/2.
:- table '_$_$_flora_sub_dyn'/2.
:- table '_$_$_flora_fs_dyn'/3.
:- table '_$_$_flora_mvs_dyn'/3.
:- table '_$_$_flora_mvd_dyn'/2.
:- table '_$_$_flora_imvd_dyn'/2.
:- table '_$_$_flora_exists_dyn'/1.
:- table '_$_$_flora_fd_rhs_dyn'/3.
:- table '_$_$_flora_mvd_rhs_dyn'/3.
:- table '_$_$_flora_ifd_rhs_dyn'/3.
:- table '_$_$_flora_imvd_rhs_dyn'/3.
:- table '_$_$_flora_isa_rhs_dyn'/2.
:- table '_$_$_flora_sub_rhs_dyn'/2.
:- table '_$_$_flora_fs_rhs_dyn'/3.
:- table '_$_$_flora_mvs_rhs_dyn'/3.
:- table '_$_$_flora_mvd_rhs_dyn'/2.
:- table '_$_$_flora_imvd_rhs_dyn'/2.


:- dynamic '_$_$_flora_fd_dyn'/3.
:- dynamic '_$_$_flora_mvd_dyn'/3.
:- dynamic '_$_$_flora_ifd_dyn'/3.
:- dynamic '_$_$_flora_imvd_dyn'/3.
:- dynamic '_$_$_flora_isa_dyn'/2.
:- dynamic '_$_$_flora_sub_dyn'/2.
:- dynamic '_$_$_flora_fs_dyn'/3.
:- dynamic '_$_$_flora_mvs_dyn'/3.
:- dynamic '_$_$_flora_mvs_dyn'/2.
:- dynamic '_$_$_flora_mvd_dyn'/2.
:- dynamic '_$_$_flora_imvd_dyn'/2.
:- dynamic '_$_$_flora_exists_dyn'/1.
:- dynamic '_$_$_flora_fd_rhs_dyn'/3.
:- dynamic '_$_$_flora_mvd_rhs_dyn'/3.
:- dynamic '_$_$_flora_ifd_rhs_dyn'/3.
:- dynamic '_$_$_flora_imvd_rhs_dyn'/3.
:- dynamic '_$_$_flora_isa_rhs_dyn'/2.
:- dynamic '_$_$_flora_sub_rhs_dyn'/2.
:- dynamic '_$_$_flora_fs_rhs_dyn'/3.
:- dynamic '_$_$_flora_mvs_rhs_dyn'/3.
:- dynamic '_$_$_flora_mvd_rhs_dyn'/2.
:- dynamic '_$_$_flora_imvd_rhs_dyn'/2.


'_$_$_flora_fd'(O,M,R)       :- '_$_$_flora_fd_dyn'(O,M,R).
'_$_$_flora_mvd'(O,M,R)      :- '_$_$_flora_mvd_dyn'(O,M,R).
'_$_$_flora_ifd'(O,M,R)      :- '_$_$_flora_ifd_dyn'(O,M,R).
'_$_$_flora_imvd'(O,M,R)     :- '_$_$_flora_imvd_dyn'(O,M,R).
'_$_$_flora_isa'(O1,O2)      :- '_$_$_flora_isa_dyn'(O1,O2).
'_$_$_flora_sub'(O1,O2)      :- '_$_$_flora_sub_dyn'(O1,O2).
'_$_$_flora_fs'(O,M,R)       :- '_$_$_flora_fs_dyn'(O,M,R).
'_$_$_flora_mvs'(O,M,R)      :- '_$_$_flora_mvs_dyn'(O,M,R).
'_$_$_flora_mvd'(O1,O2)      :- '_$_$_flora_mvd_dyn'(O1,O2).
'_$_$_flora_imvd'(O1,O2)     :- '_$_$_flora_imvd_dyn'(O1,O2).
'_$_$_flora_exists'(O)       :- '_$_$_flora_exists_dyn'(O).


/*****************************************************************************
  closure rules for X::Y
*****************************************************************************/
:- table '_$_$_flora_subclass'/2.
:- table '_$_$_flora_strict_subclass'/2.

'_$_$_flora_subclass'(X,X) :- '_$_$_flora_exists'(X).
'_$_$_flora_subclass'(X,Y) :- '_$_$_flora_strict_subclass'(X,Y).

%% Using flora_subclass can be a major source of inefficiency
%% In most cases, we want to use '_$_$_flora_strict_subclass'
'_$_$_flora_strict_subclass'(X,Y) :- '_$_$_flora_sub'(X,Y), X \= Y.

'_$_$_flora_strict_subclass'(X,Y) :-
	'_$_$_flora_strict_subclass'(X,Z), 
	'_$_$_flora_strict_subclass'(Z,Y),
	%%(X \= Z -> true ; Z\=Y),
	( X = Y ->
	    flora_warning_nl('cyclic subclass hierarchy: %S::%S::%S',
			     args(X,Z,Y))
	  ;
	    true
	).


/*****************************************************************************
  closure rules for X:Y, X::Z implies X:Z
*****************************************************************************/
:- table '_$_$_flora_isa'/2.

'_$_$_flora_isa'(O,C) :-
	'_$_$_flora_strict_subclass'(C1,C),
	'_$_$_flora_isa'(O,C1).


/*****************************************************************************
  rules for monotonic inheritance of signatures
*****************************************************************************/
:- table '_$_$_flora_fs'/3.
:- table '_$_$_flora_mvs'/3.
:- table '_$_$_flora_ifs'/3.
:- table '_$_$_flora_imvs'/3.

'_$_$_flora_fs'(O,MethodArgs,R) :-
	'_$_$_flora_isa'(O,Class),
	'_$_$_flora_fs'(Class,MethodArgs,R).
'_$_$_flora_ifs'(O,MethodArgs,R) :-
	'_$_$_flora_isa'(O,Class),
	'_$_$_flora_ifs'(Class,MethodArgs,R).

'_$_$_flora_mvs'(O,MethodArgs,R) :-
	'_$_$_flora_isa'(O,Class),
	'_$_$_flora_mvs'(Class,MethodArgs,R).
'_$_$_flora_imvs'(O,MethodArgs,R) :-
	'_$_$_flora_isa'(O,Class),
	'_$_$_flora_imvs'(Class,MethodArgs,R).

'_$_$_flora_fs'(Sub,MethodArgs,R) :-
	'_$_$_flora_strict_subclass'(Sub,Class),
	'_$_$_flora_fs'(Class,MethodArgs,R).
'_$_$_flora_ifs'(Sub,MethodArgs,R) :-
	'_$_$_flora_strict_subclass'(Sub,Class),
	'_$_$_flora_ifs'(Class,MethodArgs,R).

'_$_$_flora_mvs'(Sub,MethodArgs,R) :-
	'_$_$_flora_strict_subclass'(Sub,Class),
	'_$_$_flora_mvs'(Class,MethodArgs,R).
'_$_$_flora_imvs'(Sub,MethodArgs,R) :-
	'_$_$_flora_strict_subclass'(Sub,Class),
	'_$_$_flora_imvs'(Class,MethodArgs,R).


/*****************************************************************************
  rules for nonmonotonic inheritance of behavior
*****************************************************************************/

:- table '_$_$_flora_fd'/3.
:- table '_$_$_flora_mvd'/3.
:- table '_$_$_flora_ifd'/3.
:- table '_$_$_flora_imvd'/3.
:- table '_$_$_flora_defined_fd'/2.
:- table '_$_$_flora_defined_mvd'/2.
:- table '_$_$_flora_defined_ifd'/2.
:- table '_$_$_flora_defined_imvd'/2.
:- table '_$_$_flora_overwritten_fd'/3.
:- table '_$_$_flora_overwritten_mvd'/3.
:- table '_$_$_flora_overwritten_ifd'/3.
:- table '_$_$_flora_overwritten_imvd'/3.
:- table '_$_$_flora_conflict_fd'/3.
:- table '_$_$_flora_conflict_ifd'/3.
:- table '_$_$_flora_conflict_mvd'/3.
:- table '_$_$_flora_conflict_imvd'/3.

'_$_$_flora_fd'(Object,Method,Value) :-
	%% If Object,Method are ground, check if Object[Method->...]
	%% is defined right away --an optimization
	(ground(Object), ground(Method) ->
	    tnot('_$_$_flora_defined_fd'(Object,Method)),
	    '_$_$_flora_isa'(Object,Class),
	    '_$_$_flora_ifd'(Class,Method,Value)
	  ;
	    '_$_$_flora_isa'(Object,Class),
	    '_$_$_flora_ifd'(Class,Method,Value),
	    tnot('_$_$_flora_defined_fd'(Object,Method))
	),
	tnot('_$_$_flora_overwritten_fd'(Object,Class,Method)),
	tnot('_$_$_flora_conflict_fd'(Object,Class,Method)).

'_$_$_flora_defined_fd'(Object,Method) :- '_$_$_flora_fd'(Object,Method,_).

'_$_$_flora_overwritten_fd'(Object,Class,Method) :-
	'_$_$_flora_isa'(Object,SubClass),
	'_$_$_flora_strict_subclass'(SubClass,Class),
	'_$_$_flora_ifd'(SubClass,Method,_).

%% When this is called, Object always belongs to Class
'_$_$_flora_conflict_fd'(Object,Class,Method) :-
	'_$_$_flora_defined_ifd'(Class1,Method),
	Class \= Class1,
	'_$_$_flora_isa'(Object,Class1),
	tnot('_$_$_flora_strict_subclass'(Class1,Class)),
	tnot('_$_$_flora_strict_subclass'(Class,Class1)).


'_$_$_flora_mvd'(Object,Method,Value) :-
	(ground(Object), ground(Method) ->
	    tnot('_$_$_flora_defined_mvd'(Object,Method)),
	    '_$_$_flora_isa'(Object,Class),
	    '_$_$_flora_imvd'(Class,Method,Value)
	  ;
	    '_$_$_flora_isa'(Object,Class),
	    '_$_$_flora_imvd'(Class,Method,Value),
	    tnot('_$_$_flora_defined_mvd'(Object,Method))
	),
	tnot('_$_$_flora_overwritten_mvd'(Object,Class,Method)),
	tnot('_$_$_flora_conflict_mvd'(Object,Class,Method)).

'_$_$_flora_defined_mvd'(Object,Method) :- '_$_$_flora_mvd'(Object,Method,_).

'_$_$_flora_overwritten_mvd'(Object,Class,Method) :-
	'_$_$_flora_isa'(Object,SubClass),
	'_$_$_flora_strict_subclass'(SubClass,Class),
	'_$_$_flora_imvd'(SubClass,Method,_).

'_$_$_flora_conflict_mvd'(Object,Class,Method) :-
	'_$_$_flora_defined_imvd'(Class1,Method),
	Class \= Class1,
	'_$_$_flora_isa'(Object,Class1),
	tnot('_$_$_flora_strict_subclass'(Class1,Class)),
	tnot('_$_$_flora_strict_subclass'(Class,Class1)).


'_$_$_flora_ifd'(Class,Method,Value) :-
	(ground(Class), ground(Method) ->
	    tnot('_$_$_flora_defined_ifd'(Class,Method)),
	    '_$_$_flora_strict_subclass'(Class,Super),
	    '_$_$_flora_ifd'(Super,Method,Value)
	  ;
	    '_$_$_flora_strict_subclass'(Class,Super),
	    '_$_$_flora_ifd'(Super,Method,Value),
	    tnot('_$_$_flora_defined_ifd'(Class,Method))
	),
	tnot('_$_$_flora_overwritten_ifd'(Class,Super,Method)),
	tnot('_$_$_flora_conflict_ifd'(Class,Super,Method)).

'_$_$_flora_defined_ifd'(Class,Method) :- '_$_$_flora_ifd'(Class,Method,_).

'_$_$_flora_overwritten_ifd'(Class,Super,Method) :-
	'_$_$_flora_strict_subclass'(Class,S),
	'_$_$_flora_strict_subclass'(S,Super),
	'_$_$_flora_ifd'(S,Method,_).

%% Note: when this is called, Class is always a subclass of Super
'_$_$_flora_conflict_ifd'(Class,Super,Method) :-
	'_$_$_flora_defined_ifd'(Super1,Method),
	Super1 \= Super,
	'_$_$_flora_strict_subclass'(Class,Super1),
	tnot('_$_$_flora_strict_subclass'(Super1,Super)),
	tnot('_$_$_flora_strict_subclass'(Super,Super1)).


'_$_$_flora_imvd'(Class,Method,Value) :-
	(ground(Class), ground(Method) ->
	    tnot('_$_$_flora_defined_imvd'(Class,Method)),
	    '_$_$_flora_strict_subclass'(Class,Super),
	    '_$_$_flora_imvd'(Super,Method,Value)
	  ;
	    '_$_$_flora_strict_subclass'(Class,Super),
	    '_$_$_flora_imvd'(Super,Method,Value),
	    tnot('_$_$_flora_defined_imvd'(Class,Method))
	),
	tnot('_$_$_flora_overwritten_imvd'(Class,Super,Method)),
	tnot('_$_$_flora_conflict_imvd'(Class,Super,Method)).

'_$_$_flora_defined_imvd'(Class,Method) :- '_$_$_flora_imvd'(Class,Method,_).

'_$_$_flora_overwritten_imvd'(Class,Super,Method) :-
	'_$_$_flora_strict_subclass'(Class,S),
	'_$_$_flora_strict_subclass'(S,Super),
	'_$_$_flora_imvd'(S,Method,_).

%% Note: when this is called, Class is always a subclass of Super
'_$_$_flora_conflict_imvd'(Class,Super,Method) :-
	'_$_$_flora_defined_imvd'(Super1,Method),
	Super1 \= Super,
	'_$_$_flora_strict_subclass'(Class,Super1),
	tnot('_$_$_flora_strict_subclass'(Super1,Super)),
	tnot('_$_$_flora_strict_subclass'(Super,Super1)).


/*****************************************************************************
  rules for object existence and empty result sets
*****************************************************************************/
:- table '_$_$_flora_exists'/1.
:- table '_$_$_flora_mvd'/2.
:- table '_$_$_flora_imvd'/2.

'_$_$_flora_exists'(X) :- '_$_$_flora_fd'(X,_,_).
'_$_$_flora_exists'(X) :- '_$_$_flora_fd'(_,_,X).
'_$_$_flora_exists'(X) :- '_$_$_flora_mvd'(X,_,_).
'_$_$_flora_exists'(X) :- '_$_$_flora_mvd'(_,_,X).
'_$_$_flora_exists'(X) :- '_$_$_flora_ifd'(X,_,_).
'_$_$_flora_exists'(X) :- '_$_$_flora_ifd'(_,_,X).
'_$_$_flora_exists'(X) :- '_$_$_flora_imvd'(X,_,_).
'_$_$_flora_exists'(X) :- '_$_$_flora_imvd'(_,_,X).
'_$_$_flora_exists'(X) :- '_$_$_flora_isa'(X,_).
'_$_$_flora_exists'(X) :- '_$_$_flora_isa'(_,X).
'_$_$_flora_exists'(X) :- '_$_$_flora_sub'(X,_).
'_$_$_flora_exists'(X) :- '_$_$_flora_sub'(_,X).

'_$_$_flora_exists'(X) :-
	'_$_$_flora_fd'(_,M,_),
	M =.. [_|L],
	member(X,L).

'_$_$_flora_exists'(X) :-
	'_$_$_flora_mvd'(_,M,_),
	M =.. [_|L],
	member(X,L).

'_$_$_flora_exists'(X) :-
	'_$_$_flora_ifd'(_,M,_),
	M =.. [_|L],
	member(X,L).

'_$_$_flora_exists'(X) :-
	'_$_$_flora_imvd'(_,M,_),
	M =.. [_|L],
	member(X,L).


'_$_$_flora_mvd'(O,M) :- '_$_$_flora_mvd'(O,M,_).

'_$_$_flora_imvd'(O,M) :- '_$_$_flora_imvd'(O,M,_).


/*****************************************************************************
  rules for flattened path expressions on RHS
*****************************************************************************/
'_$_$_flora_fd_rhs'(O,M,R)   :- '_$_$_flora_fd'(O,M,R).
'_$_$_flora_mvd_rhs'(O,M,R)  :- '_$_$_flora_mvd'(O,M,R).
'_$_$_flora_ifd_rhs'(O,M,R)  :- '_$_$_flora_ifd'(O,M,R).
'_$_$_flora_imvd_rhs'(O,M,R) :- '_$_$_flora_imvd'(O,M,R).
'_$_$_flora_mvd_rhs'(O,M)    :- '_$_$_flora_mvd'(O,M).
'_$_$_flora_imvd_rhs'(O,M)   :- '_$_$_flora_imvd'(O,M).
'_$_$_flora_isa_rhs'(O1,O2)  :- '_$_$_flora_isa'(O1,O2).
'_$_$_flora_sub_rhs'(O1,O2)  :- '_$_$_flora_subclass'(O1,O2).
'_$_$_flora_fs_rhs'(O,M,R)   :- '_$_$_flora_fs'(O,M,R).
'_$_$_flora_mvs_rhs'(O,M,R)  :- '_$_$_flora_mvs'(O,M,R).


/********************************************************************/
