/*  -*-c-*-  Make sure this file comes up in the C mode of emacs */ 
/* File:      dyncoff.i
** Author(s): Steve Dawson, Jiyang Xu, Kostis Sagonas
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1986, 1993-1998
** Copyright (C) ECRC, Germany, 1990
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id$
** 
*/


/* Code specific to the DJGPP port has been #ifdef-ed in order to
   identify portions that will likely need modification for other
   systems using COFF, which is not to say that other portions
   won't need modification... */

#include <coff.h>
#include <sys/file.h>
#include <sys/types.h>
#include <sys/stat.h>
/* special.h must be included after sys/stat.h */
#include "configs/special.h"
#include <errno.h>
#include <stdio.h>

#include "auxlry.h"
#include "cell.h"
#include "memory.h"
#include "inst.h"
#include "psc.h"
#include "xsberror.h"
#include "io_builtins.h"

#ifdef DJGPP
#define e_name e.e_name
#define e_zeroes e.e.e_zeroes
#define e_offset e.e.e_offset
#else
/* whatever */
#endif

#define BUFFEXTRA 1024

char tfile[128];	/* uniquely-named tmp file for "ld" */

extern byte proceed_inst;

byte *load_obj_dyn(pofilename, cur_mod, ld_option)
char *pofilename, *ld_option;
Psc cur_mod;
{
	int i, buffsize, fd, error_occur = 0, loadsize;
	char buff[256], subfile[128];
	struct stat statbuff;
	byte *text_start;
	FILHDR fhdr;
	SCNHDR thdr, dhdr, bhdr;
	SYMENT *symtab;

	sprintf(tfile, "/tmp/xsb-dyn.%ld", getpid());

      /* first step: get the header entries of the *.o file in order
	 to obtain the size of the object code, and then allocate space
	 for it. */
        if (strlen(pofilename) >= 127) return 0;
	strcpy(subfile, pofilename);
#ifdef DJGPP
	subfile[strlen(subfile)-1] = 0;		/* change *.OX to *.O */
	subfile[strlen(subfile)-1] = 'o';	/* change *.O to *.o */
	fd = open(subfile, O_RDONLY | O_BINARY, 0);
#else
	/* the likely code for un*x systems */
	subfile[strlen(subfile)-1] = 'o';	/* change *.O to *.o */
	fd = open(subfile, O_RDONLY, 0);
#endif
	if (fd < 0) {
	    xsb-endif("Cannot find the C object file: %s", subfile);
	    return 0;
	}
	read(fd, &fhdr, FILHSZ);	/* read file header */
	/* could put some sanity checks here */
	lseek(fd, fhdr.f_opthdr, 1);	/* skip over any optional header */
	read(fd, &thdr, SCNHSZ);	/* read text section header */
	read(fd, &dhdr, SCNHSZ);	/* read data section header */
	read(fd, &bhdr, SCNHSZ);	/* read bss section header */
	close(fd);

	/* second step: run incremental ld and generate a temporary
	   object file (including orginal *.o and libraries) ready to be
	   read in. */
	buffsize = thdr.s_size + dhdr.s_size + bhdr.s_size;
	text_start = (byte *)mem_alloc(buffsize);
#ifdef DJGPP
	/* should do something about the library search path */
	sprintf(buff, "ld -N -r -R %s -Ttext %x -o %s %s %s -L/djgpp/lib -lc", 
		executable, text_start, tfile, subfile, ld_option);
#else
	/* whatever */
#endif
	if (strlen(buff) > 510) {
	    xsb_error("Buffer for ld command is too small");
            exit (-1);
	}
	system(buff);

	/* third step: check if the size of the buffer just allocated is
	   big enough to load the object (when the object code uses other
	   libraries, the buffer may not be big enough).  If this is the
	   case, redo the second step with a bigger buffer. */
#ifdef DJGPP
	fd = open(tfile, O_RDONLY | O_BINARY, 0);
#else
	fd = open(tfile, O_RDONLY, 0);
#endif
	if (fd < 0) {
	    xsb_error("The file is not generated by the loader");
	    return 0;
	}
	read(fd, &fhdr, FILHSZ);	/* read file header */
	/* could put some sanity checks here */
	lseek(fd, fhdr.f_opthdr, 1);	/* skip over any optional header */
	read(fd, &thdr, SCNHSZ);	/* read text section header */
	read(fd, &dhdr, SCNHSZ);	/* read data section header */
	read(fd, &bhdr, SCNHSZ);	/* read bss section header */
	loadsize = thdr.s_size + dhdr.s_size + bhdr.s_size;
	if (loadsize > buffsize) {
	  close(fd);
	  mem_dealloc(text_start, buffsize);
	  text_start = (byte *)mem_alloc(loadsize+BUFFEXTRA);
#ifdef DJGPP
	  sprintf(buff, "ld -N -r -R %s -Ttext %x -o %s %s %s -L/djgpp/lib -lc",
		executable, text_start, tfile, subfile, ld_option);
#else
	  /* whatever */
#endif
	  system(buff);
#ifdef DJGPP
	  fd = open(tfile, O_RDONLY | O_BINARY, 0);
#else
	  fd = open(tfile, O_RDONLY, 0);
#endif
	  read(fd, &fhdr, FILHSZ);
	  lseek(fd, fhdr.f_opthdr, 1);	/* skip over any optional header */
	  read(fd, &thdr, SCNHSZ);
	  read(fd, &dhdr, SCNHSZ);
	 }

	/* fourth step: read in the intermediate object files.		*/
	/* load text and data segment */
	lseek(fd, thdr.s_scnptr, 0);
	read(fd, text_start, thdr.s_size+dhdr.s_size);

	/* load symbol table and string table */
	fstat(fd, &statbuff);
	loadsize = statbuff.st_size - fhdr.f_symptr;
	symtab = (SYMENT *)mem_alloc(loadsize);
	lseek(fd, fhdr.f_symptr, 0);
	read(fd, symtab, loadsize);
	close(fd);

	/* fifth step: link C procedure names with Prolog names. */
	dyn_link_all(symtab, fhdr.f_nsyms, cur_mod);
	mem_dealloc((byte *)symtab, loadsize);
	return &proceed_inst;
}

bool dummy()
{
    xsb_error("Trying to use an undefined foreign procedure");
    return FALSE;
}

dyn_link_all(symtab, nsyms, cur_mod)
SYMENT *symtab;
int nsyms;
Psc cur_mod;
{
  int i, value;
  char *ptr, *strtab;
  char *name;
  Pair search_ptr;

  strtab = (byte *)symtab + nsyms*SYMESZ;
  search_ptr = (Pair)get_ep(cur_mod);
  while (search_ptr) {
    name = get_name(search_ptr->psc_ptr);
/* Jiyang changed it to the form ``module_pred'':
    sprintf(name, "%s_%s", get_name(cur_mod), get_name(search_ptr->psc_ptr));
 */
    if (get_type(search_ptr->psc_ptr) == T_FORN) {
      for (i=0; i<nsyms; i++) {
	if (!symtab[i].e_zeroes) {
	  ptr = strtab + symtab[i].e_offset;
	  if (*ptr++ == '_' && strcmp(name, ptr)==0) { 
	    set_ep(search_ptr->psc_ptr, (byte *)(symtab[i].e_value));
	    break;
	   }
	 }
	else {
	  ptr = symtab[i].e_name;
	  if (*ptr++ == '_' && strncmp(name, ptr, E_SYMNMLEN-1) == 0) {
	    set_ep(search_ptr->psc_ptr, (byte *)(symtab[i].e_value));
	    break;
	   }
	 }
	i += symtab[i].e_numaux;	/* skip auxiliary entries */
       }
      if (i>= nsyms) {          /* does not find the name */
	  xsb_warn("Cannot find foreign procedure %s", name);
	  set_ep(search_ptr->psc_ptr, (byte *)(dummy));
       }
     }
    search_ptr = search_ptr->next;
  }
  return 0;
}
