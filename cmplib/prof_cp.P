/* File:      prof_cp.P
** Author(s): Saumya Debray
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1986, 1993-1998
** Copyright (C) ECRC, Germany, 1990
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id$
** 
*/


compile(F) :- consult(F).

/*======================================================================*/
/* prepare for compiler and type inference				*/
/*======================================================================*/
prepare :- 'profile$loaded', !.
prepare :-
	op(1050,fy,(import)),
	op(1050,xfx, (from)),
	op(1100,fx,(index)),
	op(1100,fx,(export)),
	op(1200,fx,(':=')),
	( retract(gennum_val(_)), fail
	; assert(gennum_val(300))		/* for gennum and gensym */
	),
	assert('profile$loaded').

/*======================================================================*/
/* The following predicates may be standard in some variation of Prolog,*/
/* may have different meanings.						*/
/*   Include here for compatibility.					*/
/*======================================================================*/

/*----member------------------------------------------------------------*/
member(X,[X|L]).
member(X,[Y|L]) :- member(X,L).

/*----otherwise---------------------------------------------------------*/
otherwise.

/*----name_append-------------------------------------------------------*/
name_append(C1, C2, C3) :- atom(C1), atom(C2), !,
	name(C1, N1),
	name(C2, N2),
	append(N1, N2, N3),
	name(C3, N3).
name_append(C1, C2, C3) :- atom(C2), atom(C3),  !,
	name(C3, N3),
	name(C2, N2),
	append(N1, N2, N3),
	name(C1, N1).

/*----append------------------------------------------------------------*/
append([], L, L).
append([X|L1], L2, [X|L3]) :- append(L1, L2, L3).

/*----cputiem-----------------------------------------------------------*/
/*cputime(X) :- X is cputime.*/

/*----conlength---------------------------------------------------------*/
conlength(Con, Length) :- name(Con, Name), length(Name, Length).

/*----gennum------------------------------------------------------------*/
gennum(N) :- retract(gennum_val(X)), N is X + 1, assert(gennum_val(N)).

/*----gensym------------------------------------------------------------*/
gensym(R, C) :- gennum(N), name(N, N1), name(R, N2), append(N1, N2, N3),
	name(C, N3).

/*----copyterm----------------------------------------------------------*/
/* Get a copy of the Term, with a new set of variables.			*/

copyterm(Term, NewTerm) :- copyterm(Term, NewTerm, _).

copyterm(Term, NewTerm, VarDict) :- var(Term), !,
	dict_lookup(Term, NewTerm, VarDict).
copyterm(Term, Term, _) :- atomic(Term), !.
copyterm(Term, NewTerm, VarDict) :- 
	functor(Term, Func, Arity),
	functor(NewTerm, Func, Arity),
	copyterm_args(Term, NewTerm, Arity, VarDict).

copyterm_args(_, _, 0, _) :- !.
copyterm_args(Term, NewTerm, N, VarDict) :-
	arg(N, Term, Arg),
	copyterm(Arg, NewArg, VarDict),
	arg(N, NewTerm, NewArg),
	N1 is N - 1,
	copyterm_args(Term, NewTerm, N1, VarDict).

/*----numbervars--------------------------------------------------------*/
numbervars(Y,I,J) :- var(Y),!,Y='$var'(I),J is I+1.
numbervars(Y,I,J) :- functor(Y,_,N),numbervars(Y,I,J,0,N).

numbervars(_,I,I,N,N) :- !.
numbervars(Y,I,J,C,N) :- C1 is C+1, arg(C1,Y,A),numbervars(A,I,I1),
        numbervars(Y,I1,J,C1,N).

myclose(F) :- close(F).

conset(Con, Val) :- retract(conset_val(Con, _)), fail.
conset(Con, Val) :- assert(conset_val(Con, Val)).

conget(Con, Val) :- conset_val(Con, Val).

ttywrite(X) :- telling(F), tell(user), write(X), tell(F).

ttywritenl(X) :- telling(F), tell(user), ttywritenl0(X), nl, tell(F).

ttywritenl0(X) :- var(X), !, write(X).
ttywritenl0((X,Y)) :- !, ttywritenl0(X), ttywritenl0(Y).
ttywritenl0(X) :- write(X).

real(X) :- number(X), not integer(X).

write_int(Num) :- write_int(Num, 4).

write_int(Num, 1) :- put(Num).
write_int(Num,Nbytes) :-
		Byte is Num /\ 255,
		Rest is Num >> 8,
		N is Nbytes - 1,
		write_int(Rest,N),
		put(Byte).

write_float(X) :- error(('Floating point is not implemented for CProlog')),
	abort.

/*======================================================================*/
/* counter routines. A counter is a unary term.				*/
/*======================================================================*/

newcounter(C) :-  error('Counters are not implemented for CProlog'), abort.
inccounter(C) :- error('Counters are not implemented for CProlog'), abort.
getcounter(C) :- error('Counters are not implemented for CProlog'), abort.
