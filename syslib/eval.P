/* File:      eval.P
** Author(s): David S. Warren, Kostis F. Sagonas
** Contact:   xsb-contact@cs.sunysb.edu
** *
** Copyright (C) The Research Foundation of SUNY, 1993-1998
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id$
** 
*/

:- compiler_options([xpp_on,optimize,sysmod]).

#include "celltags_xsb.h"

%-------------------------------------------------------------------------
% NOTE:	Predicate eval/2 is the one who is responsible for error checking
%	of arithmetic comparisons and evaluations. According to the Prolog
%	standard, arithmetic comparisons and evaluations can cause overflow
%       and
%	instantiation errors ONLY. Everything else should simply fail as
%	far as evaluation is concerned.
%-------------------------------------------------------------------------
% NOTE: According to the Prolog standard, predicate eval/2 should perform 
%	type conversion between integers and reals when necessary. 
%	Our eval/2, does NOT. (mainly because at the moment when this is
%	written it is not clear whether we will support reals in the first
%	XSB version).
%-------------------------------------------------------------------------

eval(Expr, Res) :- 
	eval(Expr,Res,Expr).

eval(Arg, Res,Expr) :- 
	term_type(Arg, T), 
	((T =:= XSB_FREE; T =:= XSB_ATTV) ->
	    eval_instantiation_abort(Expr)
	; T =:= XSB_INT -> Res=Arg
	; T =:= XSB_FLOAT -> Res=Arg
	; (T =:= XSB_STRING; T =:= XSB_LIST) ->
	    abort(['Type Error: Non evaluable arithmetic expression:',Expr])	
	; eval0(Arg, Res,Expr) -> true	/* system defined function */
	; T =:= XSB_STRUCT -> eval1(Arg, Res)	/* user defined function */
	).

/* TLS: we are now more ISO-compatable for fp-to-integer rouinding
functions, 9.1.5.1.  To be completely compatable, we'd have to check for
overflow.  */
eval0('+'(X,Y), Res,Expr) :- eval(X, Res1,Expr), 
		eval(Y,Res2,Expr), Res is Res1 + Res2.  
eval0('-'(X,Y), Res,Expr) :- eval(X, Res1,Expr), 
		eval(Y, Res2,Expr), Res is Res1 - Res2.  
eval0('*'(X,Y), Res,Expr) :- eval(X,Res1,Expr), 
		eval(Y, Res2,Expr), Res is Res1 * Res2.  
eval0('/'(X,Y), Res,Expr) :- eval(X, Res1,Expr), 
		eval(Y, Res2,Expr), Res is Res1 / Res2.  
eval0('//'(X,Y),Res,Expr) :- eval(X, Res1,Expr), 
		eval(Y, Res2,Expr), Res is Res1 // Res2.
eval0(rem(X,Y), Res,Expr) :- eval(X, Res1,Expr), 
		eval(Y, Res2,Expr), Res is Res1 rem Res2.  
eval0(mod(X,Y), Res,Expr) :- eval(X, Res1,Expr), 
		eval(Y, Res2,Expr), Res is Res1 mod Res2.  
eval0('/\'(X,Y), Res,Expr) :- eval(X, Res1,Expr), 
		eval(Y, Res2,Expr), Res is Res1 /\ Res2.  
eval0('\/'(X,Y), Res,Expr) :- eval(X, Res1,Expr), 
		eval(Y, Res2,Expr), Res is Res1 \/ Res2.  
eval0('<<'(X,Y), Res,Expr) :- eval(X, Res1,Expr), 
		eval(Y, Res2,Expr), Res is Res1 << Res2.  
eval0('>>'(X,Y), Res,Expr) :- eval(X, Res1,Expr), 
eval(Y,Res2), Res is Res1 >> Res2.  
eval0('-'(X), Res,Expr) :- eval(X, Res1,Expr), Res is -(Res1).
eval0('\'(X), Res,Expr) :- eval(X, Res1,Expr), Res is '\'(Res1).  
eval0(float(X), Res,Expr) :- eval(X, Res1,Expr), Res is float(Res1).  
eval0(floor(X), Res,Expr) :- eval(X, Res1,Expr), Res is floor(Res1).  
eval0(abs(X),Res,Expr) :- eval(X, Res1,Expr), Res is abs(Res1).  
eval0(truncate(X),Res,Expr) :- eval(X, Res1,Expr), Res is truncate(Res1).  
eval0(round(X),Res,Expr) :- eval(X, Res1,Expr), Res is round(Res1).  
eval0(ceiling(X),Res,Expr) :- eval(X, Res1,Expr), Res is ceiling(Res1).  
eval0(sin(X), Res,Expr) :- eval(X, Res1,Expr), Res is sin(Res1).
eval0(cos(X), Res,Expr) :- eval(X, Res1,Expr), Res is cos(Res1).
eval0(tan(X), Res,Expr) :- eval(X, Res1,Expr), Res is tan(Res1).
eval0(asin(X), Res,Expr) :- eval(X, Res1,Expr), Res is asin(Res1).
eval0(acos(X), Res,Expr) :- eval(X, Res1,Expr), Res is acos(Res1).
eval0(atan(X), Res,Expr) :- eval(X, Res1,Expr), Res is atan(Res1).
eval0(exp(X), Res,Expr) :- eval(X, Res1,Expr), Res is exp(Res1).
eval0(log(X), Res,Expr) :- eval(X, Res1,Expr), Res is log(Res1).
eval0(log10(X), Res,Expr) :- eval(X, Res1,Expr), Res is log10(Res1).
eval0(sqrt(X), Res,Expr) :- eval(X, Res1,Expr), Res is sqrt(Res1).

eval1(Term, Res) :-
	term_psc(Term, Psc),
	psc_type(Psc, T0),
	( T0 =:= 15 ->		% unloaded function
	    psc_prop(Psc, ModPSC),
            psc_name(ModPSC, ModName),
            psc_type(ModPSC, ModType),
            ( ModType =:= 4
            ; ModType =\= 4,              % module is not loaded yet
              load(ModName)               % can fail here
            )
	; true
	),
	psc_type(Psc, T1),
	( T1 =\= 14, eval_regularterm(Term, Res)	 % Regular term
	; T1 =:= 14,
	  abort('Invalid term in arithmetic expression')
% no longer support user-defined functions
%          psc_prop(Psc, Code),
%	  eval_func(Code, Term, T1),
%	  '_$getreturn'(Res)
	).

/* need this because code_call/3 must be the last goal of a clause.
no longer support user-defined functions
eval_func(Code, Term, T1) :- code_call(Code, Term, T1).  
*/

eval_regularterm(Term, Res) :-
	functor(Term, F, A),
	functor(Res, F, A),
	eval_rt_args(0, A, Term, Res).

eval_rt_args(A, A, _, _).
eval_rt_args(I, A, Term, Res) :- I < A,
	I1 is I + 1,
	arg(I1, Term, X),
	arg(I1, Res, Y),
	eval(X, Y),
	eval_rt_args(I1, A, Term, Res).

/* TLS this is to get us around a second error message when expr is
   uninstantiated */
eval_instantiation_abort(Expr):- 
	var(Expr),!,
	abort(['Type Error: Uninstantiated Arithmetic Expression']).
eval_instantiation_abort(Expr):- 
	abort(['Type Error: Unbound variable in arithmetic expression',Expr]).


/* ---------------------- end of file eval.P --------------------------	*/
