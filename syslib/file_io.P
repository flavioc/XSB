/* File:      file_io.P
** Author(s): kifer
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1999
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id$
** 
*/

:- compiler_options([xpp_on,sysmod]).
#include "io_defs_xsb.h"
#include "system_defs_xsb.h"
#include "standard.h"
#include "flag_defs_xsb.h"
#include "psc_defs.h"
#include "builtin.h"


	       /********************************/
	       /*  Formatted I/O    	       */
	       /********************************/

fmt_write(Fmt, Args) :-
       stat_flag(CURRENT_OUTPUT, IOport),   % Current output
	fmt_write(IOport, Fmt, Args).

fmt_write(IOport, Fmt, Args) :-
	formatted_io(FMT_WRITE, IOport, Fmt, Args, _Ret).

fmt_write_string(Str, Fmt, Args) :-
	formatted_io(FMT_WRITE_STRING, Str, Fmt, Args, _Ret).


fmt_read(Fmt,Result,Status) :-
        stat_flag(CURRENT_INPUT, IOport),  % Current input
	fmt_read(IOport, Fmt,Result,Status).

fmt_read(IOport, Fmt, Result, Status) :-
	formatted_io(FMT_READ, IOport, Fmt, Result, Status).


/***************************************************************/
/*    	      	      	      	      	      	      	       */
/*       file_flush, file_seek, file_truncate, file_pos, etc.  */
/*    	      	      	      	      	      	      	       */
/***************************************************************/

file_flush(IOport, Ret) :-
	file_function(FILE_FLUSH, IOport, Ret, _D, _E, _,_).
file_seek(IOport, Offset, Place, Ret) :-
	file_function(FILE_SEEK, IOport, Offset, Place, Ret, _,_).
file_truncate(IOport, Length, Ret) :-
	file_function(FILE_TRUNCATE, IOport, Length, Ret, _E, _,_).
file_pos(IOport, Pos) :-
	file_function(FILE_POS, IOport, Pos, _Ret, _E, _,_).
file_open(FileName, Mode_in, IOport) :-
	preserve_numeric_calls(Mode_in,Mode),
	file_function(XSB_FILE_OPEN, FileName, Mode, IOport, _E, _,_).
/* TLS: file_close/1 is obsolescent */
file_close(IOport) :-
	file_function(FILE_CLOSE,IOport,NOFORCE_FILE_CLOSE,_Y,_Z, _,_).
file_close(IOport,Force) :-
	file_function(FILE_CLOSE,IOport,Force,_Y,_Z, _,_).
file_get(IOport,Char) :-
	file_function(FILE_GET, IOport, Char, _X, _Y, _,_).
file_put(IOport,Char) :-
	file_function(FILE_PUT, IOport, Char, _X, _Y, _,_).
file_clearerr(IOport) :-
	file_function(FILE_CLEARERR, IOport, _, _, _, _, _).
tmpfile_open(IOport) :-
	file_function(TMPFILE_OPEN, IOport, _, _, _, _, _).

preserve_numeric_calls(0,r):- !.
preserve_numeric_calls(1,w):- !.
preserve_numeric_calls(2,a):- !.
preserve_numeric_calls(3,sr):- !.
preserve_numeric_calls(X,X).

%----------------------------------------------------------------------------------------------------

file_getbuf(IOport, ByteCount, ToAtom, BytesRead) :-
	(var(ToAtom), var(BytesRead) ->
	    file_function(FILE_GETBUF, IOport,ByteCount,ToAtom,BytesRead,_,_)
	; abort('Usage: file_getbuf([+IOport,] +ByteCount, -ToAtom, -BytesRead)')
        ).

%% same as file_getbuf
file_getbuf_atom(IOport, ByteCount, ToAtom, BytesRead) :-
	(var(ToAtom), var(BytesRead) ->
	    file_function(FILE_GETBUF, IOport,ByteCount,ToAtom,BytesRead,_,_)
	; abort('Usage: file_getbuf_atom([+IOport,] +ByteCount, -ToAtom, -BytesRead)')
        ).

file_getbuf_atom(ByteCount, ToAtom, BytesRead) :-
	stat_flag(CURRENT_INPUT, IOport),
	(var(ToAtom), var(BytesRead) ->
	    file_function(FILE_GETBUF, IOport,ByteCount,ToAtom,BytesRead,_,_)
	; abort('Usage: file_getbuf_atom([+IOport,] +ByteCount, -ToAtom, -BytesRead)')
        ).

file_getbuf_list(IOport, ByteCount, ToList, BytesRead) :-
	(var(ToList), var(BytesRead) ->
	    file_function(FILE_GETBUF, IOport,ByteCount,TmpStr,BytesRead,_,_),
	    atom_codes(TmpStr, ToList)
	;
	abort('Usage: file_getbuf_list([+IOport,] +ByteCount, -ToList, -BytesRead)')).

file_getbuf_list(ByteCount, ToList, BytesRead) :-
	stat_flag(CURRENT_INPUT, IOport),
	(var(ToList), var(BytesRead) ->
	    file_function(FILE_GETBUF, IOport,ByteCount,TmpStr,BytesRead,_,_),
	    atom_codes(TmpStr, ToList)
	;
	abort('Usage: file_getbuf_list([+IOport,] +ByteCount, -ToList, -BytesRead)')).

file_putbuf(IOport, ByteCount, FromString, Offset, BytesWritten) :-
	(var(BytesWritten) ->
	    file_function(FILE_PUTBUF, IOport,ByteCount,FromString,Offset,BytesWritten,_)
	;
	abort('Usage: file_putbuf([+IOport,] +ByteCount, +FromString, +Offset, -BytesWritten)')
    ).

file_putbuf(ByteCount, FromString, Offset, BytesWritten) :-
	stat_flag(CURRENT_OUTPUT, IOport),
	(var(BytesWritten) ->
	    file_function(FILE_PUTBUF, IOport,ByteCount,FromString,Offset,BytesWritten,_)
	; abort('Usage: file_putbuf([+IOport,] +ByteCount, +FromString, +Offset, -BytesWritten)')
	).


file_read_line(IOport, Str) :-
	( var(Str) ->
	    file_function(FILE_READ_LINE, IOport, Str, _, _, _,_)
	; abort('Usage: file_read_line(+IOport, -InputStr)')
        ).

%% same as file_read_line
file_read_line_atom(IOport, Str) :-
	( var(Str) ->
	    file_function(FILE_READ_LINE, IOport, Str, _, _, _,_)
	; abort('Usage: file_read_line_atom([+IOport,] -InputStr)')
        ).

%% Read line from current input stream (previously set by 'see')
file_read_line_atom(Str) :-
	stat_flag(CURRENT_INPUT, IOport),  % Current input
	file_read_line_atom(IOport, Str).

%% Like file_read_line_atom, but returns list of characters
file_read_line_list(IOport, CharLst) :-
	( var(CharLst) ->
	    file_function(FILE_READ_LINE_LIST, IOport, CharLst, _, _, _,_)
	; abort('Usage: file_read_line_list([+IOport,] -InputStr)')
        ).

%% Read line from current input stream (previously set by 'see')
%% Return list of chars
file_read_line_list(Lst) :-
	stat_flag(CURRENT_INPUT, IOport),  % Current input
	file_read_line_list(IOport, Lst).

%% Write Str out to IOport. Str must be atom or list of chars.
%% This is checked in C, by the builtin.
file_write_line(IOport, Str, Offset) :-
	file_function(FILE_WRITE_LINE, IOport, Str, Offset, _,_,_).

%% Same as file_write_line/3, but write to current output
file_write_line(Str, Offset) :-
	stat_flag(CURRENT_OUTPUT, IOport),  % Current output
	file_function(FILE_WRITE_LINE, IOport, Str, Offset, _,_,_).


/* Fancy stuff */
%% Like freopen
file_reopen(FileName, Mode, IOport,ErrCode) :-
	file_function(FILE_REOPEN, FileName,  Mode, IOport, ErrCode,_,_).

%% Like dup/dup2: make DestIOport into the same file descriptor as SrcIOport
%% If DestIOport is var, then behaves like dup; else like dup2 
%% (and then expects DestIOport to be a file descriptor).
%% ErrCode=0 - ok
file_clone(SrcIOport, DestIOport, ErrorCode) :-
	file_function(FILE_CLONE, SrcIOport, DestIOport, ErrorCode,_,_,_).

%% Open pipe. ReadPipe is for reading from pipe,
%% WritePipe is for writing to the pipe.
pipe_open(ReadPipe, WritePipe) :-
	file_function(PIPE_OPEN, ReadPipe, WritePipe, _,_,_,_).

%% Convert pipe into an XSB file descriptor.
%% This should be done on both ends: by the parent XSB process and by 
%% the child XSB process
fd2ioport(Pipe, IOport) :-
	file_function(FD2IOPORT, Pipe, IOport,"u",_,_,_).
fd2iostream(Pipe, Mode,IOstream) :-
	file_function(FD2IOPORT, Pipe, IOstream,Mode,_,_,_).


/***************************************************************
**
** print_file_contents/1
**
****************************************************************/

print_file_contents(Filename) :-
	stat_flag(CURRENT_OUTPUT, ToIOport),  % current output
	print_file_contents(Filename, ToIOport).

print_file_contents(FileName, ToIOport) :-
	file_open(FileName, r, FromIOport),
	copyIOport(FromIOport, ToIOport),
	file_close(FromIOport).
copyIOport(FromIOport, ToIOport) :-
	repeat,
	(file_read_line(FromIOport, Line) 
	-> file_write(ToIOport, Line),fail
	; true
	), !.
copyIOport(_,_).

/***************************************************************/

% TLS: changed to allow users to call with Time either time(A,B) or as var.
file_time(FileName, Time) :-
	Time = time(_,_),
	sys_system(STAT_FILE_TIME,FileName,Time, _,_,_,_).

file_size(FileName, Size) :-
	sys_system(STAT_FILE_SIZE,FileName,[H,L], _,_,_,_),
	Size is L + (H << 16).


/************************************************************************
    	    	Path Operations
************************************************************************/

%% These fail if the op doesn't succeed
path_sysop(isplain, Path) :- !, is_plain_file(Path).
path_sysop(isdir, Path) :- !, is_directory(Path).
path_sysop(rename, OldPath, NewPath) :- !, rename(OldPath,NewPath).
path_sysop(copy, FromPath, ToPath) :- !,
	sys_filecopy(FromPath,ToPath,Res), Res=:=0.
	/*
	file_open(FromPath, r, FromIOport),
	FromIOport >= 0,
	file_open(ToPath, w, ToIOport),
	ToIOport >= 0,
	copyIOport(FromIOport, ToIOport),
	file_close(ToIOport),
	file_close(FromIOport).
        */
path_sysop(rm, Path) :- !, rm(Path).
path_sysop(unlink, Path) :- !, rm(Path).
path_sysop(link, SrsPath, DestPath) :- !,
	sys_link(SrsPath,DestPath,Res), Res=:=0.
path_sysop(cwd, Path) :- !, cwd(Path).
path_sysop(chdir, Path) :- !, cd(Path).
path_sysop(mkdir, Path) :- !, sys_mkdir(Path,Res), Res=:=0.
path_sysop(rmdir, Path) :- !, sys_rmdir(Path,Res), Res=:=0.
path_sysop(rmdir_rec, Path) :- !, rmdir_rec(Path).
path_sysop(exists, Path) :- !, file_exists(Path).
path_sysop(readable, Path) :- !, sys_access(Path, 'r', Res), Res =:= 0.
path_sysop(writable, Path) :- !, sys_access(Path, 'w', Res), Res =:= 0.
path_sysop(executable, Path) :- !, sys_access(Path, 'x', Res), Res =:= 0.
path_sysop(modtime,Path,Time) :- !,
	file_time(Path,time(Time1,Time2)), Time = [Time1,Time2], Time \= [0,0].
path_sysop(newerthan,Path1,Path2) :- !,
	file_time(Path1,time(Time11,Time12)),
	file_time(Path2,time(Time21,Time22)),
	time(Time11,Time12) @>= time(Time21,Time22).
path_sysop(size,Path,Size) :- !,
	sys_system(STAT_FILE_SIZE,Path,Size, _,_,_,_).
path_sysop(tmpfilename,TmpName) :- !,
	sys_system(GET_TMP_FILENAME,TmpName,_,_,_,_,_).
path_sysop(extension,Filename,Extension) :- !,
	parse_filename(Filename,_,_,Extension).
path_sysop(basename,Filename,Basename) :- !,
	parse_filename(Filename,_,Basename,_).
path_sysop(dirname,Filename,Dirname) :- !,
	parse_filename(Filename,Dirname,_,_).
path_sysop(isabsolute,Filename) :- !,
	is_absolute_filename(Filename).
path_sysop(expand,Filename,ExpandedName) :- !,
	expand_filename(Filename,ExpandedName).
path_sysop(X,_,_) :- abort(('[PATH_SYSOP]: Invalid request for path_sysop/3, ', X)).
path_sysop(X,_) :- abort(('[PATH_SYSOP]: Invalid request for path_sysop/2, ', X)).


%----------------------------------------------------------------------------------------------------
% Stream and Alias Checking.
%----------------------------------------------------------------------------------------------------
/* 
is_valid_stream/2: assumes integer, checks that the stream is valid
with mode input or output.

check_stream_or_alias/4 checks if stream term or alias is valid and
raises exception otherwise.

check_open_stream_or_alias/5 checks if stream or alias is valid for
mode, and raises exception otherwise.

check_enumerate_stream_or_alias/4: if bound,
check_valid_open_stream_or_alias.  If variable, backtracks through the
valid streams.

current_stream_or_alias/1: if integer, checks that the S_or_A is valid, and
fails otherwise. If variable, backtracks through the valid streams.

*/

%-----
is_valid_stream(Stream) :- 
	is_valid_stream(Stream,_).

is_valid_stream(Stream,Mode) :-
	file_function(IS_VALID_STREAM, Stream, M, _, _, _, _),
	(M =:= 0 -> Mode = input ; Mode = output).

%-----
check_stream_or_alias(S_or_A,Predicate,Arg,Stream) :- 
	(integer(S_or_A) -> 
	    Stream = S_or_A
	;
	    (atom(S_or_A) -> 
	        '_$alias'(S_or_A,Stream)
	    ;  domain_error(stream_or_alias,S_or_A,Predicate,Arg) ) ).

:- dynamic '_$alias_dynamic'/2.

'_$alias'(userin,0).
'_$alias'(user_in,0).
'_$alias'(userout,1).
'_$alias'(user_out,1).
'_$alias'(In,Out):-  '_$alias_dynamic'(In,Out).

add_alias(Alias,Stream):- 
	asserta('_$alias_dynamic'(Alias,Stream)).

%-----
check_open_stream_or_alias(S_or_A,Predicate,Arg,Mode,Stream) :- 
	check_stream_or_alias(S_or_A,Predicate,Arg,Stream),
            (is_valid_stream(Stream,Mode) -> 
	        true
	      ; existence_error(Mode-stream,Stream,Predicate,Arg) ).

%-----
check_enumerate_stream_or_alias(S_or_A,Predicate,Arg,Stream):- 
	(integer(S_or_A) -> 
	    (is_valid_stream(S_or_A) -> 
		true
	      ;     existence_error(stream,S_or_A,Predicate,Arg))
	    ; (atom(S_or_A) -> 
	          '_$alias'(S_or_A,Stream),
	          (is_valid_stream(Stream) -> 
		 true
	           ; existence_error(stream,S_or_A,Predicate,Arg) )
  	        ; (var(Stream) -> 
	             for(Stream,0,MAX_OPEN_FILES),
	             is_valid_stream(Stream)
	          ; domain_error(stream_or_alias_or_variable,Stream,
		                    check_enumerate_stream_or_alias/1,1) ) ) ).

%-----
/* Checks a stream or enumerates. Failure */
current_stream_or_alias(S_or_A,Stream):- 
	(integer(S_or_A) -> 
	   is_valid_stream(S_or_A),S_or_A = Stream
             ; (atom(S_or_A) -> 
	      '_$alias'(S_or_A,Stream),
 	      is_valid_stream(S_or_A)
 	    ; (var(S_or_A) -> 
	         for(Stream,0,MAX_OPEN_FILES),
	         is_valid_stream(Stream)
	       ; domain_error(stream_or_alias_or_variable,Stream,
	                             current_stream_or_alias/1,1) ) ) ).

%---------------------------------------------------------------------------------------------------
% ISO Predicates.
%---------------------------------------------------------------------------------------------------

% TLS: Debugging predicate that will soon be obsolete.
print_openfiles:- file_function(PRINT_OPENFILES,_,_,_,_,_,_).

peek_code(S_or_A,Code):- 
	check_open_stream_or_alias(S_or_A,at_end_of_file/1,1,_Mode,Str),
	file_function(FILE_PEEK,Str,Ret,_Y,_Z, _,_),
	Ret = Code.

peek_code(Code):- 
	stat_flag(CURRENT_INPUT, Str),
	file_function(FILE_PEEK,Str,Ret,_Y,_Z, _,_),
	Ret = Code.

% TLS: need char_conversion table.
peek_char(S_or_A,Char):- 
	check_open_stream_or_alias(S_or_A,at_end_of_file/1,1,_Mode,Str),
	file_function(FILE_PEEK,Str,Ret,_Y,_Z, _,_),
	(Ret >= 0 -> 
	    atom_codes(Char,[Ret])
	 ;  Char = Ret).

peek_char(Char):- 
	stat_flag(CURRENT_INPUT, Str),
	file_function(FILE_PEEK,Str,Ret,_Y,_Z, _,_),
	(Ret >= 0 -> 
	    atom_codes(Char,[Ret])
	 ;  Char = Ret).
	
%-----------


% TLS: ISO interfaces to feof()
at_end_of_stream:- 
	stat_flag(CURRENT_INPUT, Str),
	file_function(FILE_END_OF_FILE,Str,Ret,_Y,_Z, _,_),
	Ret \== 0.
	
at_end_of_stream(S_or_A):- 
	check_open_stream_or_alias(S_or_A,at_end_of_file/1,1,_Mode,Str),
	file_function(FILE_END_OF_FILE,Str,Ret,_Y,_Z, _,_),
	Ret \== 0.

%-----------

% TLS: ISO interface to file_seek/3.  For now, handling only text files,.
set_stream_position(S_or_A,Position):- 
	check_open_stream_or_alias(S_or_A,set_stream_position/2,1,_Md,Str),
	check_position_term(Position),
	Position = position(Origin,Offset),
	file_seek(Str, Offset, Origin, Ret),
	(Ret =:= 0 -> 
	    permission_error(set_position,stream,Str,set_stream_position/2)
	  ; true).

check_position_term(Position):- 
	((Position = position(0,Offset),integer(Offset)) -> 
	  true
             ; domain_error(position_term,Position,set_stream_position/1,1) ).


%-----------
% TLS: ISO interface to file_flush/2
flush_output(S_or_A):-
	check_open_stream_or_alias(S_or_A,flush_output/1,1,output,Str),
	file_flush(Str,Ret),
	(Ret \== 0 ->
	    permission_error(flush,stream,Str,flush_output/1)
	  ; true).

%-----------
% TLS: ISO interface to file_flush/2
flush_output:-
	stat_flag(CURRENT_OUTPUT,Stream),
	file_flush(Stream,Ret),
	(Ret \== 0 ->
	    permission_error(flush,stream,Stream,flush_output/1)
	  ; true).

%-----------
% TLS: ISO specifies some error conditions for this, but failure seems better.
stream_property(S_or_A,Prop):- 
	current_stream_or_alias(S_or_A,Stream),
	stream_property_1(Stream,Prop).

stream_property_1(_Stream,type(text)).
stream_property_1(Stream,alias(A)):- 
	'_$alias'(A,Stream).
stream_property_1(Stream,Property) :-
	(Stream >= MIN_USR_OPEN_FILE -> 
	    user_stream_property(Stream,Property)
	 ;  system_stream_property(Stream,Property) ).

user_stream_property(Stream,Property):- 
	user_stream_property_1(Property,Prop_type,Return),
	file_function(STREAM_PROPERTY,Stream, Prop_type,Ret,_, _, _),
	transform_property_returned(Prop_type,Ret,Return).

user_stream_property_1(file_name(F),STREAM_FILE_NAME,F).
user_stream_property_1(mode(M),STREAM_MODE,M).
user_stream_property_1(input,STREAM_INPUT,_).
user_stream_property_1(output,STREAM_OUTPUT,_).
user_stream_property_1(position(P),STREAM_POSITION,P).
user_stream_property_1(end_of_stream(E),STREAM_END_OF_STREAM,E).
user_stream_property_1(reposition(Bool),STREAM_REPOSITIONABLE,Bool).

system_stream_property(STDIN,mode(read)).
system_stream_property(STDIN,input).
system_stream_property(STDIN,eof_action(reset)).
system_stream_property(STDIN,reposition(false)).

system_stream_property(STDOUT,mode(append)).
system_stream_property(STDOUT,output).
system_stream_property(STDOUT,eof_action(reset)).
system_stream_property(STDOUT,reposition(false)).

system_stream_property(STDERR,mode(append)).
system_stream_property(STDERR,output).
system_stream_property(STDERR,eof_action(reset)).
system_stream_property(STDERR,reposition(false)).

system_stream_property(STDWARN,mode(append)).
system_stream_property(STDWARN,output).
system_stream_property(STDWARN,eof_action(reset)).
system_stream_property(STDWARN,reposition(false)).

system_stream_property(STDMSG,mode(append)).
system_stream_property(STDMSG,output).
system_stream_property(STDMSG,eof_action(reset)).
system_stream_property(STDMSG,reposition(false)).

system_stream_property(STDDBG,mode(append)).
system_stream_property(STDDBG,output).
system_stream_property(STDDBG,eof_action(reset)).
system_stream_property(STDDBG,reposition(false)).

system_stream_property(STDFDBK,mode(append)).
system_stream_property(STDFDBK,output).
system_stream_property(STDFDBK,eof_action(reset)).
system_stream_property(STDFDBK,reposition(false)).

transform_property_returned(STREAM_FILE_NAME,Ret,Ret).
transform_property_returned(STREAM_MODE,Ret_in,Ret_out):- 
	(Ret_in == READ_MODE -> 
	    Ret_out = read
	  ; (Ret_in == WRITE_MODE -> 
	       Ret_out = write
	     ; Ret_out = append)).
transform_property_returned(STREAM_INPUT,READ_MODE,input).
transform_property_returned(STREAM_OUTPUT,Ret,output):- 
	(Ret = WRITE_MODE ; Ret = APPEND_MODE),!.

