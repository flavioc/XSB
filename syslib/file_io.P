/* File:      file_io.P
** Author(s): kifer
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1999
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id$
** 
*/


:- compiler_options([xpp_on]).
#include "io_defs.h"
#include "standard.h"
#include "flag_defs.h"


	       /********************************/
	       /*  Formatted I/O    	       */
	       /********************************/

fmt_write(Fmt, Args) :-
       stat_flag(CURRENT_OUTPUT, OIport),   % Current output
	fmt_write(OIport, Fmt, Args).

fmt_write(OIport, Fmt, Args) :-
	formatted_io(FMT_WRITE, OIport, Fmt, Args, _Ret).

fmt_write_string(Str, Fmt, Args) :-
	formatted_io(FMT_WRITE_STRING, Str, Fmt, Args, _Ret).


fmt_read(Fmt,Result,Status) :-
        stat_flag(CURRENT_INPUT, OIport),  % Current input
	fmt_read(OIport, Fmt,Result,Status).

fmt_read(OIport, Fmt, Result, Status) :-
	formatted_io(FMT_READ, OIport, Fmt, Result, Status).


/***************************************************************/
/*    	      	      	      	      	      	      	       */
/*       file_flush, file_seek, file_truncate, file_pos, etc.  */
/*    	      	      	      	      	      	      	       */
/***************************************************************/

file_flush(OIport, Ret) :-
	file_function(FILE_FLUSH, OIport, Ret, _D, _E, _,_).
file_seek(OIport, Offset, Place, Ret) :-
	file_function(FILE_SEEK, OIport, Offset, Place, Ret, _,_).
file_truncate(OIport, Length, Ret) :-
	file_function(FILE_TRUNCATE, OIport, Length, Ret, _E, _,_).
file_pos(OIport, Pos) :-
	file_function(FILE_POS, OIport, Pos, _Ret, _E, _,_).
file_open(FileName, RWMode, OIport) :-
	file_function(FILE_OPEN, FileName, RWMode, OIport, _E, _,_).
file_close(OIport) :-
	file_function(FILE_CLOSE,OIport,_X,_Y,_Z, _,_).
file_get(OIport,Char) :-
	file_function(FILE_GET, OIport, Char, _X, _Y, _,_).
file_put(OIport,Char) :-
	file_function(FILE_PUT, OIport, Char, _X, _Y, _,_).
file_clearerr(OIport) :-
	file_function(FILE_CLEARERR, OIport, _, _, _, _, _).

%% These are lower level than file_read_line_atom/list
%% Therefore, they don''t check their arguments.
%% file_getbuf doesn''t intern ToString.
file_getbuf(OIport, ByteCount, ToString, BytesRead) :-
	file_function(FILE_GETBUF, OIport,ByteCount,ToString,BytesRead,_,_).

file_getbuf_atom(OIport, ByteCount, ToAtom, BytesRead) :-
	(var(ToAtom), var(BytesRead) ->
	    file_function(FILE_GETBUF, OIport,ByteCount,TmpStr,BytesRead,_,_),
	    intern_string(TmpStr, ToAtom)
	;
	 abort('Usage: file_getbuf_atom([+OIport,] +ByteCount, -ToAtom, -BytesRead)')
        ).

file_getbuf_atom(ByteCount, ToAtom, BytesRead) :-
	stat_flag(CURRENT_INPUT, OIport),
	(var(ToAtom), var(BytesRead) ->
	    file_function(FILE_GETBUF, OIport,ByteCount,TmpStr,BytesRead,_,_),
	    intern_string(TmpStr, ToAtom)
	;
	 abort('Usage: file_getbuf_atom([+OIport,] +ByteCount, -ToAtom, -BytesRead)')
        ).

file_getbuf_list(OIport, ByteCount, ToList, BytesRead) :-
	(var(ToList), var(BytesRead) ->
	    file_function(FILE_GETBUF, OIport,ByteCount,TmpStr,BytesRead,_,_),
	    atom_codes(TmpStr, ToList)
	;
	abort('Usage: file_getbuf_list([+OIport,] +ByteCount, -ToList, -BytesRead)')).

file_getbuf_list(ByteCount, ToList, BytesRead) :-
	stat_flag(CURRENT_INPUT, OIport),
	(var(ToList), var(BytesRead) ->
	    file_function(FILE_GETBUF, OIport,ByteCount,TmpStr,BytesRead,_,_),
	    atom_codes(TmpStr, ToList)
	;
	abort('Usage: file_getbuf_list([+OIport,] +ByteCount, -ToList, -BytesRead)')).

file_putbuf(OIport, ByteCount, FromString, Offset, BytesWritten) :-
	(var(BytesWritten) ->
	    file_function(FILE_PUTBUF, OIport,ByteCount,FromString,Offset,BytesWritten,_)
	;
	abort('Usage: file_putbuf([+OIport,] +ByteCount, +FromString, +Offset, -BytesWritten)')
    ).

file_putbuf(ByteCount, FromString, Offset, BytesWritten) :-
	stat_flag(CURRENT_OUTPUT, OIport),
	(var(BytesWritten) ->
	    file_function(FILE_PUTBUF, OIport,ByteCount,FromString,Offset,BytesWritten,_)
	;
	abort('Usage: file_putbuf([+OIport,] +ByteCount, +FromString, +Offset, -BytesWritten)')
	).

%% This doesn''t intern Str
file_read_line(OIport, Str, IsFullLine) :-
	( var(Str), var(IsFullLine) ->
	    file_function(FILE_READ_LINE, OIport, Str, IsFullLine, _, _,_)
	    ;
	    abort('Usage: file_read_line([+OIport,] -InputStr, -IsFullLine)')
        ).

%% Like file_read_line, but Str becomes an interned atom
file_read_line_atom(OIport, Str, IsFullLine) :-
	( var(Str), var(IsFullLine) ->
	    file_function(FILE_READ_LINE, OIport, UnStr, IsFullLine, _, _,_),
	    intern_string(UnStr,Str)
	    ;
	    abort('Usage: file_read_line_atom([+OIport,] -InputStr, -IsFullLine)')
        ).

%% Read line from current input stream (previously set by 'see')
%% Intern string
file_read_line_atom(Str, IsFullLine) :-
	stat_flag(CURRENT_INPUT, OIport),  % Current input
	file_read_line_atom(OIport, Str, IsFullLine).

%% Like file_read_line_atom, but returns list of characters
file_read_line_list(OIport, CharLst, IsFullLine) :-
	( var(Str), var(IsFullLine) ->
	    file_function(FILE_READ_LINE, OIport, Str, IsFullLine, _, _,_),
	    atom_codes(Str,CharLst)
	    ;
	    abort('Usage: file_read_line_list([+OIport,] -InputStr, -IsFullLine)')
        ).

%% Read line from current input stream (previously set by 'see')
%% Return list of chars
file_read_line_list(Lst, IsFullLine) :-
	stat_flag(CURRENT_INPUT, OIport),  % Current input
	file_read_line_list(OIport, Lst, IsFullLine).

%% Write Str out to OIport. Str must be atom or list of chars.
%% This is checked in C, by the builtin.
file_write_line(OIport, Str, Offset) :-
	file_function(FILE_WRITE_LINE, OIport, Str, Offset, _,_,_).

%% Same as file_write_line/3, but write to current output
file_write_line(Str, Offset) :-
	stat_flag(CURRENT_OUTPUT, OIport),  % Current output
	file_function(FILE_WRITE_LINE, OIport, Str, Offset, _,_,_).


/* Fancy stuff */
%% Like freopen
file_reopen(FileName, Mode, OIport,ErrCode) :-
	file_function(FILE_REOPEN, FileName,  Mode, OIport, ErrCode,_,_).

%% Like dup/dup2: make DestOIport into the same file descriptor as SrcOIport
%% If DestOIport is var, then behaves like dup; else like dup2 
%% (and then expects DestOIport to be a file descriptor).
%% ErrCode=0 - ok
file_clone(SrcOIport, DestOIport, ErrorCode) :-
	file_function(FILE_CLONE, SrcOIport, DestOIport, ErrorCode,_,_,_).

%% Open pipe. ReadPipe is for reading from pipe,
%% WritePipe is for writing to the pipe.
pipe_open(ReadPipe, WritePipe) :-
	file_function(PIPE_OPEN, ReadPipe, WritePipe, _,_,_,_).

%% Convert pipe into an XSB file descriptor.
%% This should be done on both ends: by the parent XSB process and by 
%% the child XSB process
fd2ioport(Pipe, OIport) :-
	file_function(FD2IOPORT, Pipe, OIport,_,_,_,_).


/***************************************************************/
/*    	      	      	      	      	      	      	       */
/*       file_stat, file_size 	      	   	     	       */
/*    	      	      	      	      	      	      	       */
/***************************************************************/

file_time(FileName, Time) :- file_stat(FileName,FILE_STAT_TIME,Time).
file_size(FileName, Size) :- file_stat(FileName,FILE_STAT_SIZE,Size).

/***************************************************************
**
** print_file_contents/1
**
****************************************************************/

print_file_contents(Filename) :-
	stat_flag(CURRENT_OUTPUT, ToIOport),  % current output
	print_file_contents(Filename, ToIOport).

print_file_contents(FileName, ToIOport) :-
	file_open(FileName, OREAD, FromIOport),
	copyIOport(FromIOport, ToIOport),
	file_close(FromIOport).
copyIOport(FromIOport, ToIOport) :-
	(file_read_line(FromIOport, Line, _) -> file_write(ToIOport, Line)),
	copyIOport(FromIOport, ToIOport),
	fail.        	 %% so as to not leave choice points around
copyIOport(_,_).


