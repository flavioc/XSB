/* File:      unix.P
** Author(s): Kostis F. Sagonas, Jiyang Xu
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1986, 1993-1998
** Copyright (C) ECRC, Germany, 1990
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id$
** 
*/


unix(Command) :- 
	term_type(Command, T),
	( T =:= 3 -> constr_command(Command, Command1), unix(Command1, Res)
	; T =:= 5 -> unix(Command, Res)
	),
	Res =:= 0.

constr_command([H], H).
constr_command([H|T], String) :-
	constr_command(T, SubString),
	str_cat(H, SubString, String).
	
unix(Command, Result) :-
	term_type(Command, T),
	( T =:= 5 -> sys_system(1, Command, R, _, _, _, _), Result = R
	; T =:= 1 -> term_psc(Command, PSC), psc_name(PSC, RCommand), 
		     sys_system(1, RCommand, R, _, _, _, _), Result = R
	).

/* Create subprocess. Redirect its standard input to StreamToProc
   and standard output to StreamFromProc. Prolog program can then read 
   from StreamFromProc and write to StreamToProc.
   +CmdAndArglist, -StreamToProc,-StreamFromProc,-StreamFromStderr,-ProcessId
   Fails, if can't create subprocess
*/
spawn_process(Cmd, StreamToProc, StreamFromProc, StreamFromStderr, Pid) :-
	sys_system(2, Cmd,StreamToProc,StreamFromProc,StreamFromStderr,Pid,_).
/* Process table is a list [process(Pid,To,From,Stderr,Cmdline), ...]
   that represents all active subprocesses */
get_process_table(ProcessList) :- sys_system(3, ProcessList, _,_,_,_,_).

%% obtain process status
process_status(Pid, Status) :- sys_system(4, Pid, Status, _,_,_,_).
%% Send signal to process. Currently wait, kill
process_control(Pid, Signal) :- 
	sys_system(5, Pid, Signal, _,_,_,_).


cd(Path) :- 
	( atom(Path) -> 
		expand_filename(Path, Dir), sys_chdir(Dir, Res), Res=:=0
	; var(Path) ->
		abort('Uninstantiated argument 1 of cd/1')
	; abort('Wrong type in argument 1 of cd/1')
	).

rename(Old, New) :- sys_rename(Old, New, Res), Res =:= 0.

ls :- unix('ls -F', Res), Res =:= 0.

rm(Name) :- sys_unlink(Name, Res), Res =:= 0.

edit(File) :- 
	expand_filename(File, FileName), 
	unix(['$EDITOR ', '$EDITOR_OPTIONS ', FileName, '.P']).

/*
sys_exit() :- sys_syscall(1).
 */
sys_link(Source, Dest, Res) :-	sys_syscall(  9, Res, Source, Dest).
sys_unlink(Path, Res) 	    :-	sys_syscall( 10, Res, Path).
sys_chdir(Dir, Res)	    :- 	sys_syscall( 12, Res, Dir).
sys_access(File, Mode, Res) :- 	sys_syscall( 33, Res, File, Mode).
sys_stat(Path, Buff, Res)   :-	sys_syscall( 38, Res, Path, Buff).
sys_rename(Old, New, Res)   :-	sys_syscall(128, Res, Old, New).


/*
sys_syscall(_CallNo, _Res)				 :- '_$builtin'(55).
 */
sys_syscall(_CallNo, _Res, _A1)				 :- '_$builtin'(55).
sys_syscall(_CallNo, _Res, _A1, _A2)			 :- '_$builtin'(55).
/*
sys_syscall(_CallNo, _Res, _A1, _A2, _A3)		 :- '_$builtin'(55).
sys_syscall(_CallNo, _Res, _A1, _A2, _A3, _A4)		 :- '_$builtin'(55).
sys_syscall(_CallNo, _Res, _A1, _A2, _A3, _A4, _A5)	 :- '_$builtin'(55).
sys_syscall(_CallNo, _Res, _A1, _A2, _A3, _A4, _A5, _A6) :- '_$builtin'(55).
 */
