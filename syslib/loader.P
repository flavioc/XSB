/* File:      loader.P
** Author(s): Ernie Johnson, Jiyang Xu, Kostis F. Sagonas
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1986, 1993-1998
** Copyright (C) ECRC, Germany, 1990
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id$
** 
*/



/*
 *  System Startup
 *  --------------
 *  Two things to notice: We need to set _$abort_cutpoint so that abort/0
 *  has a place to _$cutto during an execution where (when) the x_interp
 *  is not (not yet) loaded.  But most importantly, we must set the
 *  interrupt handler of the dynamic loader BEFORE any undefined
 *  predicate is encountered -- the first being conset/2, used to set
 *  _$abort_cutpoint.
 */

:- compiler_options([sysmod,xpp_on]).

#include "standard.h"
#include "char_defs.h"
#include "flag_defs_xsb.h"
#include "io_defs_xsb.h"
#include "celltags_xsb.h"


%% Provide tests for the respective OS.
%% windows_os_loader is used only here and in parse.
%% All other modules use windows_os imported from xsb_configuration.
%% The *_loader version is needed  here because we can''t import 
%% them from xsb_configuration this early. 

windows_os_loader :-  stat_flag(CONFIG_NAME, ConfigurationC),
	%% convert C string to Prolog
	intern_string(ConfigurationC, Configuration),
	(   str_sub('win', Configuration, _)
	;   str_sub('-nt', Configuration, _)
	;   str_sub('w95', Configuration, _)
	;   str_sub('wnt', Configuration, _) ).

%% we duplicate fmt_write_* here because they are used early on, in libpath()
fmt_write_string(S,Fmt,A) :- formatted_io(FMT_WRITE_STRING, S,Fmt,A,_).
fmt_write(File,Fmt,A) :- formatted_io(FMT_WRITE, File,Fmt,A,_).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



:-	'_$savecp'(CP),
	set_inthandler('_$load_undef'(_), 0),		% MYSIG_UNDEF
        conset('_$abort_cutpoint', CP),
	set_current_module,
	set_current_input,
	set_current_output,
	import_standard_predicates,
	%% Load the xsb_configuration predicate
	stat_flag(CONFIG_FILE, ConfigFileC),
	intern_string(ConfigFileC, ConfigFile), % convert C string to Prolog
	reconsult(ConfigFile),
	%%
	load_library_directories,
	execute_command_module.


/*
 *  Interrupt Handlers are currently stored in flags[32-48] of the
 *  emulator.
 */

set_inthandler(Handler, Number) :-
	Flag is Number + INT_HANDLERS_FLAGS_START,
	term_psc(Handler, PSC),
	stat_set_flag(Flag, PSC).


/*
 *  Set the current module to usermod (a.k.a. global_mod).  Do this by
 *  creating a PSC record for the symbol current_module/0, and
 *  associating the PSC record of usermod/0 with that of
 *  current_module/0 (it's stored in current_module's `ep' field.)
 *  Reflect this setting in the emulator by setting
 *  flags[CURRENT_MODULE] to 0.
 */

set_current_module :-
	conpsc(current_module, CURMOD_PSC),
	conpsc(usermod, USERMOD_PSC),
	psc_set_prop(CURMOD_PSC, USERMOD_PSC),
	stat_set_flag(CURRENT_MODULE, 0).


/*
 *  Create PSCs for userin/0 and current_input/0, associate userin/0
 *  with stdin and associate current_input/0 with userin/0.  Set
 *  emulator flag flags[CURRENT_INPUT] to stdin.
 */

set_current_input :-
	conpsc(userin, UserInPSC),
	psc_set_type(UserInPSC, 5),        % ``ep'' field contains file desc
	psc_set_prop(UserInPSC, 0),        % ``ep'' field set to stdin
	conset(current_input, UserInPSC),
	stat_set_flag(CURRENT_INPUT, 0).


/*
 *  Create PSCs for userout/0 and current_output/0, associate
 *  userout/0 with stdout and associate current_output/0 with
 *  userout/0.  Set emulator flag flags[CURRENT_OUTPUT] to stdout.
 */

set_current_output :-
	conpsc(userout, UserOutPSC),
	psc_set_type(UserOutPSC, 5),       % ``ep'' field contains file desc
	psc_set_prop(UserOutPSC, 1),       % ``ep'' field set to stdout
	conset(current_output, UserOutPSC),
	stat_set_flag(CURRENT_OUTPUT, 1).


/*
 *  Imports into usermod a bunch of basic-to-operation predicates, those
 *  listed in the file std_xsb.P using the predicate standard_symbol/3.
 */

import_standard_predicates :-
	standard_symbol(P, A, Mod),
	psc_import(P, A, Mod),
	fail.
import_standard_predicates.


/*
 *  Loads syslib/sysinitrc.P and site/siteinitrc.P, .xsb/xsbrc.P,
 *  if they are present.
 *  The emulator flag 50 is set to indicate that library_directory/1
 *  should be used for finding file paths rather than the default.
 */

load_library_directories :-
	slash(Slash),
	%%
	%% Construct system init file name
	xsb_configuration(syslibdir, SyslibDir),
	fmt_write_string(SysFileName, '%s%ssysinitrc', f(SyslibDir, Slash)),
	reconsult(SysFileName),	        % SysFileName is mandatory.
					% It is compiled if a .O file does
					% not exist or is obsolete.
	%%
	%% Construct site init file name
	xsb_configuration(site_dir, SiteDir),
	fmt_write_string(SiteFileName,'%s%ssiteinitrc', f(SiteDir,Slash)),
	str_cat(SiteFileName, '.P', SiteFileNameP),
	str_cat(SiteFileName, '.O', SiteFileNameO),
	%% Site init file isn't mandatory
	( (machine_file_exists(SiteFileNameP)
	   ; machine_file_exists(SiteFileNameO)) ->
		reconsult(SiteFileName)
	        ; true
	),
	%%
	%% Construct user''s .xsb/xsbrc.P
	xsb_configuration(user_home, HomeDir),
	fmt_write_string(UsrFileN, '%s%s.xsb%sxsbrc', f(HomeDir,Slash,Slash)),
	str_cat(UsrFileN, '.P', UserFileNameP),
	str_cat(UsrFileN, '.O', UserFileNameO),
	%% User init file isn't mandatory
	( (machine_file_exists(UserFileNameP)
	   ; machine_file_exists(UserFileNameO)) ->
		reconsult(UsrFileN)
		; true
        ).

load_library_directories.


/*****************************************************************************
** In the future, we'll add a modifier "system", so the user could indicate
** more precisely where predicates are imported from. E.g.,
**
** :- import file_write/2 from system(xsb_writ)
**
*****************************************************************************/

/*
 *  Load and execute the module specified on the command line.
 */

execute_command_module :-
	stat_flag(CMD_LOOP_DRIVER, InputFilePtr_INT),
	load(InputFilePtr_INT).




/*************************************************************************

		The XSB Dynamic Loader
		======================

The following code should be self-contained since it would be impossible
to load a predicate on demand if the mechanism by which it is loaded
requires the use of another unloaded predicate.  Therefore we are not
allowed imports and so cannot rely on code defined elsewhere in the
system.

In fact, the only predicates that can be used in this part of the file
are those that are explicitly defined or expanded (in-lined) by the
compiler as calls to C functions.  See the file cmplib/builtin.P for
XSB's in-lined predicates, builtins, and functions.

*************************************************************************/

/*
 *  Undefined Predicate Interrupt Handler
 *  -------------------------------------
 *  This is the starting point for resolving an undefined symbol.
 *  The module containing that symbol is loaded and its directives
 *  are executed.  Processing continues with the re-execution of
 *  the goal which triggered the interrupt.
 */

'_$load_undef'(Term) :-
	term_type(Term, Type),
	( Type =:= CS -> term_psc(Term, PSC)
	; Type =:= STRING -> psc_insert(Term, 0, PSC, 0)
	),
	load_pred(PSC),
	call0(Term).


load_pred(PSC) :- \+ (\+ (load_pred0(PSC))).

load_pred0(PSC) :- 
	stat_flag(HITRACE, Hitrace), 	
	stat_set_flag(HITRACE, 0),	  % turn off hitrace
	load_pred1(PSC),
	stat_set_flag(HITRACE, Hitrace).  % resume hitrace status if successful
load_pred1(PSC) :-
	'_$savecp'(B),
	psc_name(PSC, Name),
	psc_arity(PSC, Arity),
	psc_env(PSC, Env), 
	( Env =:= 2
	->  % is "imported"
	    psc_prop(PSC, ModPSC),
	    psc_name(ModPSC, ModName),
	    psc_type(ModPSC, ModType), 
	    (	ModType =:= 4
	    ;	ModType =\= 4,	% module is not loaded yet
		load(ModName)	% can abort here 
	    ),
	    (	psc_type(PSC, NType),
		(   NType =:= 2; NType =:= 13; NType =:= 1 ), 
		%% module loaded, and pred/foreign-pred is there
		'_$cutto'(B)
		;
		%% module loaded, but pred/foreign-pred is not there
		abort(['The predicate: ', Name, '/', Arity,
		      ' is not defined in the module ', ModName])
	    )
	;   abort(['Undefined predicate: ', Name, '/', Arity])
	).


/*
 *  Loads and executes the directives of a module.  The file containing
 *  the module is constructed using search_file/3, below.
 */

load(ModName) :-
	'_$savecp'(B),
	stat_flag(DEBUG_ON, Debug_on),
	(   Debug_on =:= 1
	->  fmt_write(STDDBG, "[ load module %s ]\n", arg(ModName))
	;   true
	),
	(   search_file(ModName, FileName_O, '.O'),
	    code_load(FileName_O, Init, 0), % use the C loader
	    (	Init =\= 0	% load succeeded
	    ->	'_$cutto'(B),
		(   Init =\= 4 % prolog byte-code succeeded
		->  ll_code_call(Init, true, 2), % call '_$main'
		    unload_seg(Init) % delete code for '_$main'
		;   true	% load foreign obj code succeeded
		)
	    )
	->  true
	%% If .O file doesn't exist or doesn't load,
	%% but .P file exists somewhere on the load path
	%% then recompile the .P file and load it.
	;   (   search_file(ModName, FileName_P, '.P'),
		machine_file_exists(FileName_P)
	    ->	reconsult(FileName_P)
	    )
	;   abort(['Module ', ModName,
		   ' is not found in XSB library directories'])
	).

/*
 *  To use code_call/3, it must be the last clause in a rule.
 *  Here we force the issue.
 */

ll_code_call(A,B,C) :- code_call(A,B,C).



/*
 *  Takes a filename (INT or STRING encoded pointer) and returns an
 *  absolute filename (STRING) with Extension (e.g., .P, .O) added to it.
 *  The extension should NOT already be a part of the incoming ModName.
 */

search_file(ModName, AbsFileName, Extension) :- 
	tilde_expand_filename(ModName,ExpandedModName),
	( is_absolute_filename(ExpandedModName)
	->  WholePath = ExpandedModName
	;   libpath(LibPath),
	    str_cat(LibPath, ExpandedModName, WholePath)
	),
	str_cat(WholePath, Extension, AbsFileName).


/*
 *  Used in searching for a file.  Directory paths are returned in the
 *  following manner:
 *
 *      Return in the order specified through the predicate
 *	library_directory/1, followed by the default paths
 *      in this default order:
 *	  lib/   syslib/   cmplib/   ./
 */

libpath(P) :- libraries_loaded, 
	      library_directory(Dir), 
	      expand_filename(Dir, P1),
	      dirname_canonic(P1, P).
libpath(P) :- stat_flag(INSTALL_DIR, InstallDir1),
	      intern_string(InstallDir1, InstallDir),
	      slash(Slash),
	      %%<installdir>/syslib/  (slash type depends on the OS)
	      fmt_write_string(P,'%s%ssyslib%s',f(InstallDir, Slash, Slash)).
libpath(P) :- stat_flag(INSTALL_DIR, InstallDir1),
	      intern_string(InstallDir1, InstallDir),
	      slash(Slash),
	      %% <installdir>/cmplib/  (slash type depends on the OS)
	      fmt_write_string(P,'%s%scmplib%s',f(InstallDir, Slash, Slash)).
libpath(P) :- stat_flag(INSTALL_DIR, InstallDir1),  % get the installation dir
	      intern_string(InstallDir1, InstallDir),
	      slash(Slash),
	      %% <installdir>/lib/  (slash type depends on the OS)
	      fmt_write_string(P, '%s%slib%s', f(InstallDir, Slash, Slash)).
libpath(P) :- slash(Slash), str_cat('.', Slash,P).

/*
 *  Determine whether the ~/.xsbrc module has been loaded.
 */

libraries_loaded :- 
	stat_flag(LIBS_LOADED, Lib_Loaded),
	Lib_Loaded =:= 1.

/*======================================================================*/

