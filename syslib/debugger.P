/* File:      debugger.P
** Author(s): David S. Warren
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1986, 1993-1998
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id$
** 
*/


:- compiler_options([cpp_on]).
#include "flag_defs.h"
#include "celltags.h"
#include "char_defs.h"
#include "standard.h"

:- set_inthandler('_$deb_spy'(_), 3),
   set_inthandler('_$deb_trace'(_), 4).


:- read_debugger_data.

read_debugger_data :- '_$_debugger_data_loaded', !.
read_debugger_data :- 
	xsb_configuration(syslibdir, SysLib),
	fmt_write_string(DebugDataFile, '%s/debugger_data.P', arg(SysLib)),
	see(DebugDataFile),
	repeat,
	    read(T),
	    (T = end_of_file -> true
	    	    	     ;  assert(T), fail
	    ),
	seen.

/* -- tracing flags setting  -------------------------------------- */

nodebug :- stat_set_flag(DEBUG_ON,0).		        % debug_on = 0
piltrace :- stat_set_flag(PIL_TRACE,1), hitrace.	% pil level tracing 
hitrace :- stat_set_flag(HITRACE,1),debug.		% call level sim trace
nosimtrace :-
	stat_set_flag(HITRACE,0), 
	stat_set_flag(PIL_TRACE,0).	    	       % undo the above two
trace_stack_max :- stat_set_flag(TRACE_STA,1), debug.  % record max space usage
notrace_stack_max :- stat_set_flag(TRACE_STA,0).       % undo above
dump :- ll_write('dump not implemented yet').
trace :- debug, stat_set_flag(TRACE,1).	    	       % trace = 1
notrace :-
	stat_set_flag(TRACE,0),	       	       	% trace = 0
	nodebug.				% ??dsw added, (no load msgs)

				% permanent autopilot, until turned off
trace_autopilot(on) :- conset('_$_deb_autopilot', 2). 
trace_autopilot(off) :- conset('_$_deb_autopilot', 0).

/* -- set debug on ------------------------------------------------ */

debug :- stat_flag(DEBUG_ON, D),
	(D =:= 0
	 ->	stat_set_flag(INVOKE_NUM, 0),		% invoke_num = 1
		stat_set_flag(SKIPPING, 0),		% skipping = 0
		stat_set_flag(QUASI_SKIPPING, 0),	% quasi_skipping = 0
		stat_set_flag(DEBUG_ON, 1)		% debug_on = 1
	 ;	true
	).

/* note: skipping implies quasi_skipping */

/* -- check debugging status -------------------------------------------*/

debugging :- 
    stat_flag(HIDE_STATE, H0), H1 is H0+1, stat_set_flag(HIDE_STATE, H1),
    ll_write('  Debugging:   '), stat_flag(DEBUG_ON,X1), ll_write(X1), ll_nl,
    ll_write('  Tracing:     '), stat_flag(TRACE,X2), ll_write(X2), ll_nl,
    ll_write('  Hi Tracing:  '), stat_flag(HITRACE,X3), ll_write(X3), ll_nl,
    ll_write('  PIL Tracing: '), stat_flag(PIL_TRACE,X4), ll_write(X4), ll_nl,
    ll_write('  StackTracing:'), stat_flag(TRACE_STA,X5), ll_write(X5), ll_nl,
    ll_write('  Skipping:    '), stat_flag(SKIPPING,X6), ll_write(X6), ll_nl,
    ll_write('  Q-Skipping:  '),
    stat_flag(QUASI_SKIPPING,X7), ll_write(X7), ll_nl,
    ll_write('  Hide level:  '), ll_write(H0), ll_nl,
    stat_set_flag(HIDE_STATE, H0).

/* -- trace interrupt handler ------------------------------------------ */

'_$deb_trace'(Call) :-
	%%ll_write(trace(Call)),ll_nl,
	stat_flag(HIDE_STATE, L),			% L = hide_state;
	stat_flag(QUASI_SKIPPING, S),		 	% S = quasi_skipping
	%% P-pred name, A- arity
	get_psc_info(Call, PSC, P, A),
	%% set_print_control is needed here too, if is_xpar_call 
	%% predicates are used to control printing
	set_print_control(P,A,_Type),
	(is_xpar_call(P,A)
	 ->	term_arg(Call,1,Ncall),
		'_$deb_trace'(Ncall)
	 ; Call = '_$load_undef'(Ncall)
	 ->	'_$deb_trace'(Ncall)
	 ; must_load(PSC)
	 ->	'_$deb_trace'(Call)
	 ; hide_this_show(P,A)
	 ->	basic_call(0,PSC,Call)	% and turn tracing back on
	 ; hide_this_hide(P,A)
	 ->	basic_call(1,PSC,Call)	% and leave tracing off
	 ; show_this_hide_call(P,A)
	 ->	stat_flag(INVOKE_NUM,N),
	        ('_$_deb_print_hidden' -> true
		; N1 is N+1,stat_set_flag(INVOKE_NUM,N1)
		),		% invoke_num++
		( S=\=0
		 ->	basic_call(1,PSC,Call)	% skipping or quasi_skipping 
		 ;	deb_enterpred(N, PSC, Call, intrace, L, 1)
		)
	 ;	stat_flag(INVOKE_NUM,N),
	        ('_$_deb_print_hidden' -> true
		; N1 is N+1,stat_set_flag(INVOKE_NUM,N1)
		),		% invoke_num++
		( S=\=0
		 ->	basic_call(0,PSC,Call)	% skipping or quasi_skipping 
		 ;	deb_enterpred(N, PSC, Call, intrace, L, 0)
		)
	).


%% trace this call, but hide all embedded calls
%% Standard preds, except those in trace_standard_predicate
%% Also, user-specified preds in show_this_hide/2.
show_this_hide_call(P,A) :- trace_standard_predicate(P,A), !, fail.
show_this_hide_call(P,A) :- standard_symbol(P,A,_).
%% show_this_hide is constructed dynamically
show_this_hide_call(P,A) :- show_this_hide(P,A).


must_load(PSC) :-
	psc_type(PSC, T),
	( T =:= 2 -> fail
	; T =:= 1 -> fail
	; T =:= 13 -> fail
%%%	; T =:= 14 -> fail
	; load_pred(PSC)
	).


/* -- spy interrupt handler ------------------------------------------ */

'_$deb_spy'(Call) :-
	%%ll_write(spy(Call)),ll_nl,
	%% P-pred name, A- arity
	get_psc_info(Call, PSC, _P, _A),
	(must_load(PSC)
	->  '_$deb_spy'(Call)
	;   stat_flag(HIDE_STATE, L), % L = hide_state
	    stat_flag(INVOKE_NUM,N),N1 is N+1,
	    stat_set_flag(INVOKE_NUM,N1), % invoke_num++
	    stat_flag(SKIPPING, S),	% S = skipping
	    psc_spy(PSC, K),
	    (	S =:= 0, (K=:=128 ; K=:=192, indeed_spy(Call))
	    ->	
		stat_set_flag(TRACE, 1), % trace = 1
		deb_enterpred(N,PSC,Call,inspy, L, 0)
	    ;	basic_call(0,PSC,Call) % skipping
	    )
	).

%% +Call, -PSC, -Pred, -Arity
get_psc_info(Call, PSC, P, A) :-
	term_type(Call,Type),
	(Type =:= STRING
	 ->	psc_insert(Call, 0, PSC, 0), P = Call, A = 0
	 ;	term_psc(Call,PSC), psc_name(PSC,P), psc_arity(PSC,A)
	).

set_print_control(Pred, Arity, Type) :- 
	Type == 'Redo',
	!,
	(trace_this_enable_print_on_redo(Pred,Arity) 
	 -> (retractall('_$_deb_print_hidden') -> true
	    ;	true
	    )
	; true
	).
set_print_control(_Pred, _Arity, Type) :- 
	(Type == 'Exit' ; Type == 'Fail'),
	!,
	(retractall('_$_deb_print_hidden') -> true
	;   true
	).
set_print_control(Pred, Arity, _Type) :-
	(trace_this_print(Pred, Arity)
	 ->     retractall('_$_deb_print_hidden')
	 ;      true
	),
	(trace_this_noprint(Pred, Arity)
	 ->     assert('_$_deb_print_hidden')
	 ;      true
	).


indeed_spy(Call) :- \+ (\+ ('_b_SPY_condition'(Call))).

/* main tracing interpreter-------------------------------------------*/

deb_enterpred(N,PSC,Call,Spy,L,Tr) :- 		% L = 1
	%%ll_write('in debugger'),ll_nl,
	deb_traceget(N,Spy,'Call',Call,_),
	(   basic_call(Tr,PSC,Call),
	    (	stat_flag(HIDE_STATE,OV), NV is OV+1,
		stat_set_flag(HIDE_STATE,NV), % hide_state ++
		stat_set_flag(9, 0), % quasi_skipping = 0
		stat_set_flag(8, 0), % skipping = 0
		(   still_displaying(Spy)
		->  deb_traceget(N,Spy,'Exit',Call,_)
		;   true
		),
		stat_set_flag(HIDE_STATE,OV) % hide_state --
	    ;	
		stat_flag(HIDE_STATE,OV), NV is OV+1,
		stat_set_flag(HIDE_STATE,NV), % hide_state++
		(   still_displaying(Spy)
		->  deb_traceget(N,Spy,'Redo',Call,_)
		;   true
		),
		stat_set_flag(HIDE_STATE,OV), % hide_state --
		fail
	    )
	;   
	    stat_flag(HIDE_STATE,OV), NV is OV+1,
	    stat_set_flag(HIDE_STATE,NV), % hide_state ++
	    stat_set_flag(QUASI_SKIPPING, 0), % skipping = 0
	    stat_set_flag(SKIPPING, 0), % quasi_skipping=0
	    (	still_displaying(Spy) % if still tracing or debugging
	    ->	deb_traceget(N,Spy,'Fail',Call,C2),
		(   C2=:=CH_r	% r: retry, otherwise just fail 
		->  stat_set_flag(INVOKE_NUM, N), % reset call number  
		    deb_retry(Call,Spy)
		;   L1 is L - 1, stat_set_flag(HIDE_STATE, L1), fail
		)
	    ;	L1 is L - 1, stat_set_flag(HIDE_STATE, L1), fail
	    )
	).

still_displaying(Spy) :-
	stat_flag(TRACE, Tracing),
	(Tracing=\=0
	 ->	true
	 ;	stat_flag(DEBUG_ON, Debugging),
		(Debugging=\=0
		 ->	Spy=inspy
		)
	).

/* retry recursive call-------------------------------------------------*/

deb_retry(Call,inspy)   :- !,'_$deb_spy'(Call).
deb_retry(Call,intrace) :- '_$deb_trace'(Call).

deb_traceget(N,Spy,Type,Call,C) :-
	%% P-pred name, A- arity
	get_psc_info(Call, _PSC, P, A),
	set_print_control(P,A,_),
	(   shown(Type,Spy)
	->  ('_$_deb_print_hidden'
	    ->	C = CH_NEWLINE
	    ;	deb_writepref(Spy),
		ll_write(' ('),ll_write(N),ll_write(') '),
		ll_write(Type),ll_write(': '),
		debug_display_call(Call),
		deb_prompt(Type,Spy,C)
	    )
	;   C = CH_NEWLINE
	),
	set_print_control(P,A,Type).

debug_display_call(Call) :- (debug_display_call_hook(Hook)
			    	-> Invocation =.. [Hook, Call],
				    %% Prevent backtracking through 
				    %% the print function hook: succeed 
				    %% even if the print function doesn''t.
				   (call(Invocation) -> true; true)
			    	;  ll_write(Call)
			    ).

leashable('Call').
leashable('Exit').
leashable('Redo').
leashable('Fail').

:- dynamic(shown(_,_)).
:- show(['Call','Exit','Redo','Fail']).

show(X) :- retractall(shown(_,_)), show0(X).
show0([]).
show0([X|R]) :- 
	leashable(X)
	 ->	assert0(shown(X,intrace)),
		assert0(shown(X,inspy)),
		show0(R)
	 ;	abort('Illegal port identifier').

:- dynamic(leashed(_,_)).
:- leash(['Call','Exit','Redo','Fail']).

leash(X) :- retractall(leashed(_,_)), leash0(X).
leash0([]).
leash0([X|R]) :- 
	leashable(X)
	 ->	assert0(leashed(X,intrace)),
		assert0(leashed(X,inspy)),
		leash0(R)
	 ;	abort('Illegal port identifier').

deb_writepref(inspy) :- ll_write('**').
deb_writepref(intrace) :- ll_write('  ').


deb_prompt(Type, Spy, C) :- 
	(   leashed(Type,Spy)	% interactive
	->  ll_flush,
	    %% if autopilot=on, temporarily or permanently:
	    (	conget('_$_deb_autopilot', Auto), Auto > 0
	    ->	C1 = CH_NEWLINE, ll_nl	   %  pretend the user entered <CR>
	    ;	deb_getonechar(C1)
	    ),
	    (	leg_r(C1)
	    ->	C = C1, deb_ug(C)
	    ;	deb_prompt(Type,Spy,C)
	    )
	;   ll_nl,    	     % non-interactive
	    C=CH_NEWLINE
	).


% legal responses to prompt:
leg_r(CH_NEWLINE).          leg_r(CH_a).  leg_r(CH_b).
leg_r(CH_c).  leg_r(CH_e).  leg_r(CH_f).  leg_r(CH_l).
leg_r(CH_n).  leg_r(CH_q).  leg_r(CH_r).  leg_r(CH_s).
leg_r(CH_p).  % autopilot

deb_ug(CH_NEWLINE) :- !,stat_set_flag(TRACE, 1). %  <cr>: creep (trace = 1)
deb_ug(CH_a) :- !,stat_set_flag(SKIPPING, 0),	 %  a: abort 
		stat_set_flag(QUASI_SKIPPING, 0),
		stat_set_flag(TRACE, 0), 
		stat_set_flag(DEBUG_ON, 0), 
		abort.
deb_ug(CH_b) :- !, stat_set_flag(SKIPPING, 0),	   %  b: break, 
		stat_set_flag(QUASI_SKIPPING, 0),  % and creep when return
		stat_set_flag(TRACE, 0),
		break,stat_set_flag(TRACE,1).
deb_ug(CH_c) :- !,stat_set_flag(TRACE,1).	%  c: creep 	(trace = 1)
deb_ug(CH_e) :- !,halt.				%  e: exit Prolog %
deb_ug(CH_f) :- !,stat_flag(HIDE_STATE,L),L1 is L-1,
		stat_set_flag(HIDE_STATE,L1),fail.	%  f: fail
deb_ug(CH_l) :- !,stat_set_flag(TRACE, 0).		%  l: leap (trace = 0)
deb_ug(CH_n) :- !,notrace.			%  n: notrace
deb_ug(CH_q) :- !,stat_set_flag(QUASI_SKIPPING, 1).	%  q: quasi-skip 
						%           (quasi-skipping=1)
deb_ug(CH_r) :- !.				%  r: retry (handled later)
deb_ug(CH_s) :- !,stat_set_flag(QUASI_SKIPPING, 1), % s: skip. 
		stat_set_flag(SKIPPING, 1). 	    % skipping=quasi_skipping=1
deb_ug(CH_p) :- !,stat_set_flag(TRACE, 1),      %  autopilot till top level
	    	conset('_$_deb_autopilot', 1).

deb_printhelp :- 
	ll_write('   <cr>   creep          a      abort') ,ll_nl,
	ll_write('   c      creep          f      fail')  ,ll_nl,
	ll_write('   r      retry (fail)   h      help')  ,ll_nl,
	ll_write('   n      nodebug        e      exit')  ,ll_nl,
	ll_write('   b      break          s      skip')  ,ll_nl,
	ll_write('   q      quasi-skip     l      leap').

deb_getonechar(C) :- 
	prompt(Prompt,Prompt,'_$debug_prompt'(_)),
	ll_write(Prompt),
	%%ll_write(' ? '),
	ll_flush,
	file_get(STDIN, C1),
	(C1=:=CH_NEWLINE
	 ->	C=C1
	 ; C1<0
	 ->	C=CH_e
	 ;	deb_skiptoaft,
	    	(C1=:=CH_h /*help*/
		 ->	deb_printhelp,deb_getonechar(C)
		 ;	C=C1
		)
	).
	
deb_skiptoaft :- file_get(STDIN, C), C=\=CH_NEWLINE, !, deb_skiptoaft.
deb_skiptoaft.

%% '_b_SPY_condition'/1 will be undefined, but that''s OK.
:- dynamic('_b_SPY_condition'(_)).

spy(X) :- 
	var(X)
	 ->	warning('Spy specification cannot be a variable. Ignored.')
	 ;	spy0(X), debug.
spy0(X) :- var(X),!,warning('Spy specification cannot be a variable. Ignored.').
spy0([Pred|More]) :- !, spy0(Pred),spy0(More).
spy0([]) :- !.
spy0(P) :- atom(P),!,
	findall(usermod:P/A,current_predicate(usermod:P/A),Preds),
	spy0(Preds).
spy0(M:P) :- atom(P),!,
	findall(M:P/A,current_predicate(M:P/A),Preds),
	spy0(Preds).
spy0(M:P/A) :- !,
	functor(Call,P,A),
	(( M \== usermod, M \== global, \+ predicate_property(M:Call,_))
	 ->	import(from(P/A,M))
	 ;	true
	),
	spy_psc(M, P, A, NPsc),
	psc_set_spy(NPsc,128).
spy0(P/A) :- !, spy0(usermod:P/A).
spy0((M:T:-B)) :- !,
	(( M \== usermod, M\== global, \+ predicate_property(M:T,_))
	 ->	functor(T,P,A),
		import(from(P/A,M))
	 ;	true
	),
	term_mod(M:T,Psc,NewT),
	psc_set_spy(Psc, 192),
	assert0(('_b_SPY_condition'(NewT):-B)).
spy0((T:-B)) :- !, spy0((usermod:T:-B)).
spy0(T) :- spy0((usermod:T:-true)).

nospy(X) :- var(X),!,warning('Spy specification cannot be a variable. Ignored.').
nospy([Pred|More]) :- !, nospy(Pred),nospy(More).
nospy([]) :- !.
nospy(P) :- atom(P),!,
	findall(usermod:P/A,current_predicate(usermod:P/A),Preds),
	nospy(Preds).
nospy(M:P) :- atom(P),!,
	findall(M:P/A,current_predicate(M:P/A),Preds),
	nospy(Preds).
nospy(M:P/A) :- !,
	spy_psc(M, P, A, NPsc),	psc_set_spy(NPsc, 0).
nospy(P/A) :- !, nospy(usermod:P/A).
nospy((M:T:-B)) :- !,
	term_mod(M:T,Psc,NewT),
	psc_set_spy(Psc, 192),
	(retract(('_b_SPY_condition'(NewT):-B)),fail ; true).
nospy((T:-B)) :- !, nospy((usermod:T:-B)).
nospy(M:T) :- 
	term_mod(M:T,Psc,NewT),
	psc_set_spy(Psc, 192),
	retractall('_b_SPY_condition'(NewT)).
nospy(T) :- !, nospy([]:T).


spy_psc(M, P, A, Psc) :-
	conname(M, MName),
	conname(P, PName),
	psc_insert(PName, A, Psc, MName).

term_mod(Mod:Term,Psc,Newterm) :-
	conname(Mod,MName),
	functor(Term,Pred,Arity),
	Term =.. [Pred|Args],
	psc_insert(Pred,Arity,Psc,MName),
	term_new(Psc,Newterm),
	Newterm =.. [Pred|Args].

%% must already have been loaded if necessary.
basic_call(I,PSC,Call) :-
	psc_prop(PSC, Code),
	psc_type(PSC, Nt),
	stat_flag(HIDE_STATE,V), V1 is V-1,	% calc hide_state-1
	(I =:= 0	% turn tracing back on
	 ->	stat_set_flag(HIDE_STATE,V1), % hide_state--
		code_call(Code,Call,Nt)
	 ;	(code_call_h(Code,Call,Nt), % leave tracing off
		  (stat_set_flag(HIDE_STATE,V1) % hide_state--
		   ;
				% restore hide state when failing in
		   stat_set_flag(HIDE_STATE,V),fail
		  )
		;
		 stat_set_flag(HIDE_STATE,V1),fail     % reset when failing out
		)
	).


%% nec since code_call must be last call in clause.
code_call_h(Code,Call,Nt) :- code_call(Code,Call,Nt).

ll_write(X) :- file_write(STDDBG, X).
ll_nl :- file_put(STDDBG, CH_NEWLINE).
ll_flush :- file_flush(STDDBG, _).

/* NOTE: psc_spy/2 now is builtin in machine.P */
psc_spy(PSC, Spy) :- buff_byte(PSC, 0, Val), Spy is Val /\ 192.

psc_set_spy(PSC, Spy) :- buff_byte(PSC, 0, Val), 
	Val1 is (Val /\ 63) \/ Spy,
	buff_set_byte(PSC, 0, Val1).


/* --------------------- end of file debugger.P ----------------------- */
