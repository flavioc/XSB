/* File:      curr_sym.P
** Author(s): Kostis F. Sagonas
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1986, 1993-1998
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id$
** 
*/


:- compiler_options([xpp_on,sysmod,optimize]).

/* TLS: because of a 64-bit number used below, compilation may give the error:
   Overflow in radix notation, returning float
*/

#include "standard.h"
#include "flag_defs_xsb.h"
#include "heap_defs_xsb.h"
#include "psc_defs.h"
#include "extensions_xsb.h"

/* ===== current_atom/1 ====================================== */

%current_atom(Atom) :- true.
current_atom(Module:Atom) :-
	get_first_psc_pair(PSC_Pair),
	module_scan(PSC_Pair, ModuleName, ModulePSC),
	ModuleName = Module,
	psc_prop(ModulePSC, First_PSC_Pair),	% get the first psc_pair 
						% of this module
	( First_PSC_Pair =:= 1 ->	% We are dealing with a global module!
	    warning(('Predicate current_atom/1 for module "',
		     ModuleName,
		     '" does not include usermod strings !')),
	    psc_scan_in_hash_table(0,PSC),
	    psc_arity(PSC, Arity), 
	    Arity =:= 0,
	    psc_name(PSC, Name),
	    Atom = Name
        ; psc_scan_in_module(First_PSC_Pair, PSC), 
	  psc_arity(PSC, Arity), 
	  0 = Arity,
	  psc_name(PSC, Name),
	  Atom = Name
	).

% Original Jiyang version of current_atom/1
%	psc_scan(PSC), psc_arity(PSC, N), N = 0, term_new(PSC, A0), A0 = A.


/* ===== current_functor/1 ===================================== */

%   current_functor(?Predicate_Indicator)
%   Succeeds iff Predicate_Indicator is a predicate indicator for one
%   of the procedures appearing in the database (both system and user 
%   defined but not necessarily loaded in the system). 
%   Predicate_Indicator can have the following forms:
%	 (i) Module:Functor/Arity.
%	(ii) Functor/Arity (for global modules)
%   A variable in place of Predicate_Indicator succeeds only for global
%   modules.

current_functor(Module:Functor/N) :-
	get_first_psc_pair(PSC_Pair),
	module_scan(PSC_Pair, ModuleName, ModulePSC),
	ModuleName = Module,
	psc_prop(ModulePSC, First_PSC_Pair),	% get the first psc_pair 
						% of this module
	( First_PSC_Pair =:= 1 ->	% We are dealing with a global module!
		current_functor(Functor/N)
        ; psc_scan_in_module(First_PSC_Pair, PSC),
	  psc_arity(PSC, Arity), 
	  psc_name(PSC, Name),
	  Functor = Name,
	  Arity = N
	).
current_functor(Functor/N) :-		% This takes care of global modules.
	!,				% i.e. "usermod" and "global".
	psc_scan_in_hash_table(0, PSC),
	psc_arity(PSC, Arity), 
	psc_name(PSC, Name),
	Functor = Name,
	Arity = N.

psc_scan_in_hash_table(Bucket_Index, PSC) :- 
	dereference_the_bucket(Bucket_Index, First_Pair_of_Bucket),
	psc_scan_in_bucket(First_Pair_of_Bucket, PSC).
psc_scan_in_hash_table(Bucket_Index, PSC) :- 
	next_bucket(Bucket_Index, Next_Bucket_Index),
	( Next_Bucket_Index =\= 0 ->		% At end of hash_table.
		psc_scan_in_hash_table(Next_Bucket_Index, PSC) ).

psc_scan_in_bucket(PSC_Pair, _) :-
	PSC_Pair =:= 0,		% PSC_Pair == NULL
	!,
	fail.
psc_scan_in_bucket(PSC_Pair, PSC) :-
	pair_psc(PSC_Pair, PSC).
psc_scan_in_bucket(PSC_Pair, Next_PSC) :- 
	pair_next(PSC_Pair, Next_PSC_Pair),
	psc_scan_in_bucket(Next_PSC_Pair, Next_PSC).

% Original Jiyang version of current_functor/2
%	psc_scan(PSC), psc_arity(PSC, N0), psc_name(PSC, Name),
%	psc_insert(Name, 0, PSC0), term_new(PSC0, F0), F0 = F, N0 = N.


/* ===== current_functor/2 ===================================== */

%   current_functor(?Name, ?Term_Indicator)
%   Succeeds iff Term_Indicator is the most general term corresponding to
%   one of the procedures appearing in the database (both system and user
%   defined but not necessarily loaded in the system) having functor Name.
%   Term_Indicator can have the following forms:
%	 (i) Module:Term.
%	(ii) Term (for global modules)
%   A variable in place of Term_Indicator succeeds only for global
%   modules. Note that the order of term generation is undetermined.

current_functor(Name, Term) :-		% This takes care of global modules.
					% i.e. "usermod" and "global".
	psc_scan_in_hash_table(0, PSC),
	psc_name(PSC, F),
	Name = F,
	psc_arity(PSC, Arity), 
	functor(Term, Name, Arity).
current_functor(Name, Term_Indicator) :-
	nonvar(Term_Indicator),
	Term_Indicator = :(Module, Term),
	get_first_psc_pair(PSC_Pair),
	module_scan(PSC_Pair, ModuleName, ModulePSC),
	ModuleName = Module,
	psc_prop(ModulePSC, First_PSC_Pair),	% get the first psc_pair 
						% of this module
	( First_PSC_Pair =:= 1 ->	% We are dealing with a global module!
		current_functor(Name, Term)
        ; psc_scan_in_module(First_PSC_Pair, PSC),
	  psc_name(PSC, F),
	  Name = F,
	  psc_arity(PSC, Arity),
	  functor(Term, Name, Arity)
	).

/* ===== current_index/2 =================================== */ 

/* Here is how I understand the index encoding to work.  Alternative
indices are put into a list of indices each of which may be simple or
composite.  Any of the 255 arguments of a term can be used as a single
index and is in the least significant byte.  Otherwise, the most
significant bit of a byte (the 128 bit) indicates * indexing.  A
single * index has a l.s. byte of 0 followed by a byte w. the 128-bit
set indicating the * index argument.

In a composite index each byte indicates the argument, and whether or
not the 128 bit is set indicates whether the index is a * index in
each byte.  Unlike simple * indices, the l.s. byte is not set to 0.

*/

current_index(Term,Index):-
	check_nonvar(Term,current_index/2,1),
	current_index_1(Term,Index).
	

current_index_1(F/N,Index):-
	nonvar(F),nonvar(N),
	functor(Term,F,N),!,
	current_index_1(Term,Index).
current_index_1(Term,Index):- 
	'_$index'(Term,Ind,_Size),!,
	decode_index(Ind,Index).
current_index_1(Term,trie):- 
	'_$trie_asserted'(Term),!.
current_index_1(_Term,1).

decode_index([],[]):-!.
decode_index([Ind|Rest],[Index|R]):- !,
	decode_index_in_list(Ind,Index),
	decode_index(Rest,R).
decode_index(Ind,Out):- 
	decode_index([Ind],Out).

decode_index_in_list(Ind,Ind):- 
	0 < Ind,Ind <  256,!.
decode_index_in_list(Ind,IndOut):- 
	decode_star_index(Ind,_,IndOut).

decode_star_index(0,IndIn,IndIn):- !.
decode_star_index(Ind,IndIn,IndOut):- 
	Ind < 256,!,
	I is Ind - 128,
	(I == 0 -> 
	    IndOut = IndIn
	 ;  (var(IndIn) -> 
	        (I < 0 -> IndOut = Ind ; IndOut = *(I))
	      ; (I < 0 -> IndOut = IndIn + Ind ; IndOut = IndIn + *(I) ) ) ).
decode_star_index(Ind,IndIn,IndOut):- 
	PreInd1 is '/\'(Ind,255),
	decode_star_index(PreInd1,IndIn,IndMid),
	IndRest is Ind >> 8,
	decode_star_index(IndRest,IndMid,IndOut).

/* ===== current_input/1 ======================================= */
% TLS: changed on 8/04 for new streams.

current_input(Stream) :- 
	((var(Stream) ; integer(Stream)) -> 
	    true
	 ;  domain_error(stream_or_variable,Stream,current_input/1,1) ),
	stat_flag(CURRENT_INPUT, S),
	S = Stream.

% Obsolescent...
current_input_port(FileDes) :- stat_flag(CURRENT_INPUT, FileDes).


/* ===== current_op/3 ========================================= */
%   current_op(?Operator_Precedence, ?Operator_Specifier, ?Operator_Name)
%   Succeeds iff Operator_Name is an operator with type defined by
%   Operator_Specifier and precedence Operator_Precedence.
%   TLS: added errors acc. to Prolog standard. 8/04

current_op(Prec, Type, Name) :- 
	check_precedence(Prec),
	check_operator_type(Type),
	check_operator_name(Name),
	'_$op'(Prec, Type, Name).

check_precedence(Prec):-
	((var(Prec) ; (integer(Prec),Prec >= 1,Prec =< 1200)) -> 
	    true 
	  ; domain_error(operator_priority,Prec,current_op/3,1) ).

check_operator_type(Type):-
	((var(Type) ; is_operator_type(Type)) -> 
	    true 
	  ; domain_error(operator_specifier,Type,current_op/3,2) ).

is_operator_type(fx).
is_operator_type(fy).
is_operator_type(hx).
is_operator_type(hy).
is_operator_type(xf).
is_operator_type(yf).
is_operator_type(xfx).
is_operator_type(xfy).
is_operator_type(yfx).

check_operator_name(Name):-
	((var(Name) ; atom(Name)) -> 
	    true 
	  ; domain_error(atom_or_variable,Name,current_op/3,3) ).


/* ===== current_output/1 ===================================== */
% TLS: changed on 8/04 for new streams.

current_output(Stream) :- 
	((var(Stream) ; integer(Stream)) -> 
	    true
	 ;  domain_error(variable_or_stream,Stream,current_output/1,1) ),
	stat_flag(CURRENT_OUTPUT, S),
	S = Stream.

% Obsolescent...
current_output_port(FileDes) :- stat_flag(CURRENT_OUTPUT, FileDes).


/* ===== current_predicate/1 ==================================== */

%   current_predicate(?Predicate_Indicator)
%   Succeeds iff Predicate_Indicator is a predicate indicator for one
%   of the loaded procedures in the database (both system and user defined).
%   Predicate_Indicator can have the following forms:
%	 (i) Module:Functor/Arity.
%	(ii) Functor/Arity (for global modules)
%   A variable in place of Predicate_Indicator succeeds only for global
%   modules.
%  TLS: added ISO-style error handling 8/04.
% TLS: redid so that we have a unified semantics for different forms
% of predicate indicators.  09/04

current_predicate(Specifier) :-		% This takes care of global modules.
	(Specifier = Module:Functor/N -> 
	   current_predicate_module(Module,Functor,N)
	;  (Specifier = Functor/N -> 
	      current_predicate_global(Functor,N)
	      ; type_error(term_indicator,Specifier,current_predicate/1,1) ) ).

/*
current_predicate(Specifier) :-		% This takes care of global modules.
	(Specifier = Functor/N -> 
	    current_predicate_global(Functor,N)
	  ; (Specifier = Module:Functor/N -> 
	        current_predicate_module(Module,Functor,N)
	      ; type_error(term_indicator,Specifier,current_predicate/1,1) ) ).
*/
current_predicate_global(Functor,N):- 
	!,				% i.e. "usermod" and "global".
	psc_scan_in_hash_table(0, PSC),
	psc_type(PSC, Type), 
	( Type =:= T_PRED -> true		% Regular loaded predicate.
	; Type =:= T_DYNA -> true		% Dynamic predicate.
	; Type =:= T_FORN			% Foreign predicate.
	),
	psc_arity(PSC, Arity), 
	psc_name(PSC, Name),
	Functor = Name,
	Arity = N.


current_predicate_module(Module,Functor,N) :-
	get_first_psc_pair(PSC_Pair),
	module_scan(PSC_Pair, ModuleName, ModulePSC),
	ModuleName = Module,
	psc_prop(ModulePSC, First_PSC_Pair),	% get the first psc_pair 
						% of this module
	( First_PSC_Pair =:= 1 ->	% We are dealing with a global module!
		current_predicate(Functor/N)
        ; psc_scan_in_module(First_PSC_Pair, PSC), 
          psc_type(PSC, Type), 
	  ( Type =:= T_PRED -> true		% Regular loaded predicate.
	  ; Type =:= T_DYNA -> true		% Dynamic predicate.
	  ; Type =:= T_FORN			% Foreign predicate.
	  ),
	  psc_arity(PSC, Arity), 
	  psc_name(PSC, Name),
	  Functor = Name, 
	  Arity = N
	).

module_scan(PSC_Pair, _, _) :-
	PSC_Pair =:= 0,		% PSC_Pair == NULL
	!,
	fail.
module_scan(PSC_Pair, ModuleName, ModulePSC) :- 
	pair_psc(PSC_Pair, ModulePSC),
	psc_name(ModulePSC, ModuleName).
module_scan(PSC_Pair, NextModuleName, ModulePSC) :- 
	pair_next(PSC_Pair, Next_PSC_Pair),
	module_scan(Next_PSC_Pair, NextModuleName, ModulePSC).

psc_scan_in_module(PSC_Pair, _) :-
	PSC_Pair =:= 0,		% PSC_Pair == NULL
	!,
	fail.
psc_scan_in_module(PSC_Pair, PSC) :-
	pair_psc(PSC_Pair, PSC).
psc_scan_in_module(PSC_Pair, Next_PSC) :- 
	pair_next(PSC_Pair, Next_PSC_Pair),
	psc_scan_in_module(Next_PSC_Pair, Next_PSC).


/* ===== current_predicate/2 =================================== */

%   current_predicate(?Name, ?Term_Indicator)
%   Succeeds iff Term_Indicator is the most general term corresponding to
%   one of the loaded procedures in the database (both system and user
%   defined) having functor Name.
%   Term_Indicator can have the following forms:
%	 (i) Module:Term.
%	(ii) Term (for global modules)
%   A variable in place of Term_Indicator succeeds only for global
%   modules. Note that the order of term generation is undetermined.

current_predicate(Name, Term) :-	% This takes care of global modules.
					% i.e. "usermod" and "global".
	psc_scan_in_hash_table(0, PSC),
	psc_type(PSC, Type),
	( Type =:= T_PRED -> true		% Regular loaded predicate.
	; Type =:= T_DYNA -> true		% Dynamic predicate.
	; Type =:= T_FORN			% Foreign predicate.
	),
	psc_arity(PSC, Arity), 
	psc_name(PSC, F),
	Name = F,
	functor(Term, Name, Arity).
current_predicate(Name, Term_Indicator) :-
	nonvar(Term_Indicator),
	Term_Indicator = :(Module, Term),
	get_first_psc_pair(PSC_Pair),
	module_scan(PSC_Pair, ModuleName, ModulePSC),
	ModuleName = Module,
	psc_prop(ModulePSC, First_PSC_Pair),	% get the first psc_pair 
						% of this module
	( First_PSC_Pair =:= 1 ->	% We are dealing with a global module!
		current_predicate(Name, Term)
	; psc_scan_in_module(First_PSC_Pair, PSC), 
	  psc_type(PSC, Type), 
	  ( Type =:= T_PRED -> true		% Regular loaded predicate.
	  ; Type =:= T_DYNA -> true		% Dynamic predicate.
	  ; Type =:= T_FORN			% Foreign predicate.
	  ),
	  psc_arity(PSC, Arity), 
	  psc_name(PSC, F),
	  Name = F, 
	  functor(Term, Name, Arity)
	).


/* ===== current_module/1 ============================================= */

%   current_module(?Module)
%   Succeeds iff Module is one of the modules in the database. This 
%   includes both user modules and system modules. A module becomes 
%   "current" as soon as it is loaded in the system or when another 
%   module that is loaded in the system imports some predicates from 
%   that module. A module can never lose the property of being "current".

current_module(Module) :- 
	get_first_psc_pair(PSC_Pair),
	scan_modules(PSC_Pair, ModuleName),
	Module = ModuleName.

scan_modules(PSC_Pair, _) :-
	PSC_Pair =:= 0,		% PSC_Pair == NULL
	!,
	fail.
scan_modules(PSC_Pair, ModuleName) :- 
	pair_psc(PSC_Pair, ModulePSC),
	psc_name(ModulePSC, ModuleName).
scan_modules(PSC_Pair, NextModuleName) :- 
	pair_next(PSC_Pair, Next_PSC_Pair),
	scan_modules(Next_PSC_Pair, NextModuleName).


/* ===== current_module/2 ============================================= */

%   current_module(?Module, ?ObjectFile)
%   Gives the relationship between the modules and their associated 
%   module object file names. It is possible for a current module to
%   have no associated object file name or for the system to be unable 
%   to find out the object file name of a current module.

current_module(Module, ObjectFile) :- 
	current_module(Module),
	module_file(Module, ObjectFile).

module_file('xsbrc', File) :-
	!,
	current_predicate('xsbrc':_),	% module .xsbrc is indeed loaded
	!,
	xsb_configuration(user_home, HomeDir),
	slash(Slash),
	fmt_write_string(FileName, '%s%s.xsb%sxsbrc.%s',
			 arg(HomeDir, Slash, Slash,XSB_OBJ_EXTENSION_ATOM)),
	FileName = File.
module_file(ModuleName, File) :-
	str_cat(ModuleName, XSB_OBJ_EXTENSION_ATOM, OFile),
	libpath(Lib),
	str_cat(Lib, OFile, FileName),
	machine_file_exists(FileName),
	!,	% This cut is needed so that we get only one filename
		% as an answer (exactly the one that corresponds to the
		% file that would be consulted when using the loader).
	FileName = File.


/* ===== predicate_property/2 ========================================= */

%   predicate_property(?Predicate_Indicator, ?Property)
%   Succeeds iff predicate Predicate has the property Property.
%   Hacked by Kostis (10/27/92) to make it fast when searching 
%   in a global module with Predicate_Indicator ground.

predicate_property(Term_Indicator, Property) :-
	nonvar(Term_Indicator),
	Term_Indicator = :(Module, Term),
	!,
	get_first_psc_pair(PSC_Pair),
	module_scan(PSC_Pair, ModuleName, ModulePSC),
	ModuleName = Module,
	psc_prop(ModulePSC, First_PSC_Pair),	% get the first psc_pair 
						% of this module
	( First_PSC_Pair =:= 1 ->	% We are dealing with a global module!
		predicate_property(Term, Property)
        ; psc_scan_in_module(First_PSC_Pair, PSC),
	  psc_name(PSC, Name),
	  psc_arity(PSC, Arity),
	  functor(Term, Name, Arity),
	  psc_properties(PSC, Property)
	).
predicate_property(Term, Property) :-	% This takes care of global 
					% modules,"usermod" and "global".
	term_type(Term, Type),
	( Type =:= 1 ->	% Hacked to make it fast when Term is given.
			% If Term is given and it is represented as a structure 
			% (has a PSC record) then using term_psc/2 we get to 
			% this PSC record directly without having to scan the 
			% whole PSC-Pair list.
		term_psc(Term, PSC),
		psc_properties(PSC, Property)
	; Type =:= 5 ->
		conpsc(Term, PSC),
		psc_properties(PSC, Property)
	; psc_scan_in_hash_table(0, PSC),
	  psc_name(PSC, Name),
	  psc_arity(PSC, Arity), 
	  functor(Term, Name, Arity),
	  psc_properties(PSC, Property)
	).

psc_properties(PSC, Property) :- 
	psc_type(PSC, Type),
	( Type =:= T_ORDI -> Property = unclassified
	; Type =:= T_DYNA -> Property = (dynamic)
	; Type =:= T_PRED -> Property = loaded
	; Type =:= T_UDEF -> Property = unloaded
	; Type =:= T_FORN -> Property = foreign
	; Type =:= 14 -> Property = function ).
psc_properties(PSC, Property) :-
	psc_env(PSC, Env),
	( Env =:= T_EXPORTED -> Property = exported
	; Env =:= T_LOCAL -> Property = (local)
	; Env =:= T_IMPORTED -> psc_mod(PSC, ModulePSC), 
		       psc_name(ModulePSC, ModuleName), 
		       Property = imported_from(ModuleName)
	; Property = global ).
psc_properties(PSC, Property) :- 
	psc_spy(PSC, Spy),
	( Spy =\= 0 -> Property = spied ).
psc_properties(PSC, Property) :- 
	psc_tabled(PSC, Tabled),
	( Tabled =\= 0 -> Property = tabled ).
psc_properties(PSC, Property) :- 
	psc_shared(PSC, Shared),
	( Shared =\= 0 -> Property = shared ).
psc_properties(PSC, Property) :-
	psc_name(PSC, Functor),		% Finding the Functor and the Arity
	psc_arity(PSC, Arity),		% twice is silly, isn''t it?
	(	standard_symbol(Functor, Arity, _) ->
		(	Property = xsb_standard_predicate
		;	Property = built_in
		)
	).
	% Unfortunately this doesn''t take the Module into account.

/* ===== module_property/2 ============================================ */

%   module_property(?Module, ?Property)
%   Succeeds iff module Module has the property Property.

module_property(Module, Property) :-
	get_first_psc_pair(PSC_Pair),
	module_scan(PSC_Pair, ModuleName, ModulePSC),
	Module = ModuleName, 
	module_properties(ModulePSC, Property).

module_properties(PSC, Property) :- 
	psc_type(PSC, Type),
	( Type =:=  T_ORDI -> Property = unloaded
	; Type =:=  T_MODU -> Property = loaded ).


/* ===== current_prolog_flag/2 ================================== */

current_prolog_flag(Flag,Value):- 
	((var(Flag) ; atom(Flag)) -> 
	    true
	  ; domain_error(atom_or_variable,Flag,current_prolog_flag/2,1) ),
	  (  iso_flag(Flag,Value) 
           ; xsb_flag(Flag,Value)
           ; prolog_commons_flag(Flag,Value)).

settable_flag(unknown).
settable_flag_value(unknown,error).
settable_flag_value(unknown,fail).
settable_flag_value(unknown,warning).

:- dynamic settable_prolog_flag/2.
:- asserta(settable_prolog_flag(unknown,error)).

set_prolog_flag(Flag,Value) :-
	(atom(Flag)
	 ->	true
	 ;	instantiation_error(set_prolog_flag/2,1,bound)
	),
	(settable_flag(Flag)
	 ->	(atomic(Value)
		 ->	true
		 ;	instantiation_error(set_prolog_flag/2,2,bound)
		),
		(settable_flag_value(Flag,Value)
		 ->	retractall(settable_prolog_flag(Flag,_)),
			asserta(settable_prolog_flag(Flag,Value))
		 ;	findall(Val,settable_flag_value(Flag,Val),Vals),
			make_set_tail(Vals,SetVals),
			domain_error(['{'|SetVals],Value,set_prolog_flag/2,2)
		)
           ; set_xsb_flag(Flag,Value)
% error handled in xsb_flag
%	 ;	domain_error(settable_flag,Flag,set_prolog_flag/2,1)
	).

make_set_tail([Val],[Val,'}']) :- !.
make_set_tail([Val|Vals],[Val,','|SetTail]) :- make_set_tail(Vals,SetTail).

%% fix for 64-bit compilation?
iso_flag(bounded,true).

% TLS: dont understand why we dont just say 7fffffff.
%iso_flag(old_max_integer,Maxint) :- Maxint is 14 * 16'08000000 + 16'0fffffff.
% Also, in 64-bits, we dont seem to get full wordsize.  We have 7 followed by 13 fs rather than by 15?
iso_flag(max_integer,Maxint):- 
	xsb_configuration(word_size,Size),
	(Size == '64' -> 
	    Maxint is 16'7fffffffffffff
	;   Maxint is 16'7fffffff).
%'
iso_flag(min_integer,Minint) :- iso_flag(max_integer,Maxint), Minint is -Maxint - 1.
iso_flag(max_arity,255).
iso_flag(integer_rounding_function,toward_zero).
iso_flag(debug, Debug) :- xsb_flag(debugging, Debug).
iso_flag(unknown, State) :- settable_prolog_flag(unknown, State).
iso_flag(double_quotes,codes).

% TLS: need to understand ISO char conversion
%iso_flag(char_conversion,{on,off})
% TLS: we only do codes...
%iso_flag(double_quotes,{chars,codes,atom}).
% TLS: shd. add
%iso_flag(unknown,{error,warning,fail})

/* ===== prolog_commons_flag/2 ========================================== */

prolog_commons_flag(dialect,xsb).
prolog_commons_flag(version_data,xsb(Maj, Min, 0, _)):- 
	xsb_configuration(major_version,Maj),
	xsb_configuration(minor_version,Min).


/* ===== xsb_flag/2 ========================================== */

%%   xsb_flag(?FlagName, ?Value)
%%   Succeeds if the XSB flag FlagName has the value Value.
%%
%%   IMPORTANT Convention: use xsb_flag for dynamic aspects of XSB setting,
%%   i.e., those that can change between sessions or within a session.
%%   In contrast, xsb_configuration is to be used for settings that are the
%%   same for different sessions and are fixed at XSB build time.

xsb_flag(write_attributes,Value):- 
	stat_flag(WRITE_ATTRIBUTES, V), 
	( V =:= WA_IGNORE -> Value = ignore
	  ;  V =:= WA_DOTS -> Value = dots
	  ;  V =:= WA_PORTRAY -> Value = portray).
xsb_flag(write_depth,Depth):- 
	get_file_write_depth(Depth).
xsb_flag(backtrace_on_error, BT) :-
	stat_flag(BACKTRACE, Value), 
	( Value =:= 0 -> BT = off ; BT = on ).
xsb_flag(debugging, Debug) :-
	stat_flag(DEBUG_ON, Value), 
	( Value =:= 0 -> Debug = off ; Debug = on ).
xsb_flag(tracing, Trace) :-
	stat_flag(TRACE, Value), 
	( Value =:= 0 -> Trace = off ; Trace = on ).
xsb_flag(verboseness,Level) :-
	var(Level),
	stat_flag(VERBOSENESS_LEVEL,Level).
xsb_flag(verboseness,Level) :-
	number(Level),
	stat_set_flag(VERBOSENESS_LEVEL,Level).
%% Goal passed on cmd line
xsb_flag(goal, Goal) :-
	stat_flag(CMD_LINE_GOAL, GoalUninterned),
	intern_string(GoalUninterned, Goal).
xsb_flag(dcg_style, DcgMode) :-
	stat_flag(DCG_MODE, Dcg_flag),
	( Dcg_flag =:= 0 -> DcgMode = xsb ; DcgMode = standard ).
xsb_flag(garbage_collection, GCmode) :-
	xsb_flag(heap_garbage_collection, GCmode).
xsb_flag(heap_garbage_collection, GCmode) :-
	stat_flag(GARBAGE_COLLECT, GCflag),
	( GCflag =:= NO_GC -> GCmode = none
	; GCflag =:= SLIDING_GC -> GCmode = sliding
	; GCflag =:= COPYING_GC -> GCmode = copying
	; GCflag =:= INDIRECTION_SLIDE_GC -> GCmode = indirection
	).
xsb_flag(clause_garbage_collection, OnOff) :-
	stat_flag(CLAUSE_GARBAGE_COLLECT, GCflag),
	( GCflag =:= 0 -> OnOff = off ; OnOff = on ).
xsb_flag(atom_garbage_collection, OnOff) :-
	stat_flag(STRING_GARBAGE_COLLECT, GCflag),
	( GCflag =:= 0 -> OnOff = off ; OnOff = on ).
xsb_flag(gc_verbose_level,Level) :-
	(   var(Level)
	->  stat_flag(VERBOSE_GC,VerboseGC),
	    stat_flag(COUNT_CHAINS,CountYN),
	    stat_flag(EXAMINE_DATA,Examine),
	    Level is VerboseGC + CountYN + Examine
	;   Level = 0
	->  stat_set_flag(VERBOSE_GC,0),
	    stat_set_flag(COUNT_CHAINS,0),
	    stat_set_flag(EXAMINE_DATA,0)
	;   Level = 1
	->  stat_set_flag(VERBOSE_GC,1),
	    stat_set_flag(COUNT_CHAINS,0),
	    stat_set_flag(EXAMINE_DATA,0)
	;   Level = 2
	->  stat_set_flag(VERBOSE_GC,1),
	    stat_set_flag(COUNT_CHAINS,0),
	    stat_set_flag(EXAMINE_DATA,1)
	;   Level = 3
	->  stat_set_flag(VERBOSE_GC,1),
	    stat_set_flag(COUNT_CHAINS,1),
	    stat_set_flag(EXAMINE_DATA,1)
	;   warning('xsb_flag(gc_verbose_level,X) -> X out of bounds.')
	).
xsb_flag(verbose_gc, VerboseGC) :-
	(   var(VerboseGC)
	->  stat_flag(VERBOSE_GC,VerboseGC)
	;   VerboseGC = yes
	->  stat_set_flag(VERBOSE_GC, 1)
	;   VerboseGC = no
	->  stat_set_flag(VERBOSE_GC, 0)
	;   warning('xsb_flag(verbose_gc,X) -> X should be no, yes or unbound.')
	).
xsb_flag(count_chains, CountYN) :-
	(   var(CountYN)
	->  stat_flag(COUNT_CHAINS,CountYN)
	;   CountYN = yes
	->  stat_set_flag(COUNT_CHAINS, 1)
	;   CountYN = no
	->  stat_set_flag(COUNT_CHAINS, 0)
	;   warning('xsb_flag(count_chains,X) -> X should be no, yes or unbound.')
	).
xsb_flag(examine_data, ExamineYN) :-
	(var(ExamineYN)
	->  stat_flag(EXAMINE_DATA, ExamineYN)
	;   ExamineYN = yes
	->  stat_set_flag(EXAMINE_DATA, 1)
	;   ExamineYN = no
	->  stat_set_flag(EXAMINE_DATA,0)
	;   warning('xsb_flag(examine_data,X) -> X should be no, yes or unbound.')
	).
xsb_flag(table_gc_action, Action) :-
	stat_flag(TABLE_GC_ACTION, ActionFlag),
	(ActionFlag == ABOLISH_TABLES_TRANSITIVELY -> 
	    Action = abolish_tables_transitively
	  ; Action = abolish_tables_singly).
xsb_flag(thread_pdlsize, Size) :-
	stat_flag(THREAD_PDLSIZE, Size).
xsb_flag(thread_glsize, Size) :-
	stat_flag(THREAD_GLSIZE, Size).
xsb_flag(thread_tcpsize, Size) :-
	stat_flag(THREAD_TCPSIZE, Size).
xsb_flag(thread_complsize, Size) :-
	stat_flag(THREAD_COMPLSIZE, Size).
xsb_flag(thread_detached, Bool) :-
	stat_flag(THREAD_DETACHED, B),
	(B == 0 -> Bool = false ; Bool = true).
/* Not changeable */
xsb_flag(max_threads, Max) :-
	stat_flag(MAX_THREAD_FLAG, Max).
xsb_flag(max_queue_terms, Max) :-
	stat_flag(MAX_QUEUE_TERMS, Max).
xsb_flag(shared_predicates,Bool):- 
	stat_flag(PRIVSHAR_DEFAULT,B),
	(B == 0 -> Bool = false ; Bool = true).
xsb_flag(warning_action,Action):- 
	stat_flag(WARNING_ACTION,A),
	(A == PRINT_WARNING -> 
	    Action = print_warning
	  ; (A == SILENT_WARNING -> 
	      Action = silent_warning
	     ; A == ERROR_WARNING,Action = error_warning) ).

set_xsb_flag(Type,Val):- 
	check_nonvar(Type,set_xsb_flag/2,1),
	check_nonvar(Val,set_xsb_flag/2,2),
	set_xsb_flag_1(Type,Val).

set_xsb_flag_1(write_depth, Depth) :- !, 
	set_file_write_depth(Depth).
set_xsb_flag_1(backtrace_on_error, BT) :-  !, 
	(BT == off -> Value = 0 ; Value = 1),
	stat_set_flag(BACKTRACE, Value). 
set_xsb_flag_1(debugging, Debug) :-  !, 
	(Debug == off -> Value = 0 ; Value = 1),
	stat_set_flag(DEBUG_ON, Value). 
set_xsb_flag_1(tracing, Trace) :-  !, 
	(Trace == off -> Value = 0 ; Value = 1),
	stat_set_flag(TRACE, Value).
set_xsb_flag_1(verboseness,Level) :-  !, 
	stat_set_flag(VERBOSENESS_LEVEL,Level).
% TLS: dont think setting makes sense here.
%% Goal passed on cmd line
%set_xsb_flag_1(goal, Goal) :-
%	stat_flag(CMD_LINE_GOAL, GoalUninterned),
%	intern_string(GoalUninterned, Goal).
set_xsb_flag_1(dcg_style, DcgMode) :-  !, 
	( DcgMode == xsb -> Value = 0 ; Value = 1 ),
	stat_set_flag(DCG_MODE, Value).
set_xsb_flag_1(garbage_collection, GCmode) :-  !, 
	set_xsb_flag_1(heap_garbage_collection, GCmode).
set_xsb_flag_1(heap_garbage_collection, GCmode) :-  !, 
	( GCmode = none -> GCflag = NO_GC 
	; GCmode = sliding -> GCflag = SLIDING_GC 
	; GCmode = copying -> GCflag = COPYING_GC
	; GCmode = indirection -> GCflag = INDIRECTION_SLIDE_GC
	; domain_error([none,sliding,copying,indirection],
                       GCmode,set_xsb_flag/2,2,'garbage_collection clause')
	),
	stat_set_flag(GARBAGE_COLLECT, GCflag).
set_xsb_flag_1(write_attributes,Code) :-  !, 
	( Code = ignore -> Flag = WA_IGNORE
	; Code = dots -> Flag = WA_DOTS
	; Code = portray -> Flag = WA_PORTRAY
	; domain_error([ignore,dots,portray],
                       Code,set_xsb_flag/2,2,'write_attributes clause')
	),
	stat_set_flag(WRITE_ATTRIBUTES, Flag).
set_xsb_flag_1(clause_garbage_collection, OnOff) :-  !, 
	( OnOff == off -> Value = 0 ; Value = 1 ),
	stat_set_flag(CLAUSE_GARBAGE_COLLECT, Value).
set_xsb_flag_1(atom_garbage_collection, OnOff) :-  !, 
	( OnOff == off -> Value = 0 ; Value = 1 ),
	stat_set_flag(STRING_GARBAGE_COLLECT, Value).
set_xsb_flag_1(gc_verbose_level,Level) :-  !, 
	(   Level = 0
	-> stat_set_flag(VERBOSE_GC,0),
	    stat_set_flag(COUNT_CHAINS,0),
	    stat_set_flag(EXAMINE_DATA,0)
	;   Level = 1
	->  stat_set_flag(VERBOSE_GC,1),
	    stat_set_flag(COUNT_CHAINS,0),
	    stat_set_flag(EXAMINE_DATA,0)
	;   Level = 2
	->  stat_set_flag(VERBOSE_GC,1),
	    stat_set_flag(COUNT_CHAINS,0),
	    stat_set_flag(EXAMINE_DATA,1)
	;   Level = 3
	->  stat_set_flag(VERBOSE_GC,1),
	    stat_set_flag(COUNT_CHAINS,1),
	    stat_set_flag(EXAMINE_DATA,1)
	;   domain_error([0,1,2,3],Level,set_xsb_flag/2,2,'gc_verbose_level clause')
	).
set_xsb_flag_1(verbose_gc, VerboseGC) :-  !, 
	(   VerboseGC = yes
	->  stat_set_flag(VERBOSE_GC, 1)
	;   VerboseGC = no
	->  stat_set_flag(VERBOSE_GC, 0)
	;     domain_error([0,1],VerboseGC,set_xsb_flag/2,2,'verbose_gc clause')
	).
set_xsb_flag_1(count_chains, CountYN) :-  !, 
	(   CountYN = yes
	->  stat_set_flag(COUNT_CHAINS, 1)
	;   CountYN = no
	->  stat_set_flag(COUNT_CHAINS, 0)
	;     domain_error([0,1],CountYN,set_xsb_flag/2,2,'count_chains clause')
	).
set_xsb_flag_1(examine_data, ExamineYN) :-  !, 
	(   ExamineYN = yes
	->  stat_set_flag(EXAMINE_DATA, 1)
	;   ExamineYN = no
	->  stat_set_flag(EXAMINE_DATA,0)
	;     domain_error([0,1],ExamineYN,set_xsb_flag/2,2,
	                  'examine_data clause')
	).
set_xsb_flag_1(table_gc_action, Action) :- !,
	(Action = abolish_tables_transitively -> 
	    stat_set_flag(TABLE_GC_ACTION, ABOLISH_TABLES_TRANSITIVELY)
	 ;  (Action = abolish_tables_singly -> 
	       stat_set_flag(TABLE_GC_ACTION, ABOLISH_TABLES_SINGLY)
	     ; domain_error([abolish_tables_transitively,', ',
	                     abolish_tables_singly],Action,set_xsb_flag/2,2,
			     'table_gc_action clause') ) ).
set_xsb_flag_1(thread_pdlsize, Size) :-!,
	stat_set_flag(THREAD_PDLSIZE, Size).
set_xsb_flag_1(thread_glsize, Size) :-!,
	stat_set_flag(THREAD_GLSIZE, Size).
set_xsb_flag_1(thread_tcpsize, Size) :-!,
	stat_set_flag(THREAD_TCPSIZE, Size).
set_xsb_flag_1(thread_complsize, Size) :-!,
	stat_set_flag(THREAD_COMPLSIZE, Size).
set_xsb_flag_1(thread_detached, Bool) :- !,
	(Bool == true -> B = 1 ; B = 0),
	stat_set_flag(THREAD_DETACHED, B).
set_xsb_flag_1(max_queue_terms, Num) :- !,
	(integer(Num) -> 
	    stat_set_flag(MAX_QUEUE_TERMS, Num)
	;   type_error(integer,Num,set_xsb_flag/2,2) ).
set_xsb_flag_1(warning_action,Action):- !,
	(Action == print_warning ->  A = PRINT_WARNING
	  ; (Action == silent_warning ->  A = SILENT_WARNING
	     ; (Action == error_warning ->  A = ERROR_WARNING
	        ; domain_error([print_warning,', ',silent_warning,', ',error_warning],
	                        Action,set_xsb_flag/2,2,'warning_action clause') ) ) ),
	 stat_set_flag(WARNING_ACTION,A).
set_xsb_flag_1(Type, _) :-  
	domain_error(prolog_flag,Type,set_prolog_flag/2,1).

/* ==================================================================== */

garbage_collection(GC) :- var(GC), !,
	abort('Uninstantiated argument 1 of garbage_collection/1').
garbage_collection(none) :- !, stat_set_flag(GARBAGE_COLLECT, NO_GC).
garbage_collection(sliding) :- !, stat_set_flag(GARBAGE_COLLECT, SLIDING_GC).
garbage_collection(copying) :- !, stat_set_flag(GARBAGE_COLLECT, COPYING_GC).
garbage_collection(indirection) :- !, stat_set_flag(GARBAGE_COLLECT, INDIRECTION_SLIDE_GC).
garbage_collection(_) :-
	abort('Wrong type in argument 1 of garbage_collection/1').


/* ===== hilog_symbol/1 =============================================== */

%   hilog_symbol(?Symbol)
%   Succeeds iff Symbol is one of the symbols that are declared as HiLog.

hilog_symbol(HS) :- 
	'_$hilog_symbol'(HS).

/* ===== Auxilliary Predicates ======================================== */

get_first_psc_pair(PSC_Pair) :-
	stat_flag(MOD_LIST, PSC_Pair).

/* ----------------- end of file current_symbols.P -------------------- */
